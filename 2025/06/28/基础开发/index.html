<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>基础开发 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="HTMLCanvas和SVG   特性 Canvas SVG    类型 位图（像素操作） 矢量图（XML 描述）   渲染方式 即时模式（绘制后不保留对象） 保留模式（DOM 树存储对象）   分辨率依赖 依赖分辨率（放大失真） 独立分辨率（无限缩放不失真）   事件处理 需手动计算坐标（无内置事件） 支持 DOM 事件（如 click&#x2F;hover）   性能 适合高频重绘（如游戏&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="基础开发">
<meta property="og:url" content="http://example.com/2025/06/28/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="HTMLCanvas和SVG   特性 Canvas SVG    类型 位图（像素操作） 矢量图（XML 描述）   渲染方式 即时模式（绘制后不保留对象） 保留模式（DOM 树存储对象）   分辨率依赖 依赖分辨率（放大失真） 独立分辨率（无限缩放不失真）   事件处理 需手动计算坐标（无内置事件） 支持 DOM 事件（如 click&#x2F;hover）   性能 适合高频重绘（如游戏&amp;#">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/23353.jpg">
<meta property="og:image" content="http://example.com/img/13609.jpg">
<meta property="og:image" content="http://example.com/img/14468.jpg">
<meta property="og:image" content="c:\Users\Zhangwenye\Desktop\%E5%8D%9A%E5%AE%A2\source\img\4611.jpg">
<meta property="og:image" content="http://example.com/img/132257ri1tw184gtv3vu8t.png">
<meta property="og:image" content="http://example.com/img/image-20240216221556720.png">
<meta property="og:image" content="http://example.com/img/image-20240216221930349.png">
<meta property="og:image" content="http://example.com/img/image-20240216222103472.png">
<meta property="og:image" content="http://example.com/img/image-20240216222423936.png">
<meta property="og:image" content="http://example.com/img/image-20240217084901274.png">
<meta property="og:image" content="http://example.com/img/image-20240217094012495.png">
<meta property="og:image" content="http://example.com/img/image-20240217100208940.png">
<meta property="og:image" content="http://example.com/img/image-20240217100229047.png">
<meta property="article:published_time" content="2025-06-28T13:03:52.000Z">
<meta property="article:modified_time" content="2025-06-30T01:24:23.156Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="html css javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/23353.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-基础开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/28/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2025-06-28T13:03:52.000Z" itemprop="datePublished">2025-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      基础开发
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="Canvas和SVG"><a href="#Canvas和SVG" class="headerlink" title="Canvas和SVG"></a>Canvas和SVG</h2><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>Canvas</strong></th>
<th align="center"><strong>SVG</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型</strong></td>
<td align="left">位图（像素操作）</td>
<td align="center">矢量图（XML 描述）</td>
</tr>
<tr>
<td align="left"><strong>渲染方式</strong></td>
<td align="left">即时模式（绘制后不保留对象）</td>
<td align="center">保留模式（DOM 树存储对象）</td>
</tr>
<tr>
<td align="left"><strong>分辨率依赖</strong></td>
<td align="left">依赖分辨率（放大失真）</td>
<td align="center">独立分辨率（无限缩放不失真）</td>
</tr>
<tr>
<td align="left"><strong>事件处理</strong></td>
<td align="left">需手动计算坐标（无内置事件）</td>
<td align="center">支持 DOM 事件（如 click&#x2F;hover）</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">适合高频重绘（如游戏&#x2F;动画）</td>
<td align="center">元素过多时性能下降</td>
</tr>
<tr>
<td align="left"><strong>输出格式</strong></td>
<td align="left">生成 PNG&#x2F;JPG</td>
<td align="center">XML 文本（可被 CSS&#x2F;JS 操作）</td>
</tr>
<tr>
<td align="left"><strong>文本渲染</strong></td>
<td align="left">支持基础文本（无富文本）</td>
<td align="center">支持完整文本操作（含 CSS 样式）</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">低（无对象存储）</td>
<td align="center">高（每个元素占用 DOM 节点）</td>
</tr>
</tbody></table>
<h2 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h2><p><strong>src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</strong> </p>
<p>（1）src</p>
<p>src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src =”js.<span class="property">js</span>”&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js 脚本放在底部而不是头部。 </p>
<p>（2）href</p>
<p>href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果在文档中添加 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=”common.<span class="property">css</span>” rel=”stylesheet”/&gt;</span><br></pre></td></tr></table></figure>

<p>那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。</p>
<h2 id="常⽤的meta标签有哪些"><a href="#常⽤的meta标签有哪些" class="headerlink" title="常⽤的meta标签有哪些"></a>常⽤的meta标签有哪些</h2><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。</p>
<p>常用的meta标签：</p>
<p>（1）<code>charset</code>，用来描述HTML文档的编码类型：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>（2） <code>keywords</code>，页面关键词：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;关键词&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）<code>description</code>，页面描述：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;页面描述内容&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）<code>refresh</code>，页面重定向和刷新：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li><code>width viewport</code> ：宽度(数值&#x2F;device-width)</li>
<li><code>height viewport</code> ：高度(数值&#x2F;device-height)</li>
<li><code>initial-scale</code> ：初始缩放比例</li>
<li><code>maximum-scale</code> ：最大缩放比例</li>
<li><code>minimum-scale</code> ：最小缩放比例</li>
<li><code>user-scalable</code> ：是否允许用户缩放(yes&#x2F;no）</li>
</ul>
<p>（6）搜索引擎索引方式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li><code>all</code>：文件将被检索，且页面上的链接可以被查询；</li>
<li><code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li>
<li><code>index</code>：文件将被检索；</li>
<li><code>follow</code>：页面上的链接可以被查询；</li>
<li><code>noindex</code>：文件将不被检索；</li>
<li><code>nofollow</code>：页面上的链接不可以被查询</li>
</ul>
<h2 id="iframe-有那些优点和缺点？"><a href="#iframe-有那些优点和缺点？" class="headerlink" title="iframe 有那些优点和缺点？"></a><strong>iframe 有那些优点和缺点？</strong></h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p>
<p><strong>优点：</strong></p>
<ul>
<li>用来加载速度较慢的内容（如广告）</li>
<li>可以使脚本可以并行下载</li>
<li>可以实现跨子域通信</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>iframe 会阻塞主页面的 onload 事件</li>
<li>无法被一些搜索引擎索识别</li>
<li>会产生很多页面，不容易管理</li>
</ul>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><p><strong>1、层叠性（Cascading）</strong></p>
<p><strong>定义</strong>：当多个 CSS 规则作用于同一元素时，浏览器根据特定规则”层叠”这些样式，最终确定生效的样式。</p>
<p><strong>核心规则</strong>（按顺序判断）：</p>
<ol>
<li><p><strong>来源顺序</strong>：后出现的规则覆盖先出现的规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &#123; color: blue; &#125;</span><br><span class="line">p &#123; color: red; &#125; /* 最终生效 */</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>来源重要性</strong>（优先级从低到高）：</p>
<ul>
<li>浏览器默认样式</li>
<li>用户样式表（普通）</li>
<li>作者样式表（开发者写的普通样式）</li>
<li>作者样式表（<code>!important</code>）</li>
<li>用户样式表（<code>!important</code>）</li>
</ul>
</li>
<li><p><strong><code>!important</code> 标志</strong>：打破常规优先级</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: blue <span class="meta">!important</span>; <span class="comment">/* 最终生效 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.special</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: red; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>2、继承性（Inheritance）</strong></p>
<p><strong>定义</strong>：某些 CSS 属性会自动从父元素传递到子元素。</p>
<p><strong>核心特点</strong>：</p>
<ol>
<li><p><strong>可继承属性</strong>（约 30%）：</p>
<ul>
<li>文本相关：<code>font-family</code>, <code>color</code>, <code>line-height</code>, <code>text-align</code></li>
<li>列表相关：<code>list-style-type</code></li>
<li>可见性：<code>visibility</code></li>
<li>表格边框：<code>border-collapse</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: blue&quot;</span>&gt;</span></span><br><span class="line">  父元素文字</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>子元素继承蓝色文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 自动继承 color 属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不可继承属性</strong>（约 70%）：</p>
<ul>
<li>盒模型：<code>width</code>, <code>height</code>, <code>margin</code>, <code>padding</code>, <code>border</code></li>
<li>定位：<code>position</code>, <code>top</code>, <code>left</code></li>
<li>背景：<code>background-color</code></li>
</ul>
</li>
<li><p><strong>强制继承</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.child &#123;</span><br><span class="line">  border: inherit; /* 强制继承父元素的边框 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>3、优先级（Specificity）</strong></p>
<p><strong>定义</strong>：当多个选择器作用于同一元素时，通过权重计算确定哪个规则生效。</p>
<p><strong>权重计算规则</strong>（从高到低）：</p>
<table>
<thead>
<tr>
<th align="left">选择器类型</th>
<th align="left">示例</th>
<th align="left">权重值（a,b,c,d）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">行内样式</td>
<td align="left"><code>style=&quot;...&quot;</code></td>
<td align="left">1,0,0,0</td>
</tr>
<tr>
<td align="left">ID 选择器</td>
<td align="left"><code>#header</code></td>
<td align="left">0,1,0,0</td>
</tr>
<tr>
<td align="left">类&#x2F;伪类&#x2F;属性选择器</td>
<td align="left"><code>.btn</code>, <code>:hover</code></td>
<td align="left">0,0,1,0</td>
</tr>
<tr>
<td align="left">元素&#x2F;伪元素选择器</td>
<td align="left"><code>div</code>, <code>::before</code></td>
<td align="left">0,0,0,1</td>
</tr>
<tr>
<td align="left">通配符&#x2F;关系选择器</td>
<td align="left"><code>*</code>, <code>&gt;</code>, <code>+</code></td>
<td align="left">0,0,0,0</td>
</tr>
</tbody></table>
<p><strong>计算示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#nav .item:hover &#123;&#125;   /* 权重：0,1,2,0 (ID×1 + 类×2) */</span><br><span class="line">header#top h1.title &#123;&#125; /* 权重：0,1,1,2 (ID×1 + 类×1 + 元素×2) */</span><br></pre></td></tr></table></figure>

<p><strong>比较规则</strong>：</p>
<ol>
<li>从左到右逐级比较：<code>a</code> &gt; <code>b</code> &gt; <code>c</code> &gt; <code>d</code></li>
<li><code>!important</code> &gt; 行内样式 &gt; ID &gt; 类 &gt; 元素</li>
<li>相同权重时，后定义的生效</li>
</ol>
<h2 id="CSS选择器与优先级"><a href="#CSS选择器与优先级" class="headerlink" title="CSS选择器与优先级"></a><strong>CSS选择器与优先级</strong></h2><ul>
<li>!important声明的样式的优先级最高；</li>
<li>如果优先级相同，则最后出现的样式生效；</li>
<li>继承得到的样式的优先级最低；</li>
<li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li>
<li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li>
</ul>
<h2 id="display的属性值及其作用"><a href="#display的属性值及其作用" class="headerlink" title="display的属性值及其作用"></a>display的属性值及其作用</h2><table>
<thead>
<tr>
<th><strong>属性值</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>元素不显示，并且会从文档流中移除。</td>
</tr>
<tr>
<td>block</td>
<td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td>
</tr>
<tr>
<td>inline</td>
<td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td>
</tr>
<tr>
<td>inline-block</td>
<td>默认宽度为内容宽度，可以设置宽高，同行显示。</td>
</tr>
<tr>
<td>list-item</td>
<td>像块类型元素一样显示，并添加样式列表标记。</td>
</tr>
<tr>
<td>table</td>
<td>此元素会作为块级表格来显示。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承display属性的值。</td>
</tr>
</tbody></table>
<h3 id="display的block、inline和inline-block的区别"><a href="#display的block、inline和inline-block的区别" class="headerlink" title="display的block、inline和inline-block的区别"></a>display的block、inline和inline-block的区别</h3><p>　（1）**block：**会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p>
<p>　（2）**inline：**元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p>
<p>　（3）**inline-block：**将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>block (块级)</strong></th>
<th align="left"><strong>inline (行内)</strong></th>
<th align="center"><strong>inline-block (行内块)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>是否独占一行</strong></td>
<td align="left">✅ 独占整行</td>
<td align="left">❌ 与其他行内元素共享一行</td>
<td align="center">❌ 与其他行内元素共享一行</td>
</tr>
<tr>
<td align="left"><strong>尺寸设置</strong></td>
<td align="left">✅ 可设置宽高，默认撑开父元素宽度由</td>
<td align="left">❌ 默认宽高由内容决定</td>
<td align="center">✅ 可设置宽高，默认宽高由内容决定</td>
</tr>
<tr>
<td align="left"><strong>盒模型属性</strong></td>
<td align="left">✅ 完整 margin&#x2F;padding</td>
<td align="left">❌ 仅水平方向 margin&#x2F;padding</td>
<td align="center">✅ 完整 margin&#x2F;padding</td>
</tr>
<tr>
<td align="left"><strong>默认排列方式</strong></td>
<td align="left">垂直堆叠</td>
<td align="left">水平排列</td>
<td align="center">水平排列</td>
</tr>
<tr>
<td align="left"><strong>包含关系</strong></td>
<td align="left">可包含其他块级&#x2F;行内元素</td>
<td align="left">只能包含行内元素</td>
<td align="center">可包含其他块级&#x2F;行内元素</td>
</tr>
<tr>
<td align="left"><strong>典型默认元素</strong></td>
<td align="left"><code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;-&lt;h6&gt;</code></td>
<td align="left"><code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code></td>
<td align="center"><code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;button&gt;</code></td>
</tr>
</tbody></table>
<p><img src="/../img/23353.jpg"></p>
<p><strong>1. 空白间隙问题 (inline-block)</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Item1<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  <span class="comment">&lt;!-- 这里有换行符 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Item2<span class="tag">&lt;/<span class="name">span</span>&gt;</span>   <span class="comment">&lt;!-- 显示时产生 4px 间隙 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong>：</p>
<ul>
<li>父元素设置 <code>font-size: 0</code>（需重置子元素字体）</li>
<li>使用负 margin：<code>margin-right: -4px</code></li>
<li>删除 HTML 标签间的空白</li>
</ul>
<p><strong>2.垂直对齐控制</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inline-block</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: top; <span class="comment">/* 可选值: top/middle/bottom */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 行内元素边距陷阱</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">20px</span>; <span class="comment">/* 仅左右生效，上下无效！ */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="comment">/* 上下padding会覆盖其他行但无位移 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>作用：<strong>选中特殊状态的元素</strong> </p>
<p>如何理解“伪” ? — 虚假的，不是真的。 </p>
<p>如何理解“伪类”？</p>
<ol>
<li>— 像类( class )，但不是类，是元素的一种特殊状态。</li>
</ol>
<p>常用的伪类选择器： </p>
<p>一、动态伪类： </p>
<p>:link 超链接未被访问的状态。</p>
<p>:visited 超链接访问过的状态。 </p>
<p>:hover 鼠标悬停在元素上的状态。</p>
<p>:active 元素激活的状态。 什么是激活？—— 按下鼠标不松开。注意点：遵循 LVHA 的顺序，即： link 、 visited 、 hover 、 active 。 </p>
<p>:focus 获取焦点的元素。 </p>
<p>表单类元素才能使用 :focus 伪类。 当用户：点击元素、触摸元素、或通过键盘的 “ tab ” 键等方式，选择元素时，就是获 得焦点。 </p>
<p>二、结构伪类 </p>
<ol>
<li><p>:first-child 所有兄弟元素中的第一个。</p>
</li>
<li><p>:last-child 所有兄弟元素中的最后一个。</p>
</li>
<li><p>:nth-child(n) 所有兄弟元素中的第 n 个。 </p>
</li>
<li><p>:first-of-type 所有同类型兄弟元素中的第一个。 </p>
</li>
<li><p>:last-of-type 所有同类型兄弟元素中的最后一个。 </p>
</li>
<li><p>:nth-of-type(n) 所有同类型兄弟元素中的 第n个 。 </p>
<p>关于 n 的值： 1. 0 或 不写 ：什么都选不中 —— 几乎不用。 2. n ：选中所有子元素 —— 几乎不用。 3. 1~正无穷的整数 ：选中对应序号的子元素。 4. 2n 或 even ：选中序号为偶数的子元素。 5. 2n+1 或 odd ：选中序号为奇数的子元素。 6. -n+3 ：选中的是前 3 个。 div[title^&#x3D;”a”]{color:red;} &#x2F;* 选中title属性值以u结尾的元素 <em>&#x2F; div[title$&#x3D;”u”]{color:red;} &#x2F;</em> 选中title属性值包含g的元素 <em>&#x2F; div[title</em>&#x3D;”g”]{color:red;} 了解即可： 1. :nth-last-child(n) 所有兄弟元素中的倒数第 n 个。 2. :nth-last-of-type(n) 所有同类型兄弟元素中的 倒数第n个 。 3. :only-child 选择没有兄弟的元素（独生子女）。 4. :only-of-type 选择没有同类型兄弟的元素。 5. :root 根元素。 6. :empty 内容为空元素（空格也算内容）。 </p>
<p>三、否定伪类： :not(选择器) 排除满足括号中条件的元素。</p>
<p>四、UI伪类： </p>
<ol>
<li><p>:checked 被选中的复选框或单选按钮。 </p>
</li>
<li><p>:enable 可用的表单元素（没有 disabled 属性）。 </p>
</li>
<li><p>:disabled 不可用的表单元素（有 disabled 属性）。</p>
</li>
</ol>
</li>
</ol>
<p>​      </p>
<pre><code>  五、目标伪类（了解） :target 选中锚点指向的元素。 

  六、语言伪类（了解） :lang() 根据指定的语言选择元素（本质是看 lang 属性的值）。
</code></pre>
<h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><p><img src="/../img/13609.jpg"></p>
<h2 id="百分比计算规则"><a href="#百分比计算规则" class="headerlink" title="百分比计算规则"></a>百分比计算规则</h2><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">百分比计算基础</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>width</code></td>
<td align="left">父元素的内容宽度</td>
<td align="left">父元素width: 600px，子元素width: 50% → 300px</td>
</tr>
<tr>
<td align="left"><code>height</code></td>
<td align="left">父元素的内容高度</td>
<td align="left">父元素height: 400px，子元素height: 50% → 200px</td>
</tr>
<tr>
<td align="left"><code>padding</code></td>
<td align="left">父元素的内容宽度</td>
<td align="left">父元素width: 800px，padding: 10% → 80px</td>
</tr>
<tr>
<td align="left"><code>margin</code></td>
<td align="left">父元素的内容宽度</td>
<td align="left">父元素width: 1000px，margin: 5% → 50px</td>
</tr>
<tr>
<td align="left"><code>top/bottom</code></td>
<td align="left">包含块的高度</td>
<td align="left">包含块height: 500px，top: 20% → 100px</td>
</tr>
<tr>
<td align="left"><code>left/right</code></td>
<td align="left">包含块的宽度</td>
<td align="left">包含块width: 1200px，left: 15% → 180px</td>
</tr>
<tr>
<td align="left"><code>font-size</code></td>
<td align="left">父元素的字体大小</td>
<td align="left">父元素font-size: 16px，子元素font-size: 150% → 24px</td>
</tr>
<tr>
<td align="left"><code>line-height</code></td>
<td align="left">元素自身的字体大小</td>
<td align="left">元素font-size: 20px，line-height: 150% → 30px</td>
</tr>
<tr>
<td align="left"><code>background-position</code></td>
<td align="left">(容器尺寸 - 背景图尺寸)</td>
<td align="left">容器宽度1000px，图片宽度800px，background-position: 50% → 100px</td>
</tr>
<tr>
<td align="left"><code>transform: translate()</code></td>
<td align="left">元素自身的尺寸</td>
<td align="left">元素width: 200px，translateX(50%) → 100px</td>
</tr>
<tr>
<td align="left"><code>border-radius</code></td>
<td align="left">元素自身的尺寸</td>
<td align="left">元素200px×100px，border-radius: 50% → 100px&#x2F;50</td>
</tr>
</tbody></table>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>margin（外边距）： 盒子与外界的距离。 </p>
<ul>
<li>子元素的 margin ，是参考父元素的 content 计算的。（因为是父亲的 content 中承装着 子元素） </li>
<li>上 margin 、左 margin ：影响自己的位置；下 margin 、右 margin ：影响后面兄弟元素 的位置。 </li>
<li>块级元素、行内块元素，均可以完美地设置四个方向的 margin ；但行内元素，左右 margin 可以完美设置，上下 margin 设置无效。 </li>
<li>margin 的值也可以是 auto ，如果给一个块级元素设置左右 margin 都为 auto ，该块级 元素会在父元素中水平居中。 </li>
<li><strong>margin 的值可以是负值。</strong></li>
</ul>
<p><img src="/../img/14468.jpg"></p>
<p>border（边框）： 盒子的边框。 </p>
<p>padding（内边距）： 紧贴内容的补白区域。 </p>
<ul>
<li><strong>padding 的值不能为负数</strong> </li>
<li>行内元素 的 左右内边距是没问题的，上下内边距不能完美的设置。 </li>
<li>块级元素、行内块元素，四个方向内边距都可以完美设置<br><strong>百分比计算来源为父元素宽度</strong></li>
</ul>
<p>content（内容）：元素中的文本或后代元素都是它的内容。</p>
<p><img src="C:\Users\Zhangwenye\Desktop\博客\source\img\4611.jpg"></p>
<h2 id="文本溢出"><a href="#文本溢出" class="headerlink" title="文本溢出"></a>文本溢出</h2><ul>
<li>单行文本溢出</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行</span><br></pre></td></tr></table></figure>

<ul>
<li>多行文本溢出</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-<span class="attribute">box-orient</span>:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-<span class="selector-tag">line</span>-clamp:<span class="number">3</span>;        // 显示的行数</span><br></pre></td></tr></table></figure>

<p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器</p>
<h2 id="CSS中可继承与不可继承属性"><a href="#CSS中可继承与不可继承属性" class="headerlink" title="CSS中可继承与不可继承属性"></a>CSS中可继承与不可继承属性</h2><p><strong>一、无继承性的属性</strong></p>
<ol>
<li><strong>display</strong>：规定元素应该生成的框的类型</li>
<li><strong>文本属性</strong>：</li>
</ol>
<ul>
<li>vertical-align：垂直文本对齐</li>
<li>text-decoration：规定添加到文本的装饰</li>
<li>text-shadow：文本阴影效果</li>
<li>white-space：空白符的处理</li>
<li>unicode-bidi：设置文本的方向</li>
</ul>
<ol>
<li><strong>盒子模型的属性</strong>：width、height、margin、border、padding</li>
<li><strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li>
<li><strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li>
<li><strong>生成内容属性</strong>：content、counter-reset、counter-increment</li>
<li><strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li>
<li><strong>页面样式属性</strong>：size、page-break-before、page-break-after</li>
<li><strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li>
</ol>
<p><strong>二、有继承性的属性</strong></p>
<ol>
<li><strong>字体系列属性</strong></li>
</ol>
<ul>
<li>font-family：字体系列</li>
<li>font-weight：字体的粗细</li>
<li>font-size：字体的大小</li>
<li>font-style：字体的风格</li>
</ul>
<ol>
<li><strong>文本系列属性</strong></li>
</ol>
<ul>
<li>text-indent：文本缩进</li>
<li>text-align：文本水平对齐</li>
<li>line-height：行高</li>
<li>word-spacing：单词之间的间距</li>
<li>letter-spacing：中文或者字母之间的间距</li>
<li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li>
<li>color：文本颜色</li>
</ul>
<ol>
<li><strong>元素可见性</strong></li>
</ol>
<ul>
<li>visibility：控制元素显示隐藏</li>
</ul>
<ol>
<li><strong>列表布局属性</strong></li>
</ol>
<ul>
<li>list-style：列表风格，包括list-style-type、list-style-image等</li>
</ul>
<ol>
<li><strong>光标属性</strong></li>
</ol>
<ul>
<li>cursor：光标显示为何种形态</li>
</ul>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><ul>
<li>脱离文档流</li>
<li>不管浮动前是什么元素，浮动后：默认宽与高都是被内容撑开（尽可能小），而且可以设置宽高</li>
<li>不会独占一行，可以与其他元素共用一行 </li>
<li>不会 margin 合并，也不会 margin 塌陷，能够完美的设置四个方向的 margin 和 padding </li>
<li>不会像行内块一样被当做文本处理（没有行内块的空白问题）</li>
</ul>
<p><strong>元素浮动后会有哪些影响</strong><br>对兄弟元素的影响： 后面的兄弟元素，会占据浮动元素之前的位置，在浮动元素的下面；对前面的兄弟无影响。 </p>
<p>对父元素的影响： 不能撑起父元素的高度，导致父元素高度塌陷；但父元素的宽度依然束缚浮动的元素。 </p>
<p><strong>解决浮动产生的影响（清除浮动）</strong><br>解决方案： </p>
<ul>
<li>方案一： 给父元素指定高度 </li>
<li>方案二： 给父元素也设置浮动，带来其他影响</li>
<li>方案三： 给父元素设置 overflow:hidden </li>
<li>方案四： 在所有浮动元素的最后面，添加一个块级元素，并给该块级元素设置 clear:both </li>
<li>方案五： 给浮动元素的父元素，设置伪元素，通过伪元素清除浮动，原理与方案四相同。&#x3D;&#x3D;&#x3D;&gt; 推 荐使用 布局中的一个原则：设置浮动的时候，兄弟元素要么全都浮动，要么全都不浮动</li>
</ul>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><table>
<thead>
<tr>
<th align="left">定位类型</th>
<th align="left">定位基准</th>
<th align="left">是否脱离文档流</th>
<th align="left">特点</th>
<th align="left">常见应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>static</strong></td>
<td align="left">正常文档流</td>
<td align="left">否</td>
<td align="left">默认定位，不受 top&#x2F;right&#x2F;bottom&#x2F;left 影响</td>
<td align="left">普通文档流布局</td>
</tr>
<tr>
<td align="left"><strong>relative</strong></td>
<td align="left">自身原始位置</td>
<td align="left">否</td>
<td align="left">保留原始空间，相对自身偏移</td>
<td align="left">微调元素位置，作为 absolute 的参照</td>
</tr>
<tr>
<td align="left"><strong>absolute</strong></td>
<td align="left">最近的定位祖先元素</td>
<td align="left">是</td>
<td align="left">完全脱离文档流，不保留空间</td>
<td align="left">弹出层、下拉菜单、图标定位</td>
</tr>
<tr>
<td align="left"><strong>fixed</strong></td>
<td align="left">浏览器视口</td>
<td align="left">是</td>
<td align="left">固定于视口位置，不随滚动移动</td>
<td align="left">固定导航栏、悬浮按钮</td>
</tr>
<tr>
<td align="left"><strong>sticky</strong></td>
<td align="left">最近的滚动祖先</td>
<td align="left">否（直到达到阈值）</td>
<td align="left">混合定位，达到阈值后固定</td>
<td align="left">粘性导航、表头固定</td>
</tr>
</tbody></table>
<h3 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h3><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：</p>
<p><img src="/../img/132257ri1tw184gtv3vu8t.png" alt="img"></p>
<p>对于上图，由上到下分别是：</p>
<p>（1）背景和边框：建立当前层叠上下文元素的背景和边框。</p>
<p>（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。</p>
<p>（3）块级盒：文档流内非行内级非定位后代元素。</p>
<p>（4）浮动盒：非定位浮动元素。</p>
<p>（5）行内盒：文档流内行内级非定位后代元素。</p>
<p>（6）z-index:0：层叠级数为0的定位元素。</p>
<p>（7）正z-index：z-index属性值为正的定位元素。</p>
<p>使用clear:both吧。</p>
<p>一般使用伪元素的方式清除浮动：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block; </span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p>
<h2 id="对BFC的理解，如何创建BFC"><a href="#对BFC的理解，如何创建BFC" class="headerlink" title="对BFC的理解，如何创建BFC"></a>对BFC的理解，如何创建BFC</h2><p>先来看两个相关的概念：</p>
<ul>
<li>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。 </li>
<li>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li>
</ul>
<p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>
<p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p>
<p><strong>创建BFC的条件：</strong></p>
<ul>
<li>根元素：body；</li>
<li>元素设置浮动：float 除 none 以外的值；</li>
<li>元素设置绝对定位：position (absolute、fixed)；</li>
<li>display 值为：inline-block、table-cell、table-caption、flex等；</li>
<li>overflow 值为：hidden、auto、scroll；</li>
</ul>
<p><strong>BFC的特点：</strong></p>
<ul>
<li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li>
<li>在BFC中上下相邻的两个容器的margin会重叠</li>
<li>计算BFC的高度时，需要计算浮动元素的高度</li>
<li>BFC区域不会与浮动的容器发生重叠</li>
<li>BFC是独立的容器，容器内部元素不会影响外部元素</li>
<li>每个元素的左margin值和容器的左border相接触</li>
</ul>
<p><strong>BFC的作用：</strong></p>
<ul>
<li><strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li>
<li><strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li>
<li><strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">left</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">right</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p>
<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><ol>
<li><strong>GPU 加速</strong>：<ul>
<li>Transform 操作由 GPU 处理，不占用主线程资源</li>
<li>特别适合动画和复杂视觉效果</li>
<li>使用 <code>translate3d()</code> 或 <code>will-change</code> 可以强制启用 GPU 加速</li>
</ul>
</li>
<li><strong>不触发重排（Reflow）</strong>：<ul>
<li>应用 transform 时，浏览器跳过布局（Layout）阶段</li>
<li>元素在文档流中的位置保持不变</li>
<li>只影响元素的视觉效果，不影响布局</li>
</ul>
</li>
<li><strong>高性能动画</strong>：<ul>
<li>与 CSS transitions&#x2F;animations 结合性能极佳</li>
<li>60fps 流畅动画的理想选择</li>
<li>特别适合移动端性能优化</li>
</ul>
</li>
</ol>
<h3 id="与其他位移属性的性能对比"><a href="#与其他位移属性的性能对比" class="headerlink" title="与其他位移属性的性能对比"></a>与其他位移属性的性能对比</h3><table>
<thead>
<tr>
<th align="left">属性类型</th>
<th align="left">触发重排</th>
<th align="left">触发重绘</th>
<th align="left">性能影响</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Transform</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">最小</td>
<td align="left">动画、交互效果、视觉变换</td>
</tr>
<tr>
<td align="left"><strong>Position</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">中等</td>
<td align="left">静态定位、布局元素</td>
</tr>
<tr>
<td align="left"><strong>Margin</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">最大</td>
<td align="left">元素间距调整</td>
</tr>
<tr>
<td align="left"><strong>Padding</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">大</td>
<td align="left">内容内边距</td>
</tr>
<tr>
<td align="left"><strong>Left&#x2F;Top</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">中等</td>
<td align="left">绝对定位元素移动</td>
</tr>
</tbody></table>
<h3 id="浏览器渲染流程与性能"><a href="#浏览器渲染流程与性能" class="headerlink" title="浏览器渲染流程与性能"></a>浏览器渲染流程与性能</h3><ol>
<li><strong>渲染流水线</strong>：<ul>
<li>JavaScript → 样式计算 → 布局 → 绘制 → 合成</li>
<li>Transform 操作只在合成阶段处理</li>
<li>其他位移属性会触发布局和绘制阶段</li>
</ul>
</li>
<li><strong>优化建议</strong>：<ul>
<li>使用 <code>transform</code> 和 <code>opacity</code> 制作动画</li>
<li>避免在循环中修改布局属性</li>
<li>使用 <code>will-change</code> 提示浏览器优化</li>
<li>优先使用 CSS 动画而非 JavaScript 动画</li>
</ul>
</li>
</ol>
<h3 id="实际性能差异"><a href="#实际性能差异" class="headerlink" title="实际性能差异"></a>实际性能差异</h3><p>在动画演示中，可以看到：</p>
<ul>
<li><strong>Transform</strong>：性能最优，CPU 使用率最低</li>
<li><strong>Position</strong>：性能中等，会触发重排</li>
<li><strong>Margin</strong>：性能最差，导致完整文档重排</li>
</ul>
<h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><p>Flex 布局（弹性盒子布局）是 CSS3 中一种强大的<strong>一维布局模型</strong>，专门设计用于在<strong>单行或单列</strong>中高效分配容器空间。它解决了传统布局（如浮动和定位）的诸多痛点，特别适合构建<strong>响应式界面</strong>和<strong>复杂组件</strong>。</p>
<ul>
<li><strong>Flex 容器</strong>：应用 <code>display: flex</code> 的元素</li>
<li><strong>Flex 项目</strong>：容器内的直接子元素</li>
<li><strong>主轴 (Main Axis)</strong>：项目排列的主要方向（由 <code>flex-direction</code> 定义）</li>
<li><strong>交叉轴 (Cross Axis)</strong>：与主轴垂直的方向</li>
</ul>
<p><strong>二、Flex 容器属性详解</strong></p>
<ol>
<li><code>display</code> - 定义容器类型</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex; <span class="comment">/* 块级 flex 容器 */</span></span><br><span class="line">  <span class="attribute">display</span>: inline-flex; <span class="comment">/* 行内 flex 容器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>flex-direction</code> - 主轴方向</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row; <span class="comment">/* 默认值，水平从左到右 */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>: row-reverse; <span class="comment">/* 水平从右到左 */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>: column; <span class="comment">/* 垂直从上到下 */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>: column-reverse; <span class="comment">/* 垂直从下到上 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>flex-wrap</code> - 换行控制</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  flex-wrap: nowrap; /* 默认不换行 */</span><br><span class="line">  flex-wrap: wrap; /* 正常换行 */</span><br><span class="line">  flex-wrap: wrap-reverse; /* 反向换行 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>flex-flow</code> - 方向与换行的简写</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap; <span class="comment">/* 方向 + 换行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>justify-content</code> - 主轴对齐</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start; <span class="comment">/* 默认，起点对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: flex-end; <span class="comment">/* 终点对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 居中对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-between; <span class="comment">/* 两端对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-around; <span class="comment">/* 均匀分布 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-evenly; <span class="comment">/* 完全均匀 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>align-items</code> - 交叉轴对齐（单行）</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: stretch; <span class="comment">/* 默认，拉伸填满 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: flex-start; <span class="comment">/* 起点对齐 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: flex-end; <span class="comment">/* 终点对齐 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/* 居中对齐 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: baseline; <span class="comment">/* 基线对齐 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><code>align-content</code> - 交叉轴对齐（多行）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  align-content: stretch; /* 默认，拉伸填满 */</span><br><span class="line">  align-content: flex-start; /* 起点对齐 */</span><br><span class="line">  align-content: flex-end; /* 终点对齐 */</span><br><span class="line">  align-content: center; /* 居中对齐 */</span><br><span class="line">  align-content: space-between; /* 两端对齐 */</span><br><span class="line">  align-content: space-around; /* 均匀分布 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>三、Flex 项目属性详解</strong></p>
<ol>
<li><code>order</code> - 项目顺序</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">0</span>; <span class="comment">/* 默认值 */</span></span><br><span class="line">  <span class="attribute">order</span>: <span class="number">1</span>; <span class="comment">/* 值越大越靠后 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>flex-grow</code> - 扩展比例</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">0</span>; <span class="comment">/* 默认不扩展 */</span></span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>; <span class="comment">/* 按比例分配剩余空间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>flex-shrink</code> - 收缩比例</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>; <span class="comment">/* 默认可收缩 */</span></span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0</span>; <span class="comment">/* 禁止收缩 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>flex-basis</code> - 初始尺寸</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: auto; <span class="comment">/* 默认，基于内容 */</span></span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">200px</span>; <span class="comment">/* 固定尺寸 */</span></span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">30%</span>; <span class="comment">/* 百分比尺寸 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>flex</code> - 复合属性</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none; <span class="comment">/* 0 0 auto */</span></span><br><span class="line">  <span class="attribute">flex</span>: auto; <span class="comment">/* 1 1 auto */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 1 1 0% */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>; <span class="comment">/* 不扩展不收缩，固定200px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>align-self</code> - 单独对齐</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto; <span class="comment">/* 继承容器 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: stretch; <span class="comment">/* 拉伸填满 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: flex-start; <span class="comment">/* 顶部对齐 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: flex-end; <span class="comment">/* 底部对齐 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: center; <span class="comment">/* 垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="requestAnimationframe"><a href="#requestAnimationframe" class="headerlink" title="requestAnimationframe"></a>requestAnimationframe</h2><p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是<strong>请求动画帧</strong>。</p>
<p>MDN对该方法的描述：</p>
<p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p>
<p><strong>语法：</strong> <code>window.requestAnimationFrame(callback);</code>  其中，callback是<strong>下一次重绘之前更新动画帧所调用的函数</strong>(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于<strong>宏任务</strong>，所以会在执行完微任务之后再去执行。</p>
<p>**取消动画：**使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p>
<p><strong>优势：</strong></p>
<ul>
<li><strong>CPU节能</strong>：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li>
<li><strong>函数节流</strong>：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li>
<li><strong>减少DOM操作</strong>：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li>
</ul>
<p><strong>setTimeout执行动画的缺点</strong>：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p>
<ul>
<li>settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；</li>
<li>settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li>
</ul>
<h2 id="CSS图片格式对比，应用场景"><a href="#CSS图片格式对比，应用场景" class="headerlink" title="CSS图片格式对比，应用场景"></a>CSS图片格式对比，应用场景</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JPEG&#x2F;JPG</th>
<th align="left">PNG</th>
<th align="left">GIF</th>
<th align="left">WebP</th>
<th align="left">SVG</th>
<th align="left">AVIF</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>压缩类型</strong></td>
<td align="left">有损</td>
<td align="left">无损</td>
<td align="left">无损</td>
<td align="left">有损&#x2F;无损</td>
<td align="left">无损</td>
<td align="left">有损&#x2F;无损</td>
</tr>
<tr>
<td align="left"><strong>透明度支持</strong></td>
<td align="left">❌</td>
<td align="left">✅ (8&#x2F;24位)</td>
<td align="left">✅ (1位)</td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">✅</td>
</tr>
<tr>
<td align="left"><strong>动画支持</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">✅ (SMIL)</td>
<td align="left">❌</td>
</tr>
<tr>
<td align="left"><strong>颜色深度</strong></td>
<td align="left">24位</td>
<td align="left">8&#x2F;24&#x2F;48位</td>
<td align="left">8位(256色)</td>
<td align="left">24&#x2F;32位</td>
<td align="left">无限</td>
<td align="left">10&#x2F;12位</td>
</tr>
<tr>
<td align="left"><strong>文件大小</strong></td>
<td align="left">小</td>
<td align="left">中-大</td>
<td align="left">小(简单)</td>
<td align="left">很小</td>
<td align="left">极小(简单)</td>
<td align="left">非常小</td>
</tr>
<tr>
<td align="left"><strong>浏览器兼容性</strong></td>
<td align="left">100%</td>
<td align="left">100%</td>
<td align="left">100%</td>
<td align="left">95%+</td>
<td align="left">100%</td>
<td align="left">75%+</td>
</tr>
<tr>
<td align="left"><strong>最佳适用场景</strong></td>
<td align="left">照片</td>
<td align="left">透明图像</td>
<td align="left">简单动画</td>
<td align="left">通用</td>
<td align="left">图标&#x2F;矢量</td>
<td align="left">高清照片</td>
</tr>
</tbody></table>
<p>图片有损压缩与无损压缩的区别详解</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">有损压缩</th>
<th align="left">无损压缩</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>原理</strong></td>
<td align="left">删除人眼不易察觉的冗余数据</td>
<td align="left">通过算法重组数据，不丢失信息</td>
</tr>
<tr>
<td align="left"><strong>图像质量</strong></td>
<td align="left">质量下降，产生压缩伪影</td>
<td align="left">保持原始质量</td>
</tr>
<tr>
<td align="left"><strong>文件大小</strong></td>
<td align="left">压缩率高(可达90%)</td>
<td align="left">压缩率低(通常20-50%)</td>
</tr>
<tr>
<td align="left"><strong>数据恢复</strong></td>
<td align="left">不可恢复原始数据</td>
<td align="left">可完全恢复原始数据</td>
</tr>
<tr>
<td align="left"><strong>常用格式</strong></td>
<td align="left">JPEG, WebP, HEIC</td>
<td align="left">PNG, GIF, BMP, TIFF</td>
</tr>
<tr>
<td align="left"><strong>典型应用</strong></td>
<td align="left">网页图片、社交媒体、数码照片</td>
<td align="left">专业摄影、医学影像、设计素材</td>
</tr>
</tbody></table>
<h2 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h2><h3 id="1-回流与重绘的概念及触发条件"><a href="#1-回流与重绘的概念及触发条件" class="headerlink" title="1. 回流与重绘的概念及触发条件"></a>1. 回流与重绘的概念及触发条件</h3><h4 id="（1）回流"><a href="#（1）回流" class="headerlink" title="（1）回流"></a>（1）回流</h4><p>当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为<strong>回流</strong>。</p>
<p>下面这些操作会导致回流：</p>
<ul>
<li>页面的首次渲染</li>
<li>浏览器的窗口大小发生变化</li>
<li>元素的内容发生变化</li>
<li>元素的尺寸或者位置发生变化</li>
<li>元素的字体大小发生变化</li>
<li>激活CSS伪类</li>
<li>查询某些属性或者调用某些方法</li>
<li>添加或者删除可见的DOM元素</li>
</ul>
<p>在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：</p>
<ul>
<li>全局范围：从根节点开始，对整个渲染树进行重新布局</li>
<li>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</li>
</ul>
<h4 id="（2）重绘"><a href="#（2）重绘" class="headerlink" title="（2）重绘"></a>（2）重绘</h4><p>当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是<strong>重绘</strong>。</p>
<p>下面这些操作会导致重绘：</p>
<ul>
<li>color、background 相关属性：background-color、background-image 等</li>
<li>outline 相关属性：outline-color、outline-width 、text-decoration</li>
<li>border-radius、visibility、box-shadow</li>
</ul>
<p>注意： <strong>当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。</strong></p>
<p>样式设置</p>
<p>1、避免使用层级较深的选择器，或其他一些复杂的选择器，以提高CSS渲染效率</p>
<p>2、避免使用CSS<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&zhida_source=entity">表达式</a>，CSS表达式是动态设置CSS属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次</p>
<p>3、元素适当地定义高度或最小高度，否则元素的动态内容载入时，会出现页面元素的晃动或位置，造成回流</p>
<p>4、给图片设置尺寸。如果图片不设置尺寸，首次载入时，占据空间会从0到完全出现，上下左右都可能位移，发生回流</p>
<p>5、不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间</p>
<p>6、能够使用CSS实现的效果，尽量使用CSS而不使用JS实现</p>
<p><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=%E6%B8%B2%E6%9F%93%E5%B1%82&zhida_source=entity">渲染层</a></p>
<p>1、此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围</p>
<p>2、对于一些进行动画的元素，使用硬件渲染，从而避免重绘和回流</p>
<p>DOM优化</p>
<p>1、缓存DOM</p>
<p>const div &#x3D; document.getElementById(‘div’)</p>
<p>由于查询DOM比较耗时，在同一个节点无需多次查询的情况下，可以缓存DOM</p>
<p>2、减少DOM深度及DOM数量</p>
<p>HTML 中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。</p>
<p>3、批量操作DOM</p>
<p>　　由于DOM操作比较耗时，且可能会造成回流，因此要避免频繁操作DOM，可以批量操作DOM，先用字符串拼接完毕，再用innerHTML更新DOM</p>
<p>4、批量操作CSS样式</p>
<p>　　通过切换class或者使用元素的style.csstext属性去批量操作元素样式</p>
<p>5、在内存中操作DOM</p>
<p>　　使用DocumentFragment对象，让DOM操作发生在内存中，而不是页面上</p>
<p>6、<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=DOM%E5%85%83%E7%B4%A0&zhida_source=entity">DOM元素</a>离线更新</p>
<p>　　对DOM进行相关操作时，例、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作</p>
<p>7、DOM<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB&zhida_source=entity">读写分离</a></p>
<p>　　浏览器具有惰性渲染机制，连接多次修改DOM可能只触发浏览器的一次渲染。而如果修改DOM后，立即读取DOM。为了保证读取到正确的DOM值，会触发浏览器的一次渲染。因此，修改DOM的操作要与访问DOM分开进行</p>
<p>8、<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86&zhida_source=entity">事件代理</a></p>
<p>　　事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件</p>
<p>　　利用事件代理，可以减少内存使用，提高性能及降低代码复杂度</p>
<p>9、防抖和节流</p>
<p>　　使用函数节流（throttle）或函数去抖（debounce），限制某一个方法的频繁触发</p>
<p>10、及时清理环境</p>
<p>　　及时消除<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8&zhida_source=entity">对象引用</a>，清除定时器，清除事件监听器，创建最小<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=%E4%BD%9C%E7%94%A8%E5%9F%9F&zhida_source=entity">作用域</a>变量，可以及时回收内存</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成： </p>
<ul>
<li>第一个字符必须是一个字母、下划线（_）或美元符号（$）； </li>
<li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li>
</ul>
<h2 id="let、const、var的区别"><a href="#let、const、var的区别" class="headerlink" title="let、const、var的区别"></a>let、const、var的区别</h2><p>**（1）块级作用域:**块作用域由 <code>&#123; &#125;</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p>
<ul>
<li>内层变量可能覆盖外层变量</li>
<li>用来计数的循环变量泄露为全局变量</li>
</ul>
<p>**（2）变量提升：**var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p>
<p>**（3）给全局添加属性：**浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p>
<p>**（4）重复声明：**var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p>
<p><strong>（5）暂时性死区：<strong>在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为</strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。</p>
<p>**（6）初始值设置：**在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p>
<p>**（7）指针指向：**let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p>
<table>
<thead>
<tr>
<th><strong>区别</strong></th>
<th><strong>var</strong></th>
<th><strong>let</strong></th>
<th><strong>const</strong></th>
</tr>
</thead>
<tbody><tr>
<td>是否有块级作用域</td>
<td>×</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>是否存在变量提升</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>是否添加全局属性</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>能否重复声明变量</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>是否存在暂时性死区</td>
<td>×</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>是否必须设置初始值</td>
<td>×</td>
<td>×</td>
<td>✔️</td>
</tr>
<tr>
<td>能否改变指针指向</td>
<td>✔️</td>
<td>✔️</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="const对象的属性可以修改吗"><a href="#const对象的属性可以修改吗" class="headerlink" title="const对象的属性可以修改吗"></a>const对象的属性可以修改吗</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p>
<p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Undefined、Null、Boolean、Number、 String 、 Symbol</p>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><strong>typeof 工作机制</strong></p>
<p>JavaScript 使用<strong>类型标签</strong>机制在底层表示值类型：</p>
<ul>
<li><p>值在内存中被表示为 32 位单元</p>
</li>
<li><p>低 1-3 位存储类型标签：</p>
<ul>
<li><p><code>000</code>: 对象</p>
</li>
<li><p><code>001</code>: 整数</p>
</li>
<li><p><code>010</code>: 浮点数</p>
</li>
<li><p><code>100</code>: 字符串</p>
</li>
<li><p><code>110</code>: 布尔值</p>
</li>
<li><p><code>111</code>: 符号</p>
</li>
<li><p><code>-2^30</code>: 特殊值（undefined）、</p>
<p><code>null</code> 值被表示为机器码 <code>0x00000000</code>（全零）<br><code>typeof</code> 检查类型标签时看到 <code>000</code>，判定为对象</p>
</li>
</ul>
</li>
</ul>
<h3 id="typeof-返回值表"><a href="#typeof-返回值表" class="headerlink" title="typeof 返回值表"></a>typeof 返回值表</h3><table>
<thead>
<tr>
<th align="left">值类型</th>
<th align="left">typeof 返回值</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Undefined</td>
<td align="left">“undefined”</td>
<td align="left"><code>typeof undefined</code></td>
</tr>
<tr>
<td align="left">Null</td>
<td align="left">“object”</td>
<td align="left"><code>typeof null</code></td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">“boolean”</td>
<td align="left"><code>typeof true</code></td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">“number”</td>
<td align="left"><code>typeof 42</code></td>
</tr>
<tr>
<td align="left">BigInt</td>
<td align="left">“bigint”</td>
<td align="left"><code>typeof 10n</code></td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">“string”</td>
<td align="left"><code>typeof &quot;hello&quot;</code></td>
</tr>
<tr>
<td align="left">Symbol</td>
<td align="left">“symbol”</td>
<td align="left"><code>typeof Symbol()</code></td>
</tr>
<tr>
<td align="left">Function</td>
<td align="left">“function”</td>
<td align="left"><code>typeof function()&#123;&#125;</code></td>
</tr>
<tr>
<td align="left">其他对象</td>
<td align="left">“object”</td>
<td align="left"><code>typeof &#123;&#125;</code></td>
</tr>
</tbody></table>
<h3 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h3><p>null &#x3D;&#x3D; undefined true</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">null</th>
<th align="left">undefined</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>含义</strong></td>
<td align="left">表示<strong>空对象指针</strong></td>
<td align="left">表示<strong>未定义的值</strong></td>
</tr>
<tr>
<td align="left"><strong>类型</strong></td>
<td align="left"><code>object</code> (历史遗留问题)</td>
<td align="left"><code>undefined</code></td>
</tr>
<tr>
<td align="left"><strong>产生场景</strong></td>
<td align="left">开发者显式赋值</td>
<td align="left">JavaScript 引擎自动分配</td>
</tr>
<tr>
<td align="left"><strong>数值转换</strong></td>
<td align="left"><code>Number(null) = 0</code></td>
<td align="left"><code>Number(undefined) = NaN</code></td>
</tr>
<tr>
<td align="left"><strong>典型场景</strong></td>
<td align="left">对象初始化、清除对象引用</td>
<td align="left">变量未初始化、函数无返回值</td>
</tr>
</tbody></table>
<h3 id="转化规则"><a href="#转化规则" class="headerlink" title="转化规则"></a>转化规则</h3><h4 id="转换为-Boolean-类型规则"><a href="#转换为-Boolean-类型规则" class="headerlink" title="转换为 Boolean 类型规则"></a>转换为 Boolean 类型规则</h4><table>
<thead>
<tr>
<th align="left">值类型</th>
<th align="left">转换结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>undefined</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(undefined)</code></td>
</tr>
<tr>
<td align="left"><code>null</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(null)</code></td>
</tr>
<tr>
<td align="left"><code>false</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(false)</code></td>
</tr>
<tr>
<td align="left"><code>0</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(0)</code></td>
</tr>
<tr>
<td align="left"><code>NaN</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(NaN)</code></td>
</tr>
<tr>
<td align="left"><code>&quot;&quot;</code> (空字符串)</td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(&quot;&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>其他所有值</strong></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean(1)</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean(&quot; &quot;)</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean([])</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean(&#123;&#125;)</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean(&quot;false&quot;)</code></td>
</tr>
</tbody></table>
<h4 id="转换为-Number-类型规则"><a href="#转换为-Number-类型规则" class="headerlink" title="转换为 Number 类型规则"></a>转换为 Number 类型规则</h4><table>
<thead>
<tr>
<th align="left">值类型</th>
<th align="left">转换结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>undefined</code></td>
<td align="left"><code>NaN</code></td>
<td align="left"><code>Number(undefined)</code></td>
</tr>
<tr>
<td align="left"><code>null</code></td>
<td align="left"><code>0</code></td>
<td align="left"><code>Number(null)</code></td>
</tr>
<tr>
<td align="left"><code>true</code></td>
<td align="left"><code>1</code></td>
<td align="left"><code>Number(true)</code></td>
</tr>
<tr>
<td align="left"><code>false</code></td>
<td align="left"><code>0</code></td>
<td align="left"><code>Number(false)</code></td>
</tr>
<tr>
<td align="left"><code>&quot;&quot;</code> (空字符串)</td>
<td align="left"><code>0</code></td>
<td align="left"><code>Number(&quot;&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>&quot; &quot;</code> (空白字符串)</td>
<td align="left"><code>0</code></td>
<td align="left"><code>Number(&quot; &quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>数字字符串</strong></td>
<td align="left">对应数字</td>
<td align="left"><code>Number(&quot;123&quot;) → 123</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>Number(&quot;12.3&quot;) → 12.3</code></td>
</tr>
<tr>
<td align="left"><strong>非数字字符串</strong></td>
<td align="left"><code>NaN</code></td>
<td align="left"><code>Number(&quot;123abc&quot;)</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>NaN</code></td>
<td align="left"><code>Number(&quot;abc&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>数组</strong></td>
<td align="left">特殊规则</td>
<td align="left"><code>Number([]) → 0</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>Number([1]) → 1</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>Number([1,2]) → NaN</code></td>
</tr>
<tr>
<td align="left"><strong>对象</strong></td>
<td align="left"><code>NaN</code></td>
<td align="left"><code>Number(&#123;&#125;)</code></td>
</tr>
</tbody></table>
<h4 id="转换为-String-类型规则"><a href="#转换为-String-类型规则" class="headerlink" title="转换为 String 类型规则"></a>转换为 String 类型规则</h4><table>
<thead>
<tr>
<th align="left">值类型</th>
<th align="left">转换结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>undefined</code></td>
<td align="left"><code>&quot;undefined&quot;</code></td>
<td align="left"><code>String(undefined)</code></td>
</tr>
<tr>
<td align="left"><code>null</code></td>
<td align="left"><code>&quot;null&quot;</code></td>
<td align="left"><code>String(null)</code></td>
</tr>
<tr>
<td align="left"><code>true</code></td>
<td align="left"><code>&quot;true&quot;</code></td>
<td align="left"><code>String(true)</code></td>
</tr>
<tr>
<td align="left"><code>false</code></td>
<td align="left"><code>&quot;false&quot;</code></td>
<td align="left"><code>String(false)</code></td>
</tr>
<tr>
<td align="left"><code>0</code></td>
<td align="left"><code>&quot;0&quot;</code></td>
<td align="left"><code>String(0)</code></td>
</tr>
<tr>
<td align="left"><code>NaN</code></td>
<td align="left"><code>&quot;NaN&quot;</code></td>
<td align="left"><code>String(NaN)</code></td>
</tr>
<tr>
<td align="left"><code>Infinity</code></td>
<td align="left"><code>&quot;Infinity&quot;</code></td>
<td align="left"><code>String(Infinity)</code></td>
</tr>
<tr>
<td align="left"><code>-0</code></td>
<td align="left"><code>&quot;0&quot;</code></td>
<td align="left"><code>String(-0)</code></td>
</tr>
<tr>
<td align="left"><strong>数字</strong></td>
<td align="left">数字字符串</td>
<td align="left"><code>String(123) → &quot;123&quot;</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>String(12.3) → &quot;12.3&quot;</code></td>
</tr>
<tr>
<td align="left"><strong>字符串</strong></td>
<td align="left">原字符串</td>
<td align="left"><code>String(&quot;hello&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>数组</strong></td>
<td align="left">元素拼接字符串</td>
<td align="left"><code>String([]) → &quot;&quot;</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>String([1]) → &quot;1&quot;</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>String([1,2]) → &quot;1,2&quot;</code></td>
</tr>
<tr>
<td align="left"><strong>对象</strong></td>
<td align="left"><code>&quot;[object Object]&quot;</code></td>
<td align="left"><code>String(&#123;&#125;)</code></td>
</tr>
</tbody></table>
<h4 id="特殊转换场景规则"><a href="#特殊转换场景规则" class="headerlink" title="特殊转换场景规则"></a>特殊转换场景规则</h4><p><strong>1. 加法运算 (+) 类型转换</strong></p>
<table>
<thead>
<tr>
<th align="left">操作数1类型</th>
<th align="left">操作数2类型</th>
<th align="left">转换规则</th>
<th align="left">示例</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">String</td>
<td align="left">任意类型</td>
<td align="left">都转字符串</td>
<td align="left"><code>&quot;1&quot; + 1</code></td>
<td align="left"><code>&quot;11&quot;</code></td>
</tr>
<tr>
<td align="left">任意类型</td>
<td align="left">String</td>
<td align="left">都转字符串</td>
<td align="left"><code>1 + &quot;1&quot;</code></td>
<td align="left"><code>&quot;11&quot;</code></td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">Number</td>
<td align="left">数值相加</td>
<td align="left"><code>1 + 1</code></td>
<td align="left"><code>2</code></td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">Number</td>
<td align="left">布尔转数字再相加</td>
<td align="left"><code>true + 1</code></td>
<td align="left"><code>2</code></td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">Number</td>
<td align="left">null转0再相加</td>
<td align="left"><code>null + 1</code></td>
<td align="left"><code>1</code></td>
</tr>
<tr>
<td align="left">undefined</td>
<td align="left">Number</td>
<td align="left">返回 NaN</td>
<td align="left"><code>undefined + 1</code></td>
<td align="left"><code>NaN</code></td>
</tr>
</tbody></table>
<p><strong>2. 相等比较 (&#x3D;&#x3D;) 类型转换</strong></p>
<table>
<thead>
<tr>
<th align="left">比较类型</th>
<th align="left">转换规则</th>
<th align="left">示例</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">null &#x3D;&#x3D; undefined</td>
<td align="left">总是相等</td>
<td align="left"><code>null == undefined</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">数字 &#x3D;&#x3D; 字符串</td>
<td align="left">字符串转数字</td>
<td align="left"><code>1 == &quot;1&quot;</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">布尔 &#x3D;&#x3D; 非布尔</td>
<td align="left">布尔转数字再比较</td>
<td align="left"><code>true == 1</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">对象 &#x3D;&#x3D; 原始值</td>
<td align="left">对象转原始值再比较</td>
<td align="left"><code>[1] == 1</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">相同类型</td>
<td align="left">直接比较</td>
<td align="left"><code>&quot;1&quot; == &quot;1&quot;</code></td>
<td align="left"><code>true</code></td>
</tr>
</tbody></table>
<h3 id="for…of-与-for…in-对比"><a href="#for…of-与-for…in-对比" class="headerlink" title="for…of 与 for…in 对比"></a>for…of 与 for…in 对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">for…of</th>
<th align="left">for…in</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>迭代对象</strong></td>
<td align="left">可迭代对象的值</td>
<td align="left">对象的可枚举属性名</td>
</tr>
<tr>
<td align="left"><strong>返回值</strong></td>
<td align="left">元素值</td>
<td align="left">属性键名</td>
</tr>
<tr>
<td align="left"><strong>适用数据类型</strong></td>
<td align="left">Array, Map, Set, String, TypedArray, NodeList</td>
<td align="left">普通对象, 数组(不推荐)</td>
</tr>
<tr>
<td align="left"><strong>原型链属性</strong></td>
<td align="left">不遍历</td>
<td align="left">会遍历(除非使用 hasOwnProperty)</td>
</tr>
<tr>
<td align="left"><strong>迭代顺序</strong></td>
<td align="left">按元素插入顺序(有序集合)</td>
<td align="left">无保证顺序(依赖于JS引擎实现)</td>
</tr>
<tr>
<td align="left"><strong>Symbol属性</strong></td>
<td align="left">支持迭代 Symbol.iterator</td>
<td align="left">默认不迭代 Symbol 属性</td>
</tr>
<tr>
<td align="left"><strong>空元素处理</strong></td>
<td align="left">跳过数组空位(sparse arrays)</td>
<td align="left">会处理空位(返回 undefined)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">较高</td>
<td align="left">较低</td>
</tr>
</tbody></table>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="数组检测"><a href="#数组检测" class="headerlink" title="数组检测"></a>数组检测</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Object.prototype.toString.call()做判断</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>,-<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过原型链做判断</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过ES6的Array.isArray()做判断</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArrray</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过instanceof做判断</span></span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Array.prototype.isPrototypeOf</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(obj)</span><br></pre></td></tr></table></figure>



<h4 id="数组方法详解"><a href="#数组方法详解" class="headerlink" title="数组方法详解"></a>数组方法详解</h4><h5 id="数组方法分类概览"><a href="#数组方法分类概览" class="headerlink" title="数组方法分类概览"></a>数组方法分类概览</h5><table>
<thead>
<tr>
<th align="left"><strong>方法类型</strong></th>
<th align="left"><strong>特点</strong></th>
<th align="left"><strong>代表方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">改变原数组</td>
<td align="left">直接修改数组</td>
<td align="left">push, pop, splice, sort, reverse</td>
</tr>
<tr>
<td align="left">不改变原数组</td>
<td align="left">返回新数组或值</td>
<td align="left">map, filter, slice, concat, reduce</td>
</tr>
<tr>
<td align="left">可中断遍历</td>
<td align="left">可通过返回值提前结束遍历</td>
<td align="left">some, every, find, findIndex</td>
</tr>
<tr>
<td align="left">不可中断遍历</td>
<td align="left">必须完整遍历所有元素</td>
<td align="left">forEach, map, filter, reduce</td>
</tr>
</tbody></table>
<h5 id="原生数组方法详细解析"><a href="#原生数组方法详细解析" class="headerlink" title="原生数组方法详细解析"></a>原生数组方法详细解析</h5><p><strong>1. 改变原数组的方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">参数</th>
<th align="left">是否改变原数组</th>
<th align="left">遍历是否可暂停</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>push</strong></td>
<td align="left">(item1, item2, …, itemN)</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">新数组长度</td>
</tr>
<tr>
<td align="left"><strong>pop</strong></td>
<td align="left">()</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">移除的元素</td>
</tr>
<tr>
<td align="left"><strong>shift</strong></td>
<td align="left">()</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">移除的元素</td>
</tr>
<tr>
<td align="left"><strong>unshift</strong></td>
<td align="left">(item1, item2, …, itemN)</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">新数组长度</td>
</tr>
<tr>
<td align="left"><strong>splice</strong></td>
<td align="left">(start, deleteCount, item1, item2, …, itemN)</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">被删除元素组成的数组</td>
</tr>
<tr>
<td align="left"><strong>sort</strong></td>
<td align="left">[compareFunction(a, b)]</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">排序后的数组</td>
</tr>
<tr>
<td align="left"><strong>reverse</strong></td>
<td align="left">()</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">反转后的数组</td>
</tr>
<tr>
<td align="left"><strong>fill</strong></td>
<td align="left">(value, [start], [end])</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">修改后的数组</td>
</tr>
<tr>
<td align="left"><strong>copyWithin</strong></td>
<td align="left">(target, [start], [end])</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">修改后的数组</td>
</tr>
</tbody></table>
<p><strong>2. 不改变原数组的方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">参数</th>
<th align="left">是否改变原数组</th>
<th align="left">遍历是否可暂停</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>concat</strong></td>
<td align="left">(array1, array2, …, arrayN)</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">合并后的新数组</td>
</tr>
<tr>
<td align="left"><strong>slice</strong></td>
<td align="left">([start], [end])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">提取元素组成的新数组</td>
</tr>
<tr>
<td align="left"><strong>join</strong></td>
<td align="left">([separator])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">连接后的字符串</td>
</tr>
<tr>
<td align="left"><strong>toString</strong></td>
<td align="left">()</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">数组的字符串表示</td>
</tr>
<tr>
<td align="left"><strong>indexOf</strong></td>
<td align="left">(searchElement, [fromIndex])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">元素的索引或 -1</td>
</tr>
<tr>
<td align="left"><strong>lastIndexOf</strong></td>
<td align="left">(searchElement, [fromIndex])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">元素的索引或 -1</td>
</tr>
<tr>
<td align="left"><strong>includes</strong></td>
<td align="left">(searchElement, [fromIndex])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left"><strong>map</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">处理后的新数组</td>
</tr>
<tr>
<td align="left"><strong>filter</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">过滤后的新数组</td>
</tr>
<tr>
<td align="left"><strong>reduce</strong></td>
<td align="left">(callback(acc, current, index, array), [initialValue])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">累计结果值</td>
</tr>
<tr>
<td align="left"><strong>reduceRight</strong></td>
<td align="left">(callback(acc, current, index, array), [initialValue])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">累计结果值</td>
</tr>
</tbody></table>
<p><strong>3. 可中断遍历的方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">参数</th>
<th align="left">是否改变原数组</th>
<th align="left">遍历是否可暂停</th>
<th align="left">暂停条件</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>some</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">callback 返回 true</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left"><strong>every</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">callback 返回 false</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left"><strong>find</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">callback 返回 true</td>
<td align="left">找到的元素或 undefined</td>
</tr>
<tr>
<td align="left"><strong>findIndex</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">callback 返回 true</td>
<td align="left">元素的索引或 -1</td>
</tr>
</tbody></table>
<p><strong>4. 不可中断遍历的方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">参数</th>
<th align="left">是否改变原数组</th>
<th align="left">遍历是否可暂停</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>forEach</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">遍历所有元素</td>
</tr>
<tr>
<td align="left"><strong>entries</strong></td>
<td align="left">()</td>
<td align="left">❌</td>
<td align="left">⚠️*</td>
<td align="left">返回迭代器，可用 break</td>
</tr>
<tr>
<td align="left"><strong>keys</strong></td>
<td align="left">()</td>
<td align="left">❌</td>
<td align="left">⚠️*</td>
<td align="left">返回迭代器，可用 break</td>
</tr>
<tr>
<td align="left"><strong>values</strong></td>
<td align="left">()</td>
<td align="left">❌</td>
<td align="left">⚠️*</td>
<td align="left">返回迭代器，可用 break</td>
</tr>
</tbody></table>
<blockquote>
<p>*注：entries&#x2F;keys&#x2F;values 方法返回的是迭代器对象，本身不进行遍历，使用迭代器时可配合 <code>break</code> 暂停</p>
</blockquote>
<h2 id="JavaScript-集合类型对比与应用场景指南"><a href="#JavaScript-集合类型对比与应用场景指南" class="headerlink" title="JavaScript 集合类型对比与应用场景指南"></a>JavaScript 集合类型对比与应用场景指南</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Map</th>
<th align="left">Set</th>
<th align="left">WeakMap</th>
<th align="left">WeakSet</th>
<th align="left">Object</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>键类型</strong></td>
<td align="left">任意类型</td>
<td align="left">任意类型</td>
<td align="left">仅对象</td>
<td align="left">仅对象</td>
<td align="left">字符串&#x2F;Symbol</td>
</tr>
<tr>
<td align="left"><strong>值类型</strong></td>
<td align="left">任意类型</td>
<td align="left">无值(仅存储键)</td>
<td align="left">任意类型</td>
<td align="left">无值(仅存储键)</td>
<td align="left">任意类型</td>
</tr>
<tr>
<td align="left"><strong>可迭代性</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅(需辅助方法)</td>
</tr>
<tr>
<td align="left"><strong>大小获取</strong></td>
<td align="left">直接(size属性)</td>
<td align="left">直接(size属性)</td>
<td align="left">不可获取</td>
<td align="left">不可获取</td>
<td align="left">需计算</td>
</tr>
<tr>
<td align="left"><strong>垃圾回收</strong></td>
<td align="left">强引用(阻止回收)</td>
<td align="left">强引用(阻止回收)</td>
<td align="left">弱引用(不阻止回收)</td>
<td align="left">弱引用(不阻止回收)</td>
<td align="left">强引用(阻止回收)</td>
</tr>
<tr>
<td align="left"><strong>顺序保证</strong></td>
<td align="left">插入顺序</td>
<td align="left">插入顺序</td>
<td align="left">无顺序</td>
<td align="left">无顺序</td>
<td align="left">无顺序(ES6后有序)</td>
</tr>
<tr>
<td align="left"><strong>键冲突处理</strong></td>
<td align="left">可覆盖</td>
<td align="left">自动去重</td>
<td align="left">可覆盖</td>
<td align="left">自动去重</td>
<td align="left">属性名覆盖</td>
</tr>
<tr>
<td align="left"><strong>序列化支持</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅</td>
</tr>
<tr>
<td align="left"><strong>原型链影响</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅</td>
</tr>
<tr>
<td align="left"><strong>性能(增删)</strong></td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">较低</td>
</tr>
</tbody></table>
<p><strong>应用场景详解</strong></p>
<ol>
<li>Map 最佳应用场景</li>
</ol>
<ul>
<li><strong>复杂键值存储</strong>：当需要使用非字符串键（如对象、函数）时</li>
<li><strong>DOM元素关联</strong>：将DOM元素与元数据关联，不污染DOM本身</li>
<li><strong>频率计数</strong>：高效统计元素出现频率</li>
<li><strong>有序键值对</strong>：需要保持键值对插入顺序的场景</li>
<li><strong>类私有属性</strong>：实现类实例的私有属性存储</li>
</ul>
<ol start="2">
<li>Set 最佳应用场景</li>
</ol>
<ul>
<li><strong>值唯一性保证</strong>：自动去除重复元素的场景</li>
<li><strong>集合运算</strong>：实现并集、交集、差集等数学集合操作</li>
<li><strong>存在性检查</strong>：快速检查元素是否存在的场景</li>
<li><strong>事件订阅管理</strong>：管理唯一的事件处理器集合</li>
<li><strong>数据过滤</strong>：从大型数据集中快速过滤唯一值</li>
</ul>
<ol start="3">
<li>WeakMap 最佳应用场景</li>
</ol>
<ul>
<li><strong>私有数据存储</strong>：关联对象与私有数据，不暴露给外部</li>
<li><strong>DOM元数据关联</strong>：当DOM元素被移除时自动清除关联数据</li>
<li><strong>缓存系统</strong>：对象缓存，当对象不再使用时自动清除缓存</li>
<li><strong>资源管理</strong>：对象与资源的关联，资源随对象自动释放</li>
<li><strong>避免内存泄漏</strong>：需要对象作为键且自动垃圾回收的场景</li>
</ul>
<ol start="4">
<li>WeakSet 最佳应用场景</li>
</ol>
<ul>
<li><strong>对象标记</strong>：标记对象状态（如”已处理”），不阻止垃圾回收</li>
<li><strong>循环引用检测</strong>：跟踪对象访问状态，防止无限递归</li>
<li><strong>临时对象集合</strong>：存储临时使用的对象集合，自动清理</li>
<li><strong>访问控制</strong>：检查对象是否具有特定权限，自动清理无效对象</li>
<li><strong>依赖管理</strong>：管理对象依赖关系，随主对象自动清除</li>
</ul>
<ol start="5">
<li>Object 最佳应用场景</li>
</ol>
<ul>
<li><strong>配置对象</strong>：结构化配置参数的存储</li>
<li><strong>JSON数据</strong>：需要序列化和反序列化的数据</li>
<li><strong>方法命名空间</strong>：组织相关函数和方法</li>
<li><strong>简单键值对</strong>：键为字符串&#x2F;Symbol的简单数据结构</li>
<li><strong>模块导出</strong>：作为模块的导出容器</li>
<li><strong>原型继承</strong>：需要利用原型链实现继承的场景</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>3种定义方式 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 全局提升</span></span><br><span class="line"><span class="keyword">const</span> fn =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 函数表达式</span></span><br><span class="line">箭头表达式</span><br><span class="line"><span class="comment">// 0或多个参数，1个可以没有（）</span></span><br><span class="line"><span class="comment">// 1行语句可以没有&#123;&#125;</span></span><br><span class="line">()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 引擎在任何代码执行之前，会<strong>先读取函数声明，并在执行上下文中生成函数定义</strong>。</p>
<p>而<strong>函数表达式必须等到代码执行到它那一行</strong>，才会在执行上下文中生成函数定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没问题  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">	<span class="keyword">return</span> num1 + num2;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>只有var 修饰的变量，存在<strong>变量声明提升</strong>，且在赋值前允许访问,<strong>但不赋值</strong>，返回undefiend</p>
<p>let存在<strong>变量声明提升</strong>，但是<strong>在赋值前不允许访问</strong>,报错</p>
<p>以上代码可以正常运行，因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个 过程叫作<strong>函数声明提升</strong>（function declaration hoisting）</p>
<p>在<strong>执行代码时，JavaScript 引擎会先执行一遍扫描， 把发现的函数声明提升到源代码树的顶部</strong>。因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部<font color="red">为了性能</font></p>
<p>这两提升适用于函数作用域<br><img src="/../img/image-20240216221556720.png" alt="image-20240216221556720"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会出错 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));  </span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">	<span class="keyword">return</span> num1 + num2;  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>上面的代码之所以会出错，是因为这个函数定义包含在一个变量初始化语句中，而不是函数声明中。 这意味着代码如果没有执行到加粗的那一行，那么执行上下文中就没有函数的定义，所以上面的代码会 出错。</p>
<p><strong>函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量 functionName。这样创建的函数叫作匿名函数（anonymous funtion），因为 function 关键字后面没有 标识符。（匿名函数有也时候也被称为兰姆达函数）。未赋值给其他变量的匿名函数的 name 属性是空字符串</strong>。</p>
<p>箭头函数箭头后面一行代码想要返回一个对像{}是不行的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span>=(<span class="params"></span>)=&gt;&#123;<span class="attr">test</span>:<span class="string">&quot;name&quot;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> res=<span class="title function_">fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//&#123;&#123;&#125;&#125;也不行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（&#123;&#125;）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span>=(<span class="params"></span>)=&gt;(&#123;<span class="attr">test</span>:<span class="string">&quot;name&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> res=<span class="title function_">fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);<span class="comment">//&#123;test:&quot;name&quot;&#125;</span></span><br></pre></td></tr></table></figure>



<p><strong>函数名</strong></p>
<p>函数名就是指向函数的指针，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着 一个函数可以有多个名称，如下所示： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">	<span class="keyword">return</span> num1 + num2;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20  </span></span><br><span class="line"><span class="keyword">let</span> anotherSum = sum;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherSum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20  </span></span><br><span class="line">sum = <span class="literal">null</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherSum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20  </span></span><br></pre></td></tr></table></figure>

<p>以上代码定义了一个名为 sum()的函数，用于求两个数之和。然后又声明了一个变量 anotherSum， 并将它的值设置为等于 sum。</p>
<p><strong>注意，使用不带括号的函数名会访问函数指针，而不会执行函数。</strong></p>
<p>此时， anotherSum 和 sum 都指向同一个函数。调用 anotherSum()也可以返回结果。</p>
<p>把 sum 设置为 null 之后，就切断了它与函数之间的关联。而 anotherSum()还是可以照常调用，没有问题</p>
<p>ECMAScript 6 的所有函数对象都会暴露一个只读的 <strong>name 属性</strong>，其中包含关于函数的信息。多数情 况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称， 也会如实显示成空字符串。<strong>如果它是使用 Function 构造函数创建的，则会标识成”anonymous”</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">baz</span> = (<span class="params"></span>) =&gt; &#123;&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">name</span>); <span class="comment">// foo </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">name</span>); <span class="comment">// bar </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">name</span>); <span class="comment">// baz </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="function">() =&gt;</span> &#123;&#125;).<span class="property">name</span>); <span class="comment">//（空字符串）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">new</span> <span class="title class_">Function</span>()).<span class="property">name</span>); <span class="comment">// anonymous </span></span><br></pre></td></tr></table></figure>

<p>如果函数是一个获取函数、设置函数，或者使用 bind()实例化，那么标识符前面会加上一个前缀：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">bind</span>(<span class="literal">null</span>).<span class="property">name</span>); <span class="comment">// bound foo  </span></span><br><span class="line"><span class="keyword">let</span> dog = &#123;  </span><br><span class="line">    <span class="attr">years</span>: <span class="number">1</span>,  </span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">age</span>() &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">years</span>;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">newAge</span>) &#123;  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">years</span> = newAge;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">let</span> propertyDescriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(dog, <span class="string">&#x27;age&#x27;</span>); <span class="variable language_">console</span>.<span class="title function_">log</span>(propertyDescriptor.<span class="property">get</span>.<span class="property">name</span>); <span class="comment">// get age  console.log(propertyDescriptor.set.name); // set age </span></span><br></pre></td></tr></table></figure>





<p><strong>函数参数</strong></p>
<p>定义形参就相当于<strong>在函数中声明了对应的变量，但是没有赋值</strong></p>
<p><img src="/../img/image-20240216221930349.png" alt="image-20240216221930349"></p>
<p><img src="/../img/image-20240216222103472.png" alt="image-20240216222103472"></p>
<p><img src="/../img/image-20240216222423936.png" alt="image-20240216222423936"></p>
<p><strong>ECMAScript 函数的参数在内部表现为一个数组</strong>。</p>
<p>函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。</p>
<p>如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没问题。</p>
<p>事实上，在使用 function 关键字定义（非箭头）函数时，<strong>可以在函数内部访问 arguments 对象</strong>，从中取得传进来的每个参数值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">howManyArgs</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">howManyArgs</span>(<span class="string">&quot;string&quot;</span>, <span class="number">45</span>); <span class="comment">// 2 </span></span><br><span class="line"><span class="title function_">howManyArgs</span>(); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">howManyArgs</span>(<span class="number">12</span>); <span class="comment">// 1 </span></span><br></pre></td></tr></table></figure>

<p><strong>arguments 对象</strong>可以跟命名参数一起使用，比如： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAdd</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;  </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + <span class="number">10</span>);  </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;  </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在这个 doAdd()函数中，同时使用了两个命名参数和 arguments 对象。命名参数 num1 保存着与 arugments[0]一样的值，因此使用谁都无所谓。（同样，num2 也保存着跟 arguments[1]一样的值。）</p>
<p> arguments 对象的另一个有意思的地方就是，<strong>它的值始终会与对应的命名参数同步</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAdd</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个 doAdd()函数把第二个参数的值重写为 10。因为 <strong>arguments 对象的值会自动同步到对应的命名参数</strong>，所以修改 arguments[1]也会修改 num2 的值，因此两者的值都是 10。但这并不意味着它们都访问同一个内存地址，<strong>它们在内存中还是分开的，只不过会保持同步而已</strong>。另外还要记住一点：如果只传了一个参数，然后把 arguments[1]设置为某个值，那么这个值并不会反映到第二个命名参数。这是 <strong>因为 arguments 对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的</strong></p>
<p>特例</p>
<p><strong>箭头函数中的参数</strong> </p>
<p>如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 arguments 关键字访问，而只能通过定义的命名参数访问。</p>
<p>注意 <strong>ECMAScript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。</strong></p>
<p>在JavaScript中，<strong>原始类型的内容是存储在栈中，而对象的内容是存储在堆中，指向堆的地址存储在栈中</strong>。</p>
<p>(Number、Stirng、Boolean、Null、Underfined这些基本数据类型，他们的值直接保存在栈中；<br>Object、Function、Array、Date、RegExp这些引用类型，他们的引用变量储存在栈中，通过指针指向储存在堆中的实际对象)</p>
<p>原始变量及他们的值储存在栈中，当把一个原始变量传递给另一个原始变量时，是把一个栈房间的东西复制到另一个栈房间，且这两个原始变量互不影响。</p>
<p>引用值是把引用变量的名称储存在栈中，但是其实际对象储存在堆中，且存在一个指针由变量名指向储存在堆中的实际对象，当把引用对象传递给另一个变量时，复制的其实是指向实际对象的指针，此时两者指向的是同一个数据，若通过方法改变其中一个变量的值，则访问另一个变量时，其值也会随之加以改变；但若通过重新赋值  ，此时相当于重新开了一个房间 ，该值的原指针改变，而另外一个值不会随它的改变而改变</p>
<p><strong>原始变量赋值给参数时，将栈中数据发给参数，两个数相互独立</strong></p>
<p><strong>引用变量给的是栈中的内存地址，所以，在函数内部发生属性值得改变，是对堆中对象的修改，所以另一个值得属性也发生，除非在函数中修改参数的内存的地址，也即参数重新赋值，才会再次相互独立</strong></p>
<p><strong>默认参数值</strong></p>
<p>1、使用默认参数时，arguments 对象的值不反映参数的默认值，只反映传给函数的参数</p>
<p>2、默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值：</p>
<p>3、函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数 只有在调用函数但未传相应参数时才会被调用。 箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了</p>
<p>4、默认参数会按照定义它们的顺序依次被初始化，后定义默认值的参数可以引用先定义的参数</p>
<p>5、参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的</p>
<p>6、参数也存在于自己的作用域中，它们不能引用函数体的作用域</p>
<p><strong>扩展参数</strong></p>
<p>对可迭代对象适用 …,这也适用于argument数组，箭头函数中也能这么写</p>
<p><strong>函数作为传递值</strong></p>
<p>函数作为值 因为函数名在 ECMAScript 中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。</p>
<h3 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h3><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a><strong>arguments</strong></h3><p>一个类数组对象，包含调用函数时传入的所有参数。这 个对象只有以 function 关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包 含函数参数，但 arguments 对象其实还有一个 callee 属性，是一个指向 arguments 对象所在函数的 指针。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a><strong>this</strong></h3><p>它在标准函数和箭头函数中有不同的行为。 在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 this 值（在 网页的全局上下文中调用函数时，this 指向 windows）</p>
<p>在箭头函数中，this引用的是定义箭头函数的上下文。</p>
<h4 id="对this对象的理解"><a href="#对this对象的理解" class="headerlink" title="对this对象的理解"></a>对this对象的理解</h4><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p>
<ul>
<li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li>
<li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li>
<li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li>
<li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li>
</ul>
<p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p>
<h4 id="对this-的补充"><a href="#对this-的补充" class="headerlink" title="对this 的补充"></a>对this 的补充</h4><ol>
<li>函数默认执行 执行window.也就是什么都不做直接执行</li>
<li>对象调用函数,会隐式绑定把this指向对象</li>
<li>显示绑定,通过call , apply , bind,会指向输入的参数,如果不输入参数,则默认绑定为window</li>
<li>通过new操作符来绑定this.</li>
</ol>
<p>它们的优先级是:</p>
<p>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。</p>
<p>还有一个考察的知识点就是箭头函数.它的this由定义它的结构代码时父级执行上下文决定的</p>
<ul>
<li>如果是在全局环境,或者是在一个对象里,它的父级执行上下文就是全局环境,它的this就指向了window</li>
<li>如果它的<strong>外部是一个函数,那么它的this就指向了函数的执行上下文.而函数的执行上下文就是活的.取决于调用时的情况.也就上面列举的四种情况</strong>.</li>
</ul>
<p>根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。</p>
<p>要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined</p>
<h4 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h4><p>函数的 <code>this</code> 关键字在 <code>JavaScript</code> 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别</p>
<p>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值（运行时绑定）</p>
<p><code>this</code> 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置是全局作用域</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;baz&quot;</span> );</span><br><span class="line">    <span class="title function_">bar</span>(); <span class="comment">// &lt;-- bar的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz --&gt; bar</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在baz中</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;bar&quot;</span> );</span><br><span class="line">    <span class="title function_">foo</span>(); <span class="comment">// &lt;-- foo的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz --&gt; bar --&gt; foo</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在bar中</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;foo&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">baz</span>(); <span class="comment">// &lt;-- baz的调用位置</span></span><br></pre></td></tr></table></figure>



<p>同时，<code>this</code>在函数执行过程中，<code>this</code>一旦被确定了，就不可以再更改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span> = obj; <span class="comment">// 修改this，运行后会报错</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>



<h4 id="二、绑定规则"><a href="#二、绑定规则" class="headerlink" title="二、绑定规则"></a>二、绑定规则</h4><p>根据不同的使用场合，<code>this</code>有不同的值，主要分为下面几种情况：</p>
<ul>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>new绑定</li>
<li>显示绑定</li>
</ul>
<h5 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h5><p>全局环境中定义<code>person</code>函数，内部使用<code>this</code>关键字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jenny&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">person</span>());  <span class="comment">//Jenny</span></span><br></pre></td></tr></table></figure>



<p>上述代码输出<code>Jenny</code>，原因是调用函数的对象在游览器中位<code>window</code>，因此<code>this</code>指向<code>window</code>，所以输出<code>Jenny</code></p>
<p>注意：</p>
<p>严格模式下，不能将全局对象用于默认绑定，this会绑定到<code>undefined</code>，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象</p>
<h5 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h5><p>函数还可以作为某个对象的方法调用，这时<code>this</code>就指这个上级对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">m</span> = test;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">m</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<p>这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，<code>this</code>指向的也只是它上一级的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>:&#123;</span><br><span class="line">        <span class="attr">fn</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">//undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.<span class="property">b</span>.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>



<p>上述代码中，<code>this</code>的上一级对象为<code>b</code>，<code>b</code>内部并没有<code>a</code>变量的定义，所以输出<code>undefined</code></p>
<p>这里再举一种特殊情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>:&#123;</span><br><span class="line">        <span class="attr">a</span>:<span class="number">12</span>,</span><br><span class="line">        <span class="attr">fn</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">//undefined</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//window</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = o.<span class="property">b</span>.<span class="property">fn</span>;</span><br><span class="line"><span class="title function_">j</span>();</span><br></pre></td></tr></table></figure>



<p>此时<code>this</code>指向的是<code>window</code>，这里的大家需要记住，<code>this</code>永远指向的是最后调用它的对象，虽然<code>fn</code>是对象<code>b</code>的方法，但是<code>fn</code>赋值给<code>j</code>时候并没有执行，所以最终指向<code>window</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure>

<h5 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h5><p>通过构建函数<code>new</code>关键字生成一个实例对象，此时<code>this</code>指向这个实例对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">　<span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">test</span>();</span><br><span class="line">obj.<span class="property">x</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<p>上述代码之所以能过输出1，是因为<code>new</code>关键字改变了<code>this</code>的指向</p>
<p>这里再列举一些特殊情况：</p>
<p><code>new</code>过程遇到<code>return</code>一个对象，此时<code>this</code>指向为返回的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">fn</span>();  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>



<p>如果返回一个简单类型的时候，则<code>this</code>指向实例对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//xxx</span></span><br></pre></td></tr></table></figure>



<p>注意的是<code>null</code>虽然也是对象，但是此时<code>new</code>仍然指向实例对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//xxx</span></span><br></pre></td></tr></table></figure>



<h5 id="显示修改"><a href="#显示修改" class="headerlink" title="显示修改"></a>显示修改</h5><p><code>apply()、call()、bind()</code>是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时<code>this</code>指的就是这第一个参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">　<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">m</span> = test;</span><br><span class="line">obj.<span class="property">m</span>.<span class="title function_">apply</span>(obj) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<p>关于<code>apply、call、bind</code>三者的区别，我们后面再详细说</p>
<h4 id="三、箭头函数"><a href="#三、箭头函数" class="headerlink" title="三、箭头函数"></a>三、箭头函数</h4><p>在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 <code>this</code> 的指向（编译时绑定）</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">sayThis</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">sayThis</span>(); <span class="comment">// window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了</span></span><br><span class="line"><span class="keyword">const</span> globalSay = obj.<span class="property">sayThis</span>;</span><br><span class="line"><span class="title function_">globalSay</span>(); <span class="comment">// window 浏览器中的 global 对象</span></span><br></pre></td></tr></table></figure>



<p>虽然箭头函数的<code>this</code>能够在编译的时候就确定了<code>this</code>的指向，但也需要注意一些潜在的坑</p>
<p>下面举个例子：</p>
<p>绑定事件监听</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mngb&#x27;</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;clicked button&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>上述可以看到，我们其实是想要<code>this</code>为点击的<code>button</code>，但此时<code>this</code>指向了<code>window</code></p>
<p>包括在原型上添加方法时候，此时<code>this</code>指向<code>window</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">//true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;mm&#x27;</span>);</span><br><span class="line">cat.<span class="title function_">sayName</span>()</span><br></pre></td></tr></table></figure>



<p>同样的，箭头函数不能作为构建函数</p>
<h4 id="四、优先级"><a href="#四、优先级" class="headerlink" title="四、优先级"></a>四、优先级</h4><h5 id="隐式绑定-VS-显式绑定"><a href="#隐式绑定-VS-显式绑定" class="headerlink" title="隐式绑定 VS 显式绑定"></a>隐式绑定 VS 显式绑定</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br><span class="line">obj2.<span class="title function_">foo</span>(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>( obj2 ); <span class="comment">// 3</span></span><br><span class="line">obj2.<span class="property">foo</span>.<span class="title function_">call</span>( obj1 ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<p>显然，显示绑定的优先级更高</p>
<h5 id="new绑定-VS-隐式绑定"><a href="#new绑定-VS-隐式绑定" class="headerlink" title="new绑定 VS 隐式绑定"></a>new绑定 VS 隐式绑定</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>( <span class="number">2</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>( obj2, <span class="number">3</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj2.<span class="property">a</span> ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.<span class="title function_">foo</span>( <span class="number">4</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( bar.<span class="property">a</span> ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>



<p>可以看到，new绑定的优先级<code>&gt;</code>隐式绑定</p>
<h5 id="new绑定-VS-显式绑定"><a href="#new绑定-VS-显式绑定" class="headerlink" title="new绑定 VS 显式绑定"></a><code>new</code>绑定 VS 显式绑定</h5><p>因为<code>new</code>和<code>apply、call</code>无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>( obj1 );</span><br><span class="line"><span class="title function_">bar</span>( <span class="number">2</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>( <span class="number">3</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( baz.<span class="property">a</span> ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar`被绑定到obj1上，但是`new bar(3)` 并没有像我们预计的那样把`obj1.a`修改为3。但是，`new`修改了绑定调用`bar()`中的`this</span><br></pre></td></tr></table></figure>

<p>我们可认为<code>new</code>绑定优先级<code>&gt;</code>显式绑定</p>
<p>综上，new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p>
<p>**new.target **</p>
<p>ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性。如果函数是正常调用的</p>
<p>则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的 构造函数。</p>
<p><strong>函数的属性和方法</strong></p>
<p>length 属性保存函数定义的命名参数的个数</p>
<p>prototype 属性也许是 ECMAScript 核心中最有趣的部分。prototype 是保存引用类型所有实例 方法的地方，这意味着 toString()、valueOf()等方法实际上都保存在 prototype 上，进而由所有实 例共享</p>
<p>apply()和 call()。这两个方法都会以指定的 this 值来调用函数，即会设 置调用函数时函数体内 this 对象的值。</p>
<p>apply()方法接收两个参数：函数内 this 的值和一个参数数组。第二个参数可以是 Array 的实例，但也可以是 arguments 对象</p>
<p>call()方法与 apply()的作用一样，只是传参的形式不同。第一个参数跟 apply()一样，也是 this 值，而剩下的要传给被调用函数的参数则是逐个传递的。换句话说，通过 call()向函数传参时，必须 将参数一个一个地列出来</p>
<p><strong>严格模式下，调用函数时如果没有指定上下文对象，则 this 值不会指向 window。 除非使用 apply()或 call()把函数指定给一个对象，否则 this 的值会变成 undefined。</strong></p>
<p>bind() bind()方法会创建一个新的函数实例， 其 this 值会被绑定到传给 bind()的对象。</p>
<h3 id="三个函数方法的原理实现"><a href="#三个函数方法的原理实现" class="headerlink" title=" 三个函数方法的原理实现"></a><font color="red"> <strong>三个函数方法的原理实现</strong></font></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断调用对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">      result = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">    context = context || <span class="variable language_">window</span>;</span><br><span class="line">    <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">    <span class="comment">// 将属性删除</span></span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">        fn = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">            <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context,</span><br><span class="line">            args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>尾调用优化的条件</strong> </p>
<p>代码在严格模式下执行； </p>
<p>外部函数的返回值是对尾调用函数的调用； </p>
<p>尾调用函数返回后不需要执行额外的逻辑； </p>
<p>尾调用函数不是引用外部函数作用域中自由变量的闭包</p>
<h3 id="函数垃圾回收"><a href="#函数垃圾回收" class="headerlink" title="函数垃圾回收"></a><strong>函数垃圾回收</strong></h3><p><strong>标记清理</strong></p>
<p> JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。</p>
<p>当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永 远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时， 也会被加上离开上下文的标记。 </p>
<p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下 文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现 并不重要，关键是策略。 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它 会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记 的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内 存清理，销毁带标记的所有值并收回它们的内存。</p>
<p><strong>引用计数</strong></p>
<p> 另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被 引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变 量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一 个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序 下次运行的时候就会释放引用数为 0 的值的内存。 引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：<strong>循环引用</strong>。所谓循环引 用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定 了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的<strong>变量对象（variable object）</strong>， 而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它</p>
<p><strong>全局上下文</strong></p>
<p>是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一 样。在浏览器中，全局上下文就是我们常说的 window 对象，因此<strong>所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。</strong></p>
<p><strong>使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义 在它上面的所有变量和函数</strong>（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。<br>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。 在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。</p>
<p>ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。 上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定 了各级上下文中的代码在访问变量和函数时的顺序。</p>
<p>代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有 一个定义变量：arguments。（全局上下文中没有这个变量）作用域链中的下一个变量对象来自包含上 下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；</p>
<p><strong>就近原则</strong></p>
<p>**全局上下文的变量对象始终是作用域链的最后一个变量对象。 **</p>
<p><strong>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符</strong></p>
<p><strong>作用域链增强</strong> </p>
<p>虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时： </p>
<p>try&#x2F;catch 语句的 catch 块 </p>
<p>with 语句 这两种情况下，都会在作用域链前端添加一个变量对象。</p>
<p><strong>对 with 语句来说，会向作用域链前端添 加指定的对象；</strong></p>
<p><strong>对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明</strong></p>
<h3 id="作用域、作用域链的理解"><a href="#作用域、作用域链的理解" class="headerlink" title="作用域、作用域链的理解"></a>作用域、作用域链的理解</h3><h5 id="1）全局作用域和函数作用域"><a href="#1）全局作用域和函数作用域" class="headerlink" title="1）全局作用域和函数作用域"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p>
<ul>
<li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li>
<li>所有未定义直接赋值的变量自动声明为全局作用域</li>
<li>所有window对象的属性拥有全局作用域</li>
<li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li>
</ul>
<p>（2）函数作用域</p>
<ul>
<li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li>
<li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li>
</ul>
<h5 id="2）块级作用域"><a href="#2）块级作用域" class="headerlink" title="2）块级作用域"></a>2）块级作用域</h5><ul>
<li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li>
<li>let和const声明的变量不会有变量提升，也不可以重复声明</li>
<li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li>
</ul>
<p><strong>作用域链：</strong></p>
<p>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p>
<p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p>
<p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p>
<p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><font color="red">函数的作用域，<strong>在函数创建时就已经确定的</strong>(词法作用域)和调用的位置无关</font></p>
<font color="red">

<p>闭包的生命周期:1闭包在外部函数调用时产生，外部函数每次调用都会产生一个全新的闭包2在内部函数丢失时销毁(内部函数被垃圾回收了，闭包才会消失)</p>
</font>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> a=<span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    <span class="title function_">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>



<p><img src="/../img/image-20240217084901274.png" alt="image-20240217084901274"></p>
<p>指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。比如，下面是之前展示的 createComparisonFunction()函数，</p>
<p>注 意其中加粗的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;  </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">object1, object2</span>) &#123;  </span><br><span class="line">		    <span class="keyword">let</span> value1 = object1[propertyName];  </span><br><span class="line">		    <span class="keyword">let</span> value2 = object2[propertyName];  </span><br><span class="line">		    <span class="keyword">if</span> (value1 &lt; value2) &#123;  </span><br><span class="line">		    	<span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">		    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;  </span><br><span class="line">		    	<span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">		    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">		    	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">		    &#125;  </span><br><span class="line">	 &#125;;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p><img src="/../img/image-20240217094012495.png" alt="image-20240217094012495"></p>
<h3 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h3><p>普通函数（外层函数）</p>
<p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义 compare()函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的[[Scope]]中。在 调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[Scope]]来创建其作用域链。接着会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。在这个例子中，这意味着 compare() 函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。</p>
<p><img src="/../img/image-20240217100208940.png" alt="image-20240217100208940"></p>
<p>函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。 在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。因此，在 createComparisonFunction()函数中，匿名函数的作用域链中实际上包含 createComparisonFunction()的活动对象。图 10-2 展示了以下代码执行后的结果</p>
<p><img src="/../img/image-20240217100229047.png" alt="image-20240217100229047"></p>
<p><font color="red">闭包在外部函数调用时且在外部函数作用域已被调用或者已被返回才会产生</font></p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>占用的内存没有及时释放</p>
<p>内存泄露积累多了就容易导致内存溢出</p>
<p>常见的内存泄露:<br>意外的全局变量</p>
<p>没有及时清理的计时器或回调函数</p>
<p>闭包</p>
<p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line"></span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法有三种：</p>
<p>●第一种是使用闭包的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  ;(<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line"></span><br><span class="line">​    &#125;, j * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">  &#125;)(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。</p>
<p>●第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(</span><br><span class="line"></span><br><span class="line">​    function timer(j) &#123;</span><br><span class="line"></span><br><span class="line">​      console.log(j)</span><br><span class="line"></span><br><span class="line">​    &#125;,</span><br><span class="line"></span><br><span class="line">​    i * 1000,</span><br><span class="line"></span><br><span class="line">​    i</span><br><span class="line"></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>●第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line"></span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a><strong>立即调用的函数表达式</strong></h2><p>立即调用的函数表达式（IIFE，Immediately Invoked Function  Expression）。</p>
<p>它类似于函数声明，但<strong>由于被包含在括号中，所以会被解释为函数表达式</strong>。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式。下面是一个简单的例子： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line"><span class="comment">// 块级作用域  </span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p> 使用 IIFE 可以<strong>模拟块级作用域</strong>，即在<strong>一个函数表达式内部声明变量，然后立即调用这个函数</strong>。这 样位于函数体作用域的变量就像是在块级作用域中一样。ECMAScript 5 尚未支持块级作用域，使用 IIFE 模拟块级作用域是相当普遍的。比如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// IIFE  </span><br><span class="line">(function () &#123;  </span><br><span class="line">	for (var i = 0; i &lt; count; i++) &#123;  </span><br><span class="line">		console.log(i);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;)();  console.log(i); // 抛出错误 </span><br></pre></td></tr></table></figure>

<p>前面的代码在执行到 IIFE 外部的 console.log()时会出错，因为它访问的变量是在 IIFE 内部定义的，在外部访问不到。</p>
<p>在 ECMAScript 5.1 及以前，为了防止变量定义外泄，IIFE 是个非常有效的方式。 这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕， 其作用域链就可以被销毁。 在 </p>
<p>ECMAScript 6 以后，IIFE 就没有那么必要了，因为块级作用域中的变量无须 IIFE 就可以实现同 样的隔离。下面展示了两种不同的块级作用域形式： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内嵌块级作用域  </span></span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">let</span> i;  </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;  </span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">		&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误 </span></span><br><span class="line"><span class="comment">// 循环的块级作用域 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;  </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误 </span></span><br></pre></td></tr></table></figure>

<p>说明 IIFE 用途的一个实际的例子，就是可以用它锁定参数值。比如： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);  <span class="comment">// 达不到目的！  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;  </span><br><span class="line">	divs[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">	&#125;);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里使用 var 关键字声明了循环迭代变量 i，但这个变量并不会被限制在 for 循环的块级作用域内。 因此，渲染到页面上之后，点击每个都会弹出元素总数。这是因为在执行单击处理程序时，迭代变 量的值是循环结束时的最终值，即元素的个数。而且，这个变量 i 存在于循环体外部，随时可以访问。 以前，为了实现点击第几个</p>
<p>就显示相应的索引值，需要借助 IIFE 来执行一个函数表达式，传 入每次循环的当前索引，从而“锁定”点击时应该显示的索引值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;  </span><br><span class="line">	divs[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, (<span class="keyword">function</span>(<span class="params">frozenCounter</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(frozenCounter);  </span><br><span class="line">        &#125;;  </span><br><span class="line">        &#125;)(i));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而使用 ECMAScript 块级作用域变量，就不用这么大动干戈了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;  </span><br><span class="line">	divs[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">	&#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/28/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/" data-id="cmcgaht3600004sur1w0e7uo4" data-title="基础开发" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html-css-javascript/" rel="tag">html css javascript</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/06/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          前端性能[C
        
      </div>
    </a>
  
  
    <a href="/2025/06/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">前端基础</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html-css-javascript/" rel="tag">html css javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E3%80%81%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/" rel="tag">前端工程、包管理器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E3%80%81%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E3%80%81/" rel="tag">前端页面、错误监控、</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/" rel="tag">大模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" rel="tag">计算机网络，浏览器原理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/html-css-javascript/" style="font-size: 10px;">html css javascript</a> <a href="/tags/typescript/" style="font-size: 10px;">typescript</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E3%80%81%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/" style="font-size: 10px;">前端工程、包管理器</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E3%80%81%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E3%80%81/" style="font-size: 10px;">前端页面、错误监控、</a> <a href="/tags/%E5%8E%9F%E7%90%86/" style="font-size: 10px;">原理</a> <a href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">大模型</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" style="font-size: 10px;">计算机网络，浏览器原理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/04/%E4%B8%9A%E5%8A%A1/">业务</a>
          </li>
        
          <li>
            <a href="/2025/07/03/Vue/">Vue</a>
          </li>
        
          <li>
            <a href="/2025/07/01/AI/">AI</a>
          </li>
        
          <li>
            <a href="/2025/07/01/React%E8%A1%A5%E5%85%85/">React补充</a>
          </li>
        
          <li>
            <a href="/2025/06/29/React/">React</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>