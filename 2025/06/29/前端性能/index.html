<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>前端性能[C | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Js错误JavaScript 错误类型总览   错误类型 触发场景 示例代码 解决方案    SyntaxError 语法错误 if (a) &#123; 修复代码语法   ReferenceError 访问未声明变量 console.log(undeclaredVar); 声明变量或检查变量作用域   TypeError 类型不匹配操作 null.func(); 添加类型检查   RangeEr">
<meta property="og:type" content="article">
<meta property="og:title" content="前端性能[C">
<meta property="og:url" content="http://example.com/2025/06/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Js错误JavaScript 错误类型总览   错误类型 触发场景 示例代码 解决方案    SyntaxError 语法错误 if (a) &#123; 修复代码语法   ReferenceError 访问未声明变量 console.log(undeclaredVar); 声明变量或检查变量作用域   TypeError 类型不匹配操作 null.func(); 添加类型检查   RangeEr">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://segmentfault.com/img/bV7tjY?w=372&h=126">
<meta property="article:published_time" content="2025-06-29T06:44:38.000Z">
<meta property="article:modified_time" content="2025-06-29T08:11:39.843Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="前端页面、错误监控、性能指标">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://segmentfault.com/img/bV7tjY?w=372&h=126">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-前端性能" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/" class="article-date">
  <time class="dt-published" datetime="2025-06-29T06:44:38.000Z" itemprop="datePublished">2025-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      前端性能[C
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Js错误"><a href="#Js错误" class="headerlink" title="Js错误"></a>Js错误</h1><h2 id="JavaScript-错误类型总览"><a href="#JavaScript-错误类型总览" class="headerlink" title="JavaScript 错误类型总览"></a>JavaScript 错误类型总览</h2><table>
<thead>
<tr>
<th align="left">错误类型</th>
<th align="left">触发场景</th>
<th align="left">示例代码</th>
<th align="left">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SyntaxError</strong></td>
<td align="left">语法错误</td>
<td align="left"><code>if (a) &#123;</code></td>
<td align="left">修复代码语法</td>
</tr>
<tr>
<td align="left"><strong>ReferenceError</strong></td>
<td align="left">访问未声明变量</td>
<td align="left"><code>console.log(undeclaredVar);</code></td>
<td align="left">声明变量或检查变量作用域</td>
</tr>
<tr>
<td align="left"><strong>TypeError</strong></td>
<td align="left">类型不匹配操作</td>
<td align="left"><code>null.func();</code></td>
<td align="left">添加类型检查</td>
</tr>
<tr>
<td align="left"><strong>RangeError</strong></td>
<td align="left">数值超出有效范围</td>
<td align="left"><code>new Array(-1);</code></td>
<td align="left">验证输入值范围</td>
</tr>
<tr>
<td align="left"><strong>URIError</strong></td>
<td align="left">URI处理函数使用无效参数</td>
<td align="left"><code>decodeURIComponent(&#39;%&#39;);</code></td>
<td align="left">验证URI参数</td>
</tr>
<tr>
<td align="left"><strong>EvalError</strong></td>
<td align="left"><code>eval()</code> 函数使用不当</td>
<td align="left"><code>new eval();</code></td>
<td align="left">避免使用eval</td>
</tr>
<tr>
<td align="left"><strong>AggregateError</strong></td>
<td align="left">多个错误组合</td>
<td align="left"><code>Promise.any([rejectedPromises]);</code></td>
<td align="left">处理多个错误</td>
</tr>
<tr>
<td align="left"><strong>自定义错误</strong></td>
<td align="left">开发者主动抛出</td>
<td align="left"><code>throw new CustomError(&#39;msg&#39;);</code></td>
<td align="left">实现特定错误处理逻辑</td>
</tr>
</tbody></table>
<h3 id="1-SyntaxError（语法错误）"><a href="#1-SyntaxError（语法错误）" class="headerlink" title="1. SyntaxError（语法错误）"></a>1. SyntaxError（语法错误）</h3><p><strong>触发时机</strong>：代码解析阶段<br><strong>常见场景</strong>：</p>
<ul>
<li>缺少括号、引号或花括号</li>
<li>错误使用保留字</li>
<li>无效的表达式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1: 缺少括号</span></span><br><span class="line"><span class="keyword">if</span> (a &#123;  <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;&#123;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: 无效赋值</span></span><br><span class="line"><span class="keyword">const</span> 123<span class="keyword">var</span> = <span class="string">&quot;test&quot;</span>;  <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>

<h3 id="2-ReferenceError（引用错误）"><a href="#2-ReferenceError（引用错误）" class="headerlink" title="2. ReferenceError（引用错误）"></a>2. ReferenceError（引用错误）</h3><p><strong>触发时机</strong>：运行时<br><strong>常见场景</strong>：</p>
<ul>
<li>访问未声明的变量</li>
<li>访问块作用域变量（let&#x2F;const）的TDZ（暂时性死区）</li>
<li>模块导入错误</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1: 未声明变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(undeclaredVar);  <span class="comment">// Uncaught ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: TDZ访问</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);  <span class="comment">// Uncaught ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-TypeError（类型错误）"><a href="#3-TypeError（类型错误）" class="headerlink" title="3. TypeError（类型错误）"></a>3. TypeError（类型错误）</h3><p><strong>触发时机</strong>：操作不符合变量类型<br><strong>常见场景</strong>：</p>
<ul>
<li>调用非函数值</li>
<li>访问null&#x2F;undefined的属性</li>
<li>尝试修改常量值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1: 调用非函数</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="title function_">num</span>();  <span class="comment">// Uncaught TypeError: num is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: 访问null属性</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">property</span>);  <span class="comment">// Uncaught TypeError: Cannot read property</span></span><br></pre></td></tr></table></figure>

<h3 id="4-RangeError（范围错误）"><a href="#4-RangeError（范围错误）" class="headerlink" title="4. RangeError（范围错误）"></a>4. RangeError（范围错误）</h3><p><strong>触发时机</strong>：参数超出有效范围<br><strong>常见场景</strong>：</p>
<ul>
<li>无效数组长度</li>
<li>数字方法参数越界</li>
<li>递归深度过大</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1: 无效数组长度</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(-<span class="number">1</span>);  <span class="comment">// Uncaught RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: 数字精度超限</span></span><br><span class="line">(<span class="number">123.456</span>).<span class="title function_">toFixed</span>(<span class="number">101</span>);  <span class="comment">// Uncaught RangeError: toFixed() digits argument must be between 0 and 100</span></span><br></pre></td></tr></table></figure>

<h3 id="5-URIError（URI错误）"><a href="#5-URIError（URI错误）" class="headerlink" title="5. URIError（URI错误）"></a>5. URIError（URI错误）</h3><p><strong>触发时机</strong>：URI处理函数参数无效<br><strong>仅影响</strong>：<code>encodeURI()</code>, <code>decodeURI()</code>, <code>encodeURIComponent()</code>, <code>decodeURIComponent()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例: 无效URI解码</span></span><br><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="string">&#x27;%&#x27;</span>);  <span class="comment">// Uncaught URIError: URI malformed</span></span><br></pre></td></tr></table></figure>

<h3 id="6-EvalError（eval错误）"><a href="#6-EvalError（eval错误）" class="headerlink" title="6. EvalError（eval错误）"></a>6. EvalError（eval错误）</h3><p><strong>触发时机</strong>：<code>eval()</code> 函数使用不当<br><strong>注意</strong>：现代JavaScript中很少见，保留用于兼容性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 历史用法 (现代JS引擎不再抛出)</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EvalError</span>(<span class="string">&quot;Eval error&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e <span class="keyword">instanceof</span> <span class="title class_">EvalError</span>);  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-AggregateError（聚合错误）"><a href="#7-AggregateError（聚合错误）" class="headerlink" title="7. AggregateError（聚合错误）"></a>7. AggregateError（聚合错误）</h3><p><strong>触发时机</strong>：多个错误需要同时报告<br><strong>常见于</strong>：<code>Promise.any()</code> 全部拒绝时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Error 1&quot;</span>)),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Error 2&quot;</span>))</span><br><span class="line">]).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e <span class="keyword">instanceof</span> <span class="title class_">AggregateError</span>);  <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">errors</span>.<span class="property">length</span>);  <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="WebIDL和ecma-262中的错误类型"><a href="#WebIDL和ecma-262中的错误类型" class="headerlink" title="WebIDL和ecma-262中的错误类型"></a>WebIDL和ecma-262中的错误类型</h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=WCsyJ0SbM68nFUfknuxc4g==.suEaakDxsFgunJR89KoRM2icTf23NuhbkJlXUUrVWbBpYg3tSQ3Qcro+8NlH58ZUTRaKRVPug72ITCAseJfwzPkhe/P6CqFiA14nNIjGM7E=">ECMAScript exceptions</a> &lt;&#x3D;&#x3D;&gt; <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=PKwXx59Icv2HdaKCGITj+w==.ZkwDXSwbBVZSMF94vbPpyK+w3iC2bcBf19ml+tcJNstSYLackci+BgNMsdSmvchdLjCH5bbjMMICt01dZB8DuA==">IDL 的简单异常</a></p>
<p>当脚本代码运行时发生的错误，会创建Error对象，并将其抛出，除了通用的Error构造函数外，以下是另外几个ECMAScript 2015中定义的错误构造函数。</p>
<ul>
<li><strong>EvalError</strong> eval错误</li>
<li><strong>RangeError</strong> 范围错误</li>
<li><strong>ReferenceError</strong> 引用错误</li>
<li><strong>TypeError</strong> 类型错误</li>
<li><strong>URIError</strong> URI错误</li>
<li><strong>SyntaxError</strong> 语法错误 (这个错误WebIDL中故意省略，保留给ES解析器使用)</li>
<li><strong>Error</strong> 通用错误 （这个错误WebIDL中故意省略，保留给开发者使用使用）</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=Qaux4NrI17y7bOplFMyitw==.cL487ezp3TEsLOuy+TKH9OHDliMsEWajxxayEUwyqYIqv9RbXRCkouXogfTnmFZbGfw3Oo476yuXgMBVsvAeEQ==">DOMException</a> 最新的DOM规范定义的错误类型集，兼容旧浏览的DOMError接口, 完善和规范化DOM错误类型。</p>
<ul>
<li><strong>IndexSizeError</strong> 索引不在允许的范围内</li>
<li><strong>HierarchyRequestError</strong> 节点树层次结构是不正确的。</li>
<li><strong>WrongDocumentError</strong> 对象是错误的</li>
<li><strong>InvalidCharacterError</strong> 字符串包含无效字符。</li>
<li><strong>NoModificationAllowedError</strong> 对象不能被修改。</li>
<li><strong>NotFoundError</strong> 对象不能在这里被找到。</li>
<li><strong>NotSupportedError</strong> 不支持的操作</li>
<li><strong>InvalidStateError</strong> 对象是一个无效的状态。</li>
<li><strong>SyntaxError</strong> 字符串不匹配预期的模式</li>
<li><strong>InvalidModificationError</strong> 对象不能以这种方式被修改</li>
<li><strong>NamespaceError</strong> 操作在XML命名空间内是不被允许的</li>
<li><strong>InvalidAccessError</strong> 对象不支持这种操作或参数。</li>
<li><strong>TypeMismatchError</strong> 对象的类型不匹配预期的类型。</li>
<li><strong>SecurityError</strong> 此操作是不安全的。</li>
<li><strong>NetworkError</strong> 发生网络错误</li>
<li><strong>AbortError</strong> 操作被中止</li>
<li><strong>URLMismatchError</strong> 给定的URL不匹配另一个URL。</li>
<li><strong>QuotaExceededError</strong> 已经超过给定配额。</li>
<li><strong>TimeoutError</strong> 操作超时。</li>
<li><strong>InvalidNodeTypeError</strong> 这个操作的 节点或节点祖先 是不正确的</li>
<li><strong>DataCloneError</strong> 对象不能克隆。</li>
</ul>
</li>
</ul>
<h3 id="前端错误异常按照捕获方式分类"><a href="#前端错误异常按照捕获方式分类" class="headerlink" title="前端错误异常按照捕获方式分类"></a>前端错误异常按照捕获方式分类</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 语法错误</li>
<li><input checked="" disabled="" type="checkbox"> 运行时异常</li>
<li><input checked="" disabled="" type="checkbox"> 资源加载异常<ul>
<li>img</li>
<li>script</li>
<li>link</li>
<li>audio</li>
<li>video</li>
<li>iframe</li>
<li>…外链资源的DOM元素</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> 异步请求异常<ul>
<li>XMLHttpRequest</li>
<li>fetch</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> Promise异常</li>
<li><input disabled="" type="checkbox"> <del>CSS中资源异常</del><ul>
<li>@font-face</li>
<li>background-image</li>
<li>…暂时无法捕获</li>
</ul>
</li>
</ul>
<h3 id="前端错误异常的捕获方式"><a href="#前端错误异常的捕获方式" class="headerlink" title="前端错误异常的捕获方式"></a>前端错误异常的捕获方式</h3><ul>
<li>try-catch (ES提供基本的错误捕获语法)<ul>
<li>只能捕获同步代码的异常</li>
<li><del>回调</del></li>
<li><del>setTimeout</del></li>
<li><del>promise</del></li>
</ul>
</li>
<li><strong>window.onerror &#x3D; cb (DOM0)</strong><ul>
<li>img</li>
<li>script</li>
<li>link</li>
</ul>
</li>
<li>window.addEventListener(‘error’, cb, true) (DOM2)</li>
<li>window.addEventListener(“unhandledrejection”, cb) (DOM4)</li>
<li>Promise.then().catch(cb)</li>
<li>封装XMLHttpRequest&amp;fetch | 覆写请求接口对象</li>
</ul>
<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p>将能引发异常的代码块放到try中，并对应一个响应，然后有异常会被捕获</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 模拟一段可能有错误的代码</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;会有错误的代码块&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">  <span class="comment">// 捕获到try中代码块的错误得到一个错误对象e，进行处理分析</span></span><br><span class="line">  <span class="title function_">report</span>(e)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;finally&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="onerror事件"><a href="#onerror事件" class="headerlink" title="onerror事件"></a>onerror事件</h4><h5 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h5><p>当JavaScript运行时错误（包括语法错误）发生时，window会触发一个ErrorEvent接口的事件，并执行window.onerror();</p>
<p>但这里有个信息要注意，语法错误会导致出现语法错误的那个脚本块执行失败，所以语法错误会导致当前代码块运行终止，从而导致整个程序运行中断，如果语法错误这个发生在我们的错误监控语句块中，那么我们就什么也监控不到了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 运行时错误处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; message 错误信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; source 发生错误的脚本URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; lineno 发生错误的行号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; colno 发生错误的列号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">object</span>&#125; error Error对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">err</span>(<span class="params">message,source,lineno,colno,error</span>) &#123;...&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = err</span><br></pre></td></tr></table></figure>

<h5 id="element-onerror"><a href="#element-onerror" class="headerlink" title="element.onerror"></a>element.onerror</h5><p>当一项资源（如<code>&lt;img&gt;</code>或<code>&lt;script&gt;</code>）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; ... &#125; <span class="comment">//注意和window.onerror的参数不同</span></span><br></pre></td></tr></table></figure>

<p>注意：这些error事件不会向上冒泡到window，不过能被单一的window.addEventListener捕获。</p>
<h5 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h5><h5 id="addEventListener相关的一些内容"><a href="#addEventListener相关的一些内容" class="headerlink" title="addEventListener相关的一些内容"></a>addEventListener相关的一些内容</h5><p>W3C DOM2 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=t0fRx2nVaR1eu7VXBZ0Oyw==./f7iMYPHVLL1SJ7Tsr8UBsyS07dvVmnWFnPkFkJMUE383Svkr3So82kOIjNpQpQl">Events</a>规范中提供的注册事件监听器的方法, 在这之前均使用<br><code>el.onclick</code>的形式（DOM0 规范的基本内容，几乎所有浏览器都支持）。</p>
<p>注意： <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=jhXgag8h/rd9UmLYcpREUw==.gyww6nUd6BCIKiObOuusn+K7pdiHTFxvnJrdeLqnQ2YuJAup9f50b3dTfzUjfcWVmy/T+2pz16NB64TCAJStAbOv8JVXfXroRUjMA3B3dXo=">接口的几种语法</a></p>
<h5 id="error事件捕获资源加载错误"><a href="#error事件捕获资源加载错误" class="headerlink" title="error事件捕获资源加载错误"></a>error事件捕获资源加载错误</h5><p>资源加载失败，不会冒泡，但是会被addEventListener捕获，所以我们可以指定在加载失败事件的捕获阶段捕获该错误。</p>
<p>注意: 接口同时也能捕获运行时错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;error&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> eventType = [].<span class="property">toString</span>.<span class="title function_">call</span>(e, e);</span><br><span class="line">    <span class="keyword">if</span> (eventType === <span class="string">&quot;[object Event]&quot;</span>) &#123; <span class="comment">// 过滤掉运行时错误</span></span><br><span class="line">      <span class="comment">// 上报加载错误</span></span><br><span class="line">      <span class="title function_">report</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="unhandledrejection事件捕获Promise异常"><a href="#unhandledrejection事件捕获Promise异常" class="headerlink" title="unhandledrejection事件捕获Promise异常"></a>unhandledrejection事件捕获Promise异常</h5><p>最新的规范中定义了 unhandledrejection事件用于全局捕获promise对象没有rejection处理器时异常情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// ...your code here to handle the unhandled rejection...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent the default handling (error in console)</span></span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Promise-then-catch-cb-finally"><a href="#Promise-then-catch-cb-finally" class="headerlink" title="Promise.then().catch(cb).finally()"></a>Promise.then().catch(cb).finally()</h4><p>Promise中的错误会被Promise.prototype.catch捕获，所以我们通过这种方式捕获错误，这包括一些不支持unhandledrejection事件的环境中promisede polyfill实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;Uncaught Exception!&#x27;</span>;</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// Uncaught Exception!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="封装XMLHttpRequest-fetch-覆写请求接口对象"><a href="#封装XMLHttpRequest-fetch-覆写请求接口对象" class="headerlink" title="封装XMLHttpRequest&amp;fetch | 覆写请求接口对象"></a>封装XMLHttpRequest&amp;fetch | 覆写请求接口对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 覆写XMLHttpRequest API</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> xmlhttp = <span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>;</span><br><span class="line">  <span class="keyword">var</span> _oldSend = xmlhttp.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">send</span>;</span><br><span class="line">  <span class="keyword">var</span> _handleEvent = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (event &amp;&amp; event.<span class="property">currentTarget</span> &amp;&amp; event.<span class="property">currentTarget</span>.<span class="property">status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">report</span>(event)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xmlhttp.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">send</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>]) &#123;</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>](<span class="string">&#x27;error&#x27;</span>, _handleEvent);</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>](<span class="string">&#x27;load&#x27;</span>, _handleEvent);</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>](<span class="string">&#x27;abort&#x27;</span>, _handleEvent);</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>](<span class="string">&#x27;close&#x27;</span>, _handleEvent);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> _oldStateChange = <span class="variable language_">this</span>[<span class="string">&#x27;onreadystatechange&#x27;</span>];</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;onreadystatechange&#x27;</span>] = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">                  <span class="title function_">_handleEvent</span>(event);</span><br><span class="line">              &#125;</span><br><span class="line">              _oldStateChange &amp;&amp; _oldStateChange.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> _oldSend.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写fetch API</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="property">fetch</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">var</span> _oldFetch = <span class="variable language_">window</span>.<span class="property">fetch</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">fetch</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _oldFetch</span><br><span class="line">    .<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!res.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="comment">// True if status is HTTP 2xx</span></span><br><span class="line">        <span class="title function_">report</span>(res)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">      <span class="title function_">report</span>(res)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="日志上报的方式"><a href="#日志上报的方式" class="headerlink" title="日志上报的方式"></a>日志上报的方式</h3><ul>
<li>异步请求上报, 后端提供接口，或者直接发到日志服务器</li>
<li>img请求上报, url参数带上错误信息<ul>
<li><code>eg:(new Image()).src = &#39;http://baidu.com/tesjk?r=tksjk&#39;</code></li>
</ul>
</li>
</ul>
<h4 id="注意跨源脚本异常"><a href="#注意跨源脚本异常" class="headerlink" title="注意跨源脚本异常"></a>注意跨源脚本异常</h4><p>当加载自不同域的脚本中发生语法错误时，为避免信息泄露，语法错误的细节将不会报告，而代之简单的 “Script error.”</p>
<p>由于同源策略影响，浏览器限制跨源脚本的错误访问，这样跨源脚本错误报错信息如下图：</p>
<p><img src="https://segmentfault.com/img/bV7tjY?w=372&h=126" alt="跨源的脚本的异常"></p>
<p>在H5的规定中，只要满足下面俩个条件，是允许获取跨源脚本的错误信息的。</p>
<ol>
<li>客户端在script标签上增加crossorigin属性；</li>
<li>服务端设置js资源响应头Access-Control-Origin:*（或者是域名）。</li>
</ol>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><h4 id="业界已经有的监控平台"><a href="#业界已经有的监控平台" class="headerlink" title="业界已经有的监控平台"></a>业界已经有的监控平台</h4><ul>
<li>Sentry开源</li>
<li>阿里的ARMS</li>
<li>fundebug</li>
<li>FrontJS</li>
</ul>
<h4 id="几个异常监控的问题"><a href="#几个异常监控的问题" class="headerlink" title="几个异常监控的问题"></a>几个异常监控的问题</h4><ul>
<li><p>如何保证大家提交的代码是符合预期的？ 如何了解前端项目的运行是否正常，是否存在错误？</p>
<p>代码质量体系控制和错误监控以及性能分析</p>
</li>
<li><p>如果用户使用网页，发现白屏，现在联系上了你们，你们会向他询问什么信息呢？先想一下为什么会白屏？</p>
<p>我们以用户访问页面的过程为顺序，大致排查一下</p>
<ol>
<li>用户没打开网络</li>
<li>DNS域名劫持</li>
<li>http劫持</li>
<li>cdn或是其他资源文件访问出错</li>
<li>服务器错误</li>
<li>前端代码错误</li>
<li>前端兼容性问题</li>
<li>用户操作出错</li>
</ol>
</li>
</ul>
<p>通过以上可能发生错误的环节，我们需要向用户手机一下以下的用户信息</p>
<ol>
<li>当前的网络状态</li>
<li>运营商</li>
<li>地理位置</li>
<li>访问时间</li>
<li>客户端的版本(如果是通过客户端访问)</li>
<li>系统版本</li>
<li>浏览器信息</li>
<li>设备分辨率</li>
<li>页面的来源</li>
<li>用户的账号信息</li>
<li>通过performance API收集用户各个页面访问流程所消耗的时间</li>
<li>收集用户js代码报错的信息</li>
</ol>
<ul>
<li>如果我们使用了脚本代码压缩，然而我们又不想将sourcemap文件发布到线上，我们怎么捕获到错误的具体信息？</li>
<li>CSS文件中也存在引用资源，@font-face, background-image …等这些请求错误该如何进行错误捕获？</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Web规范中相关前端异常<ul>
<li>DOM处理异常</li>
<li>ECMAScript处理异常</li>
</ul>
</li>
<li>异常按照捕获方式分类<ul>
<li>运行时异常</li>
<li>资源加载异常</li>
<li>异步请求异常</li>
<li>Promise异常</li>
</ul>
</li>
<li>异常的捕获方式<ul>
<li>try-catch (ES提供基本的错误捕获语法)<ul>
<li>只能捕获同步代码的异常</li>
<li><del>回调</del></li>
<li><del>setTimeout</del></li>
<li><del>promise</del></li>
</ul>
</li>
<li>window.onerror &#x3D; cb (DOM0)<ul>
<li>img</li>
<li>script</li>
<li>link</li>
</ul>
</li>
<li>window.addEventListener(‘error’, cb, true) (DOM2)</li>
<li>window.addEventListener(“unhandledrejection”, cb) (DOM4)</li>
<li>Promise.then().catch(cb)</li>
<li>封装XMLHttpRequest&amp;fetch | 覆写请求接口对象</li>
</ul>
</li>
</ul>
<p>注意点：跨源脚本异常的捕获</p>
<ul>
<li><p>日志上报的方式</p>
<ul>
<li>异步请求上报</li>
<li>new img上报 避免跨域问题</li>
</ul>
</li>
<li><p>扩展阅读</p>
<ul>
<li>业界已有的异常监控平台</li>
<li>几个跟异常监控有关的问题</li>
</ul>
</li>
</ul>
<p>为了在移动端项目中实现前端错误监控，并考虑极端断网环境，我们需要设计一个健壮且全面的技术方案。移动端环境具有网络不稳定（弱网、断网）、设备多样性、操作系统差异等特点，因此方案需要具备以下能力：</p>
<ol>
<li><p>错误捕获：全面捕获JS错误、资源加载错误、接口错误、框架错误（如React&#x2F;Vue）、Promise错误等。</p>
</li>
<li><p>数据存储：在断网情况下，能够将错误信息暂存本地，待网络恢复后上报。</p>
</li>
<li><p>上报机制：支持重试机制，避免因网络问题导致数据丢失。</p>
</li>
<li><p>数据压缩与批处理：减少网络请求，节省流量。</p>
</li>
<li><p>区分错误类型：对错误进行分类，便于分析。</p>
</li>
</ol>
<p> 我们将从以下几个方面进行设计：</p>
<p> 一、错误捕获</p>
<p> 二、错误信息处理</p>
<p> 三、本地存储与上报</p>
<p> 四、网络恢复后的处理</p>
<p> 五、其他优化措施</p>
<p> 详细方案如下：</p>
<p> 一、错误捕获</p>
<ol>
<li>JavaScript运行时错误</li>
</ol>
<p>​    - 使用 <code>window.onerror</code> 捕获全局同步错误。</p>
<p>​    - 注意：<code>window.onerror</code> 无法捕获语法错误（一般会在编译阶段发现，不会进入线上环境）和跨域脚本错误（需要为跨域脚本添加 <code>crossorigin</code> 属性）。</p>
<ol start="2">
<li>Promise错误</li>
</ol>
<p>​    - 使用 <code>unhandledrejection</code> 事件捕获未处理的Promise拒绝。</p>
<ol start="3">
<li>资源加载错误</li>
</ol>
<p>​    - 使用 <code>window.addEventListener(&#39;error&#39;, callback, true)</code> 捕获资源（如图片、脚本、样式）加载错误。注意第三个参数为 <code>true</code>（捕获阶段）。</p>
<ol start="4">
<li>框架错误</li>
</ol>
<p>​    - React：使用 <code>ErrorBoundary</code> 组件捕获组件树中的错误。</p>
<p>​    - Vue：使用 <code>Vue.config.errorHandler</code> 全局错误处理函数。</p>
<ol start="5">
<li>控制台错误（可选）</li>
</ol>
<p>​    - 重写 <code>console.error</code> 方法，捕获通过 <code>console.error</code> 输出的错误。</p>
<ol start="6">
<li>接口错误</li>
</ol>
<p>​    - 重写 <code>XMLHttpRequest</code> 和 <code>fetch</code> 方法，拦截请求并监听错误。</p>
<p> 二、错误信息处理</p>
<p> 对捕获到的错误信息进行规范化处理，提取关键信息，包括：</p>
<p>   - 错误类型（如JS错误、资源错误、Promise错误等）</p>
<p>   - 错误消息</p>
<p>   - 错误堆栈（尽可能完整）</p>
<p>   - 发生错误的页面URL</p>
<p>   - 设备信息（如UA、屏幕分辨率、设备型号等，通过navigator获取）</p>
<p>   - 用户信息（如果有登录用户）</p>
<p>   - 发生时间</p>
<p>   - 其他上下文信息（如当前路由、前端版本号等）</p>
<p> 三、本地存储与上报</p>
<ol>
<li>本地存储</li>
</ol>
<p>​    - 使用浏览器提供的持久化存储（如IndexedDB）来存储错误日志。因为IndexedDB存储容量较大（通常50MB以上），且支持异步操作，不会阻塞主线程。</p>
<p>​    - 在断网情况下，将错误日志存入IndexedDB，并标记为待上报状态。</p>
<ol start="2">
<li>上报机制</li>
</ol>
<p>​    - 每次发生错误，先尝试立即上报（如果网络正常）。</p>
<p>​    - 如果上报失败（网络错误或服务器错误），则将错误日志存入IndexedDB。</p>
<p>​    - 定时检查（例如每5分钟）IndexedDB中是否有待上报的错误日志，如果有且网络可用，则进行上报。</p>
<p>​    - 在页面可见性变化时（例如用户切换回应用）检查并上报。</p>
<p>​    - 在页面关闭前（<code>visibilitychange</code> 和 <code>pagehide</code> 事件）尝试上报，但要注意此时不能使用同步的XHR（推荐使用 <code>navigator.sendBeacon</code> 方法）。</p>
<ol start="3">
<li>重试机制</li>
</ol>
<p>​    - 每条错误日志设置重试次数（如3次），超过重试次数则丢弃（避免存储爆满）。</p>
<p>​    - 每次重试间隔时间递增（指数退避策略）。</p>
<p> 四、网络恢复后的处理</p>
<p>   监听网络状态变化（<code>navigator.onLine</code>），当网络恢复时，触发一次上报。</p>
<p> 五、其他优化措施</p>
<ol>
<li><p>数据压缩：在存储和上报前，对数据进行压缩（如使用gzip，但前端压缩通常用lz-string等库进行简单压缩，或使用JSON字符串减少冗余字段名）。</p>
</li>
<li><p>批量上报：将多个错误日志合并为一个请求上报，减少请求次数。</p>
</li>
<li><p>采样率：根据错误类型和严重程度设置采样率，避免大量重复错误导致存储和上报压力。</p>
</li>
<li><p>存储上限：设置IndexedDB存储上限（如最多存储1000条错误日志），超过时丢弃旧日志。</p>
</li>
<li><p>区分环境：开发环境不上报，避免开发过程中产生的大量错误上报。</p>
</li>
</ol>
<h1 id="前端场景"><a href="#前端场景" class="headerlink" title="前端场景"></a>前端场景</h1><p>参考思路：<a href="%5B%E5%89%8D%E7%AB%AF%E5%8D%8F%E5%90%8C%E6%96%87%E6%A1%A3%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF_%E5%89%8D%E7%AB%AF%E6%96%87%E6%A1%A3%E5%8D%8F%E5%90%8C-CSDN%E5%8D%9A%E5%AE%A2%5D" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;Bruce__taotao&#x2F;article&#x2F;details&#x2F;148200821#:~:text&#x3D;本文介绍了前端协同文档系统的实现技术和方法，主要包括实时同步机制（WebSocket、OT和CRDT算法）、实时文本编辑（Diff算法和协作框架）、后端实现（数据库同步与技术栈）以及前端技术（React%2FVue和WebRTC）。 此外，还讨论了功能扩展如版本控制和权限管理，并提供了基于Vue.js和Node.js的简单实现示例。,协同文档开发需结合多种技术，确保实时性和数据一致性。 _前端协同算法">前端协同文档实现思路</a></p>
<h2 id="RN容器与浏览器容器的区别"><a href="#RN容器与浏览器容器的区别" class="headerlink" title="RN容器与浏览器容器的区别"></a>RN容器与浏览器容器的区别</h2><ol>
<li><strong>RN容器 (React Native 容器)</strong><ul>
<li><strong>目标：</strong> 在**原生移动应用（iOS&#x2F;Android）**中运行。</li>
<li><strong>核心：</strong> 它是一个<strong>原生应用框架</strong>（虽然使用了JavaScript）。React Native 应用最终会被编译&#x2F;打包成包含原生代码（Objective-C&#x2F;Swift for iOS, Java&#x2F;Kotlin for Android）的安装包（.ipa&#x2F;.apk）。</li>
<li><strong>渲染：</strong> <strong>不依赖浏览器引擎</strong>。RN 的核心在于其<strong>原生桥接</strong>。你的 JavaScript 代码（描述UI和逻辑）通过这个桥接与<strong>原生UI组件</strong>通信。当你在 RN 中写一个 <code>&lt;View&gt;</code> 或 <code>&lt;Text&gt;</code> 时，最终在屏幕上显示的是平台对应的原生视图（<code>UIView</code> on iOS, <code>android.view.View</code> on Android）。JavaScript 线程计算布局和逻辑，然后通过桥接将指令发送到原生主线程进行实际的渲染。</li>
<li><strong>能力：</strong> 可以<strong>直接访问绝大部分原生设备功能</strong>（摄像头、地理位置、传感器、文件系统、蓝牙等），通过 JavaScript 桥接调用原生模块实现。性能通常接近纯原生应用，尤其是在复杂UI和动画方面。</li>
<li><strong>打包：</strong> 最终打包成一个独立的、需要安装的<strong>原生移动应用</strong>。</li>
<li><strong>开发体验：</strong> 使用 JavaScript (或 TypeScript) 和 React 范式开发，但需要理解原生概念（如桥接、线程、原生模块）以及特定平台的差异。可以使用热重载。</li>
<li><strong>例子：</strong> Facebook、Instagram、Discord、Shopify 的部分功能。</li>
</ul>
</li>
<li><strong>浏览器容器 (Browser Container &#x2F; WebView)</strong><ul>
<li><strong>目标：</strong> 在<strong>任何有兼容浏览器（或 WebView 控件）</strong> 的环境（桌面、移动、电视、甚至某些嵌入式设备）中运行。</li>
<li><strong>核心：</strong> 它是一个<strong>网页渲染引擎</strong>（如 WebKit, Blink, Gecko）。浏览器容器（如 Chrome, Safari, Firefox，或者移动 App 内嵌的 <code>UIWebView</code>&#x2F;<code>WKWebView</code> on iOS, <code>WebView</code> on Android）的工作就是下载、解析 HTML&#x2F;CSS&#x2F;JavaScript 代码，并根据 Web 标准将其渲染成可视化的网页。</li>
<li><strong>渲染：</strong> <strong>完全依赖浏览器引擎</strong>。它渲染的是 <strong>HTML DOM 元素</strong> 和 <strong>CSS 样式</strong>。JavaScript 运行在浏览器提供的沙盒环境中，操作 DOM 和 CSSOM 来实现交互和动态效果。</li>
<li><strong>能力：</strong> 通过 Web APIs（如 <code>Geolocation API</code>, <code>Camera API (getUserMedia)</code>, <code>Web Bluetooth</code> 等）访问设备功能，但这些 API 的<strong>支持度、权限模型和性能通常不如原生访问直接和强大</strong>，且依赖于浏览器厂商的实现。性能受限于浏览器渲染引擎和 JavaScript 引擎。</li>
<li><strong>打包：</strong> 本质上是<strong>网页</strong>，通过 URL 访问（在线或离线包）。在移动端，可以通过 <strong>PWA</strong> 技术或简单的 <strong>WebView 封装</strong> 使其看起来更像一个 App（有图标、启动屏等），但其核心仍是网页。</li>
<li><strong>开发体验：</strong> 使用标准的 Web 技术（HTML, CSS, JavaScript）。一次编写，理论上可以在所有现代浏览器上运行（虽然存在兼容性问题）。开发工具链成熟（浏览器开发者工具）。热重载是标准功能。</li>
<li><strong>例子：</strong> 任何网站或 Web App。移动端内嵌 WebView 的混合应用（Hybrid App），或者 PWA（如 Twitter Lite, Starbucks PWA）。</li>
</ul>
</li>
</ol>
<p><strong>核心区别总结：</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">RN 容器 (React Native App)</th>
<th align="left">浏览器容器 (Web App &#x2F; WebView)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left"><strong>原生应用框架</strong> (JS驱动原生UI)</td>
<td align="left"><strong>网页渲染引擎</strong> (渲染 HTML&#x2F;CSS&#x2F;JS DOM)</td>
</tr>
<tr>
<td align="left"><strong>目标平台</strong></td>
<td align="left"><strong>原生移动平台 (iOS&#x2F;Android)</strong></td>
<td align="left"><strong>任何有兼容浏览器&#x2F;WebView的平台</strong></td>
</tr>
<tr>
<td align="left"><strong>最终产物</strong></td>
<td align="left">原生安装包 (.ipa&#x2F;.apk)</td>
<td align="left">网页资源 (HTML&#x2F;CSS&#x2F;JS)，通过 URL 访问</td>
</tr>
<tr>
<td align="left"><strong>渲染方式</strong></td>
<td align="left"><strong>原生UI组件</strong> (通过JS桥接驱动)</td>
<td align="left"><strong>HTML DOM &#x2F; CSSOM</strong> (由浏览器引擎渲染)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>接近原生</strong>，复杂UI&#x2F;动画更流畅</td>
<td align="left">受限于浏览器引擎，复杂场景可能较差</td>
</tr>
<tr>
<td align="left"><strong>设备访问</strong></td>
<td align="left"><strong>直接、强大</strong> (通过原生桥接模块)</td>
<td align="left"><strong>通过 Web APIs</strong>，支持度和能力有限</td>
</tr>
<tr>
<td align="left"><strong>开发技术</strong></td>
<td align="left">JS&#x2F;TS + React + 原生概念</td>
<td align="left">HTML + CSS + JS&#x2F;TS</td>
</tr>
<tr>
<td align="left"><strong>跨平台</strong></td>
<td align="left">需为iOS&#x2F;Android分别构建，代码可共享</td>
<td align="left"><strong>一次编写，随处运行</strong> (理论，需适配)</td>
</tr>
<tr>
<td align="left"><strong>安装</strong></td>
<td align="left">需要从应用商店下载安装</td>
<td align="left">通过URL访问，PWA可“安装”到桌面&#x2F;主屏</td>
</tr>
<tr>
<td align="left"><strong>更新</strong></td>
<td align="left">需通过应用商店审核更新</td>
<td align="left"><strong>即时更新</strong> (服务器端更新资源即可)</td>
</tr>
</tbody></table>
<p><strong>简单类比：</strong></p>
<ul>
<li><strong>RN容器：</strong> 像一个用JavaScript编写的“说明书”，交给当地（iOS&#x2F;Android）的“施工队”（原生桥接和组件）按照说明书，用当地最好的“建材”（原生UI组件）来建造房子（App）。结果是本地化的、高质量的房子。</li>
<li><strong>浏览器容器：</strong> 像一个预制的“活动板房”（网页）。施工队（浏览器引擎）按照统一的“国际标准”（Web标准），用自带的“标准化板材”（HTML&#x2F;CSS）在任何地方快速搭建。房子可以快速搭建和修改，但可能不如本地定制的那么坚固或贴合当地环境。</li>
</ul>
<p><strong>选择哪一个？</strong></p>
<ul>
<li>需要<strong>最佳性能、深度设备集成、原生用户体验</strong> -&gt; <strong>React Native</strong>。</li>
<li>需要<strong>最广泛的跨平台覆盖（包括Web）、最快的开发迭代速度、即时更新</strong> -&gt; <strong>浏览器容器 (Web技术&#x2F;PWA)</strong>。</li>
<li>混合方案：在原生App中嵌入<strong>WebView</strong>来展示部分内容（如帮助页面、营销活动页），结合两者优势。React Native 本身也提供了 <code>WebView</code> 组件来实现这一点。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/" data-id="cmchb34xk0000c4ur8wemfedc" data-title="前端性能[C" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E3%80%81%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E3%80%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" rel="tag">前端页面、错误监控、性能指标</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2025/06/28/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">基础开发</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/html-css-javascript/" rel="tag">html css javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E3%80%81%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E3%80%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" rel="tag">前端页面、错误监控、性能指标</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" rel="tag">计算机网络，浏览器原理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/html-css-javascript/" style="font-size: 10px;">html css javascript</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E3%80%81%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E3%80%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" style="font-size: 10px;">前端页面、错误监控、性能指标</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" style="font-size: 10px;">计算机网络，浏览器原理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/">前端性能[C</a>
          </li>
        
          <li>
            <a href="/2025/06/28/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/">基础开发</a>
          </li>
        
          <li>
            <a href="/2025/06/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a>
          </li>
        
          <li>
            <a href="/2025/06/27/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>