<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-前端性能" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/" class="article-date">
  <time class="dt-published" datetime="2025-06-29T06:44:38.000Z" itemprop="datePublished">2025-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/">前端性能[C</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Js错误"><a href="#Js错误" class="headerlink" title="Js错误"></a>Js错误</h1><h2 id="JavaScript-错误类型总览"><a href="#JavaScript-错误类型总览" class="headerlink" title="JavaScript 错误类型总览"></a>JavaScript 错误类型总览</h2><table>
<thead>
<tr>
<th align="left">错误类型</th>
<th align="left">触发场景</th>
<th align="left">示例代码</th>
<th align="left">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SyntaxError</strong></td>
<td align="left">语法错误</td>
<td align="left"><code>if (a) &#123;</code></td>
<td align="left">修复代码语法</td>
</tr>
<tr>
<td align="left"><strong>ReferenceError</strong></td>
<td align="left">访问未声明变量</td>
<td align="left"><code>console.log(undeclaredVar);</code></td>
<td align="left">声明变量或检查变量作用域</td>
</tr>
<tr>
<td align="left"><strong>TypeError</strong></td>
<td align="left">类型不匹配操作</td>
<td align="left"><code>null.func();</code></td>
<td align="left">添加类型检查</td>
</tr>
<tr>
<td align="left"><strong>RangeError</strong></td>
<td align="left">数值超出有效范围</td>
<td align="left"><code>new Array(-1);</code></td>
<td align="left">验证输入值范围</td>
</tr>
<tr>
<td align="left"><strong>URIError</strong></td>
<td align="left">URI处理函数使用无效参数</td>
<td align="left"><code>decodeURIComponent(&#39;%&#39;);</code></td>
<td align="left">验证URI参数</td>
</tr>
<tr>
<td align="left"><strong>EvalError</strong></td>
<td align="left"><code>eval()</code> 函数使用不当</td>
<td align="left"><code>new eval();</code></td>
<td align="left">避免使用eval</td>
</tr>
<tr>
<td align="left"><strong>AggregateError</strong></td>
<td align="left">多个错误组合</td>
<td align="left"><code>Promise.any([rejectedPromises]);</code></td>
<td align="left">处理多个错误</td>
</tr>
<tr>
<td align="left"><strong>自定义错误</strong></td>
<td align="left">开发者主动抛出</td>
<td align="left"><code>throw new CustomError(&#39;msg&#39;);</code></td>
<td align="left">实现特定错误处理逻辑</td>
</tr>
</tbody></table>
<h3 id="1-SyntaxError（语法错误）"><a href="#1-SyntaxError（语法错误）" class="headerlink" title="1. SyntaxError（语法错误）"></a>1. SyntaxError（语法错误）</h3><p><strong>触发时机</strong>：代码解析阶段<br><strong>常见场景</strong>：</p>
<ul>
<li>缺少括号、引号或花括号</li>
<li>错误使用保留字</li>
<li>无效的表达式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1: 缺少括号</span></span><br><span class="line"><span class="keyword">if</span> (a &#123;  <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;&#123;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: 无效赋值</span></span><br><span class="line"><span class="keyword">const</span> 123<span class="keyword">var</span> = <span class="string">&quot;test&quot;</span>;  <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>

<h3 id="2-ReferenceError（引用错误）"><a href="#2-ReferenceError（引用错误）" class="headerlink" title="2. ReferenceError（引用错误）"></a>2. ReferenceError（引用错误）</h3><p><strong>触发时机</strong>：运行时<br><strong>常见场景</strong>：</p>
<ul>
<li>访问未声明的变量</li>
<li>访问块作用域变量（let&#x2F;const）的TDZ（暂时性死区）</li>
<li>模块导入错误</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1: 未声明变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(undeclaredVar);  <span class="comment">// Uncaught ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: TDZ访问</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);  <span class="comment">// Uncaught ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-TypeError（类型错误）"><a href="#3-TypeError（类型错误）" class="headerlink" title="3. TypeError（类型错误）"></a>3. TypeError（类型错误）</h3><p><strong>触发时机</strong>：操作不符合变量类型<br><strong>常见场景</strong>：</p>
<ul>
<li>调用非函数值</li>
<li>访问null&#x2F;undefined的属性</li>
<li>尝试修改常量值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1: 调用非函数</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="title function_">num</span>();  <span class="comment">// Uncaught TypeError: num is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: 访问null属性</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">property</span>);  <span class="comment">// Uncaught TypeError: Cannot read property</span></span><br></pre></td></tr></table></figure>

<h3 id="4-RangeError（范围错误）"><a href="#4-RangeError（范围错误）" class="headerlink" title="4. RangeError（范围错误）"></a>4. RangeError（范围错误）</h3><p><strong>触发时机</strong>：参数超出有效范围<br><strong>常见场景</strong>：</p>
<ul>
<li>无效数组长度</li>
<li>数字方法参数越界</li>
<li>递归深度过大</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1: 无效数组长度</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(-<span class="number">1</span>);  <span class="comment">// Uncaught RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: 数字精度超限</span></span><br><span class="line">(<span class="number">123.456</span>).<span class="title function_">toFixed</span>(<span class="number">101</span>);  <span class="comment">// Uncaught RangeError: toFixed() digits argument must be between 0 and 100</span></span><br></pre></td></tr></table></figure>

<h3 id="5-URIError（URI错误）"><a href="#5-URIError（URI错误）" class="headerlink" title="5. URIError（URI错误）"></a>5. URIError（URI错误）</h3><p><strong>触发时机</strong>：URI处理函数参数无效<br><strong>仅影响</strong>：<code>encodeURI()</code>, <code>decodeURI()</code>, <code>encodeURIComponent()</code>, <code>decodeURIComponent()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例: 无效URI解码</span></span><br><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="string">&#x27;%&#x27;</span>);  <span class="comment">// Uncaught URIError: URI malformed</span></span><br></pre></td></tr></table></figure>

<h3 id="6-EvalError（eval错误）"><a href="#6-EvalError（eval错误）" class="headerlink" title="6. EvalError（eval错误）"></a>6. EvalError（eval错误）</h3><p><strong>触发时机</strong>：<code>eval()</code> 函数使用不当<br><strong>注意</strong>：现代JavaScript中很少见，保留用于兼容性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 历史用法 (现代JS引擎不再抛出)</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EvalError</span>(<span class="string">&quot;Eval error&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e <span class="keyword">instanceof</span> <span class="title class_">EvalError</span>);  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-AggregateError（聚合错误）"><a href="#7-AggregateError（聚合错误）" class="headerlink" title="7. AggregateError（聚合错误）"></a>7. AggregateError（聚合错误）</h3><p><strong>触发时机</strong>：多个错误需要同时报告<br><strong>常见于</strong>：<code>Promise.any()</code> 全部拒绝时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Error 1&quot;</span>)),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Error 2&quot;</span>))</span><br><span class="line">]).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e <span class="keyword">instanceof</span> <span class="title class_">AggregateError</span>);  <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">errors</span>.<span class="property">length</span>);  <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="WebIDL和ecma-262中的错误类型"><a href="#WebIDL和ecma-262中的错误类型" class="headerlink" title="WebIDL和ecma-262中的错误类型"></a>WebIDL和ecma-262中的错误类型</h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=WCsyJ0SbM68nFUfknuxc4g==.suEaakDxsFgunJR89KoRM2icTf23NuhbkJlXUUrVWbBpYg3tSQ3Qcro+8NlH58ZUTRaKRVPug72ITCAseJfwzPkhe/P6CqFiA14nNIjGM7E=">ECMAScript exceptions</a> &lt;&#x3D;&#x3D;&gt; <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=PKwXx59Icv2HdaKCGITj+w==.ZkwDXSwbBVZSMF94vbPpyK+w3iC2bcBf19ml+tcJNstSYLackci+BgNMsdSmvchdLjCH5bbjMMICt01dZB8DuA==">IDL 的简单异常</a></p>
<p>当脚本代码运行时发生的错误，会创建Error对象，并将其抛出，除了通用的Error构造函数外，以下是另外几个ECMAScript 2015中定义的错误构造函数。</p>
<ul>
<li><strong>EvalError</strong> eval错误</li>
<li><strong>RangeError</strong> 范围错误</li>
<li><strong>ReferenceError</strong> 引用错误</li>
<li><strong>TypeError</strong> 类型错误</li>
<li><strong>URIError</strong> URI错误</li>
<li><strong>SyntaxError</strong> 语法错误 (这个错误WebIDL中故意省略，保留给ES解析器使用)</li>
<li><strong>Error</strong> 通用错误 （这个错误WebIDL中故意省略，保留给开发者使用使用）</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=Qaux4NrI17y7bOplFMyitw==.cL487ezp3TEsLOuy+TKH9OHDliMsEWajxxayEUwyqYIqv9RbXRCkouXogfTnmFZbGfw3Oo476yuXgMBVsvAeEQ==">DOMException</a> 最新的DOM规范定义的错误类型集，兼容旧浏览的DOMError接口, 完善和规范化DOM错误类型。</p>
<ul>
<li><strong>IndexSizeError</strong> 索引不在允许的范围内</li>
<li><strong>HierarchyRequestError</strong> 节点树层次结构是不正确的。</li>
<li><strong>WrongDocumentError</strong> 对象是错误的</li>
<li><strong>InvalidCharacterError</strong> 字符串包含无效字符。</li>
<li><strong>NoModificationAllowedError</strong> 对象不能被修改。</li>
<li><strong>NotFoundError</strong> 对象不能在这里被找到。</li>
<li><strong>NotSupportedError</strong> 不支持的操作</li>
<li><strong>InvalidStateError</strong> 对象是一个无效的状态。</li>
<li><strong>SyntaxError</strong> 字符串不匹配预期的模式</li>
<li><strong>InvalidModificationError</strong> 对象不能以这种方式被修改</li>
<li><strong>NamespaceError</strong> 操作在XML命名空间内是不被允许的</li>
<li><strong>InvalidAccessError</strong> 对象不支持这种操作或参数。</li>
<li><strong>TypeMismatchError</strong> 对象的类型不匹配预期的类型。</li>
<li><strong>SecurityError</strong> 此操作是不安全的。</li>
<li><strong>NetworkError</strong> 发生网络错误</li>
<li><strong>AbortError</strong> 操作被中止</li>
<li><strong>URLMismatchError</strong> 给定的URL不匹配另一个URL。</li>
<li><strong>QuotaExceededError</strong> 已经超过给定配额。</li>
<li><strong>TimeoutError</strong> 操作超时。</li>
<li><strong>InvalidNodeTypeError</strong> 这个操作的 节点或节点祖先 是不正确的</li>
<li><strong>DataCloneError</strong> 对象不能克隆。</li>
</ul>
</li>
</ul>
<h3 id="前端错误异常按照捕获方式分类"><a href="#前端错误异常按照捕获方式分类" class="headerlink" title="前端错误异常按照捕获方式分类"></a>前端错误异常按照捕获方式分类</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 语法错误</li>
<li><input checked="" disabled="" type="checkbox"> 运行时异常</li>
<li><input checked="" disabled="" type="checkbox"> 资源加载异常<ul>
<li>img</li>
<li>script</li>
<li>link</li>
<li>audio</li>
<li>video</li>
<li>iframe</li>
<li>…外链资源的DOM元素</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> 异步请求异常<ul>
<li>XMLHttpRequest</li>
<li>fetch</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> Promise异常</li>
<li><input disabled="" type="checkbox"> <del>CSS中资源异常</del><ul>
<li>@font-face</li>
<li>background-image</li>
<li>…暂时无法捕获</li>
</ul>
</li>
</ul>
<h3 id="前端错误异常的捕获方式"><a href="#前端错误异常的捕获方式" class="headerlink" title="前端错误异常的捕获方式"></a>前端错误异常的捕获方式</h3><ul>
<li>try-catch (ES提供基本的错误捕获语法)<ul>
<li>只能捕获同步代码的异常</li>
<li><del>回调</del></li>
<li><del>setTimeout</del></li>
<li><del>promise</del></li>
</ul>
</li>
<li><strong>window.onerror &#x3D; cb (DOM0)</strong><ul>
<li>img</li>
<li>script</li>
<li>link</li>
</ul>
</li>
<li>window.addEventListener(‘error’, cb, true) (DOM2)</li>
<li>window.addEventListener(“unhandledrejection”, cb) (DOM4)</li>
<li>Promise.then().catch(cb)</li>
<li>封装XMLHttpRequest&amp;fetch | 覆写请求接口对象</li>
</ul>
<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p>将能引发异常的代码块放到try中，并对应一个响应，然后有异常会被捕获</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 模拟一段可能有错误的代码</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;会有错误的代码块&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">  <span class="comment">// 捕获到try中代码块的错误得到一个错误对象e，进行处理分析</span></span><br><span class="line">  <span class="title function_">report</span>(e)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;finally&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="onerror事件"><a href="#onerror事件" class="headerlink" title="onerror事件"></a>onerror事件</h4><h5 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h5><p>当JavaScript运行时错误（包括语法错误）发生时，window会触发一个ErrorEvent接口的事件，并执行window.onerror();</p>
<p>但这里有个信息要注意，语法错误会导致出现语法错误的那个脚本块执行失败，所以语法错误会导致当前代码块运行终止，从而导致整个程序运行中断，如果语法错误这个发生在我们的错误监控语句块中，那么我们就什么也监控不到了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 运行时错误处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; message 错误信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; source 发生错误的脚本URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; lineno 发生错误的行号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; colno 发生错误的列号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">object</span>&#125; error Error对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">err</span>(<span class="params">message,source,lineno,colno,error</span>) &#123;...&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = err</span><br></pre></td></tr></table></figure>

<h5 id="element-onerror"><a href="#element-onerror" class="headerlink" title="element.onerror"></a>element.onerror</h5><p>当一项资源（如<code>&lt;img&gt;</code>或<code>&lt;script&gt;</code>）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; ... &#125; <span class="comment">//注意和window.onerror的参数不同</span></span><br></pre></td></tr></table></figure>

<p>注意：这些error事件不会向上冒泡到window，不过能被单一的window.addEventListener捕获。</p>
<h5 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h5><h5 id="addEventListener相关的一些内容"><a href="#addEventListener相关的一些内容" class="headerlink" title="addEventListener相关的一些内容"></a>addEventListener相关的一些内容</h5><p>W3C DOM2 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=t0fRx2nVaR1eu7VXBZ0Oyw==./f7iMYPHVLL1SJ7Tsr8UBsyS07dvVmnWFnPkFkJMUE383Svkr3So82kOIjNpQpQl">Events</a>规范中提供的注册事件监听器的方法, 在这之前均使用<br><code>el.onclick</code>的形式（DOM0 规范的基本内容，几乎所有浏览器都支持）。</p>
<p>注意： <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=jhXgag8h/rd9UmLYcpREUw==.gyww6nUd6BCIKiObOuusn+K7pdiHTFxvnJrdeLqnQ2YuJAup9f50b3dTfzUjfcWVmy/T+2pz16NB64TCAJStAbOv8JVXfXroRUjMA3B3dXo=">接口的几种语法</a></p>
<h5 id="error事件捕获资源加载错误"><a href="#error事件捕获资源加载错误" class="headerlink" title="error事件捕获资源加载错误"></a>error事件捕获资源加载错误</h5><p>资源加载失败，不会冒泡，但是会被addEventListener捕获，所以我们可以指定在加载失败事件的捕获阶段捕获该错误。</p>
<p>注意: 接口同时也能捕获运行时错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;error&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> eventType = [].<span class="property">toString</span>.<span class="title function_">call</span>(e, e);</span><br><span class="line">    <span class="keyword">if</span> (eventType === <span class="string">&quot;[object Event]&quot;</span>) &#123; <span class="comment">// 过滤掉运行时错误</span></span><br><span class="line">      <span class="comment">// 上报加载错误</span></span><br><span class="line">      <span class="title function_">report</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="unhandledrejection事件捕获Promise异常"><a href="#unhandledrejection事件捕获Promise异常" class="headerlink" title="unhandledrejection事件捕获Promise异常"></a>unhandledrejection事件捕获Promise异常</h5><p>最新的规范中定义了 unhandledrejection事件用于全局捕获promise对象没有rejection处理器时异常情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// ...your code here to handle the unhandled rejection...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent the default handling (error in console)</span></span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Promise-then-catch-cb-finally"><a href="#Promise-then-catch-cb-finally" class="headerlink" title="Promise.then().catch(cb).finally()"></a>Promise.then().catch(cb).finally()</h4><p>Promise中的错误会被Promise.prototype.catch捕获，所以我们通过这种方式捕获错误，这包括一些不支持unhandledrejection事件的环境中promisede polyfill实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;Uncaught Exception!&#x27;</span>;</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// Uncaught Exception!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="封装XMLHttpRequest-fetch-覆写请求接口对象"><a href="#封装XMLHttpRequest-fetch-覆写请求接口对象" class="headerlink" title="封装XMLHttpRequest&amp;fetch | 覆写请求接口对象"></a>封装XMLHttpRequest&amp;fetch | 覆写请求接口对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 覆写XMLHttpRequest API</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> xmlhttp = <span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>;</span><br><span class="line">  <span class="keyword">var</span> _oldSend = xmlhttp.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">send</span>;</span><br><span class="line">  <span class="keyword">var</span> _handleEvent = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (event &amp;&amp; event.<span class="property">currentTarget</span> &amp;&amp; event.<span class="property">currentTarget</span>.<span class="property">status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">report</span>(event)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xmlhttp.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">send</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>]) &#123;</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>](<span class="string">&#x27;error&#x27;</span>, _handleEvent);</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>](<span class="string">&#x27;load&#x27;</span>, _handleEvent);</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>](<span class="string">&#x27;abort&#x27;</span>, _handleEvent);</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>](<span class="string">&#x27;close&#x27;</span>, _handleEvent);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> _oldStateChange = <span class="variable language_">this</span>[<span class="string">&#x27;onreadystatechange&#x27;</span>];</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;onreadystatechange&#x27;</span>] = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">                  <span class="title function_">_handleEvent</span>(event);</span><br><span class="line">              &#125;</span><br><span class="line">              _oldStateChange &amp;&amp; _oldStateChange.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> _oldSend.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写fetch API</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="property">fetch</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">var</span> _oldFetch = <span class="variable language_">window</span>.<span class="property">fetch</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">fetch</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _oldFetch</span><br><span class="line">    .<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!res.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="comment">// True if status is HTTP 2xx</span></span><br><span class="line">        <span class="title function_">report</span>(res)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">      <span class="title function_">report</span>(res)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="日志上报的方式"><a href="#日志上报的方式" class="headerlink" title="日志上报的方式"></a>日志上报的方式</h3><ul>
<li>异步请求上报, 后端提供接口，或者直接发到日志服务器</li>
<li>img请求上报, url参数带上错误信息<ul>
<li><code>eg:(new Image()).src = &#39;http://baidu.com/tesjk?r=tksjk&#39;</code></li>
</ul>
</li>
</ul>
<h4 id="注意跨源脚本异常"><a href="#注意跨源脚本异常" class="headerlink" title="注意跨源脚本异常"></a>注意跨源脚本异常</h4><p>当加载自不同域的脚本中发生语法错误时，为避免信息泄露，语法错误的细节将不会报告，而代之简单的 “Script error.”</p>
<p>由于同源策略影响，浏览器限制跨源脚本的错误访问，这样跨源脚本错误报错信息如下图：</p>
<p><img src="https://segmentfault.com/img/bV7tjY?w=372&h=126" alt="跨源的脚本的异常"></p>
<p>在H5的规定中，只要满足下面俩个条件，是允许获取跨源脚本的错误信息的。</p>
<ol>
<li>客户端在script标签上增加crossorigin属性；</li>
<li>服务端设置js资源响应头Access-Control-Origin:*（或者是域名）。</li>
</ol>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><h4 id="业界已经有的监控平台"><a href="#业界已经有的监控平台" class="headerlink" title="业界已经有的监控平台"></a>业界已经有的监控平台</h4><ul>
<li>Sentry开源</li>
<li>阿里的ARMS</li>
<li>fundebug</li>
<li>FrontJS</li>
</ul>
<h4 id="几个异常监控的问题"><a href="#几个异常监控的问题" class="headerlink" title="几个异常监控的问题"></a>几个异常监控的问题</h4><ul>
<li><p>如何保证大家提交的代码是符合预期的？ 如何了解前端项目的运行是否正常，是否存在错误？</p>
<p>代码质量体系控制和错误监控以及性能分析</p>
</li>
<li><p>如果用户使用网页，发现白屏，现在联系上了你们，你们会向他询问什么信息呢？先想一下为什么会白屏？</p>
<p>我们以用户访问页面的过程为顺序，大致排查一下</p>
<ol>
<li>用户没打开网络</li>
<li>DNS域名劫持</li>
<li>http劫持</li>
<li>cdn或是其他资源文件访问出错</li>
<li>服务器错误</li>
<li>前端代码错误</li>
<li>前端兼容性问题</li>
<li>用户操作出错</li>
</ol>
</li>
</ul>
<p>通过以上可能发生错误的环节，我们需要向用户手机一下以下的用户信息</p>
<ol>
<li>当前的网络状态</li>
<li>运营商</li>
<li>地理位置</li>
<li>访问时间</li>
<li>客户端的版本(如果是通过客户端访问)</li>
<li>系统版本</li>
<li>浏览器信息</li>
<li>设备分辨率</li>
<li>页面的来源</li>
<li>用户的账号信息</li>
<li>通过performance API收集用户各个页面访问流程所消耗的时间</li>
<li>收集用户js代码报错的信息</li>
</ol>
<ul>
<li>如果我们使用了脚本代码压缩，然而我们又不想将sourcemap文件发布到线上，我们怎么捕获到错误的具体信息？</li>
<li>CSS文件中也存在引用资源，@font-face, background-image …等这些请求错误该如何进行错误捕获？</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Web规范中相关前端异常<ul>
<li>DOM处理异常</li>
<li>ECMAScript处理异常</li>
</ul>
</li>
<li>异常按照捕获方式分类<ul>
<li>运行时异常</li>
<li>资源加载异常</li>
<li>异步请求异常</li>
<li>Promise异常</li>
</ul>
</li>
<li>异常的捕获方式<ul>
<li>try-catch (ES提供基本的错误捕获语法)<ul>
<li>只能捕获同步代码的异常</li>
<li><del>回调</del></li>
<li><del>setTimeout</del></li>
<li><del>promise</del></li>
</ul>
</li>
<li>window.onerror &#x3D; cb (DOM0)<ul>
<li>img</li>
<li>script</li>
<li>link</li>
</ul>
</li>
<li>window.addEventListener(‘error’, cb, true) (DOM2)</li>
<li>window.addEventListener(“unhandledrejection”, cb) (DOM4)</li>
<li>Promise.then().catch(cb)</li>
<li>封装XMLHttpRequest&amp;fetch | 覆写请求接口对象</li>
</ul>
</li>
</ul>
<p>注意点：跨源脚本异常的捕获</p>
<ul>
<li><p>日志上报的方式</p>
<ul>
<li>异步请求上报</li>
<li>new img上报 避免跨域问题</li>
</ul>
</li>
<li><p>扩展阅读</p>
<ul>
<li>业界已有的异常监控平台</li>
<li>几个跟异常监控有关的问题</li>
</ul>
</li>
</ul>
<p>为了在移动端项目中实现前端错误监控，并考虑极端断网环境，我们需要设计一个健壮且全面的技术方案。移动端环境具有网络不稳定（弱网、断网）、设备多样性、操作系统差异等特点，因此方案需要具备以下能力：</p>
<ol>
<li><p>错误捕获：全面捕获JS错误、资源加载错误、接口错误、框架错误（如React&#x2F;Vue）、Promise错误等。</p>
</li>
<li><p>数据存储：在断网情况下，能够将错误信息暂存本地，待网络恢复后上报。</p>
</li>
<li><p>上报机制：支持重试机制，避免因网络问题导致数据丢失。</p>
</li>
<li><p>数据压缩与批处理：减少网络请求，节省流量。</p>
</li>
<li><p>区分错误类型：对错误进行分类，便于分析。</p>
</li>
</ol>
<p> 我们将从以下几个方面进行设计：</p>
<p> 一、错误捕获</p>
<p> 二、错误信息处理</p>
<p> 三、本地存储与上报</p>
<p> 四、网络恢复后的处理</p>
<p> 五、其他优化措施</p>
<p> 详细方案如下：</p>
<p> 一、错误捕获</p>
<ol>
<li>JavaScript运行时错误</li>
</ol>
<p>​    - 使用 <code>window.onerror</code> 捕获全局同步错误。</p>
<p>​    - 注意：<code>window.onerror</code> 无法捕获语法错误（一般会在编译阶段发现，不会进入线上环境）和跨域脚本错误（需要为跨域脚本添加 <code>crossorigin</code> 属性）。</p>
<ol start="2">
<li>Promise错误</li>
</ol>
<p>​    - 使用 <code>unhandledrejection</code> 事件捕获未处理的Promise拒绝。</p>
<ol start="3">
<li>资源加载错误</li>
</ol>
<p>​    - 使用 <code>window.addEventListener(&#39;error&#39;, callback, true)</code> 捕获资源（如图片、脚本、样式）加载错误。注意第三个参数为 <code>true</code>（捕获阶段）。</p>
<ol start="4">
<li>框架错误</li>
</ol>
<p>​    - React：使用 <code>ErrorBoundary</code> 组件捕获组件树中的错误。</p>
<p>​    - Vue：使用 <code>Vue.config.errorHandler</code> 全局错误处理函数。</p>
<ol start="5">
<li>控制台错误（可选）</li>
</ol>
<p>​    - 重写 <code>console.error</code> 方法，捕获通过 <code>console.error</code> 输出的错误。</p>
<ol start="6">
<li>接口错误</li>
</ol>
<p>​    - 重写 <code>XMLHttpRequest</code> 和 <code>fetch</code> 方法，拦截请求并监听错误。</p>
<p> 二、错误信息处理</p>
<p> 对捕获到的错误信息进行规范化处理，提取关键信息，包括：</p>
<p>   - 错误类型（如JS错误、资源错误、Promise错误等）</p>
<p>   - 错误消息</p>
<p>   - 错误堆栈（尽可能完整）</p>
<p>   - 发生错误的页面URL</p>
<p>   - 设备信息（如UA、屏幕分辨率、设备型号等，通过navigator获取）</p>
<p>   - 用户信息（如果有登录用户）</p>
<p>   - 发生时间</p>
<p>   - 其他上下文信息（如当前路由、前端版本号等）</p>
<p> 三、本地存储与上报</p>
<ol>
<li>本地存储</li>
</ol>
<p>​    - 使用浏览器提供的持久化存储（如IndexedDB）来存储错误日志。因为IndexedDB存储容量较大（通常50MB以上），且支持异步操作，不会阻塞主线程。</p>
<p>​    - 在断网情况下，将错误日志存入IndexedDB，并标记为待上报状态。</p>
<ol start="2">
<li>上报机制</li>
</ol>
<p>​    - 每次发生错误，先尝试立即上报（如果网络正常）。</p>
<p>​    - 如果上报失败（网络错误或服务器错误），则将错误日志存入IndexedDB。</p>
<p>​    - 定时检查（例如每5分钟）IndexedDB中是否有待上报的错误日志，如果有且网络可用，则进行上报。</p>
<p>​    - 在页面可见性变化时（例如用户切换回应用）检查并上报。</p>
<p>​    - 在页面关闭前（<code>visibilitychange</code> 和 <code>pagehide</code> 事件）尝试上报，但要注意此时不能使用同步的XHR（推荐使用 <code>navigator.sendBeacon</code> 方法）。</p>
<ol start="3">
<li>重试机制</li>
</ol>
<p>​    - 每条错误日志设置重试次数（如3次），超过重试次数则丢弃（避免存储爆满）。</p>
<p>​    - 每次重试间隔时间递增（指数退避策略）。</p>
<p> 四、网络恢复后的处理</p>
<p>   监听网络状态变化（<code>navigator.onLine</code>），当网络恢复时，触发一次上报。</p>
<p> 五、其他优化措施</p>
<ol>
<li><p>数据压缩：在存储和上报前，对数据进行压缩（如使用gzip，但前端压缩通常用lz-string等库进行简单压缩，或使用JSON字符串减少冗余字段名）。</p>
</li>
<li><p>批量上报：将多个错误日志合并为一个请求上报，减少请求次数。</p>
</li>
<li><p>采样率：根据错误类型和严重程度设置采样率，避免大量重复错误导致存储和上报压力。</p>
</li>
<li><p>存储上限：设置IndexedDB存储上限（如最多存储1000条错误日志），超过时丢弃旧日志。</p>
</li>
<li><p>区分环境：开发环境不上报，避免开发过程中产生的大量错误上报。</p>
</li>
</ol>
<h1 id="前端场景"><a href="#前端场景" class="headerlink" title="前端场景"></a>前端场景</h1><p>参考思路：<a href="%5B%E5%89%8D%E7%AB%AF%E5%8D%8F%E5%90%8C%E6%96%87%E6%A1%A3%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF_%E5%89%8D%E7%AB%AF%E6%96%87%E6%A1%A3%E5%8D%8F%E5%90%8C-CSDN%E5%8D%9A%E5%AE%A2%5D" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;Bruce__taotao&#x2F;article&#x2F;details&#x2F;148200821#:~:text&#x3D;本文介绍了前端协同文档系统的实现技术和方法，主要包括实时同步机制（WebSocket、OT和CRDT算法）、实时文本编辑（Diff算法和协作框架）、后端实现（数据库同步与技术栈）以及前端技术（React%2FVue和WebRTC）。 此外，还讨论了功能扩展如版本控制和权限管理，并提供了基于Vue.js和Node.js的简单实现示例。,协同文档开发需结合多种技术，确保实时性和数据一致性。 _前端协同算法">前端协同文档实现思路</a></p>
<h2 id="RN容器与浏览器容器的区别"><a href="#RN容器与浏览器容器的区别" class="headerlink" title="RN容器与浏览器容器的区别"></a>RN容器与浏览器容器的区别</h2><ol>
<li><strong>RN容器 (React Native 容器)</strong><ul>
<li><strong>目标：</strong> 在**原生移动应用（iOS&#x2F;Android）**中运行。</li>
<li><strong>核心：</strong> 它是一个<strong>原生应用框架</strong>（虽然使用了JavaScript）。React Native 应用最终会被编译&#x2F;打包成包含原生代码（Objective-C&#x2F;Swift for iOS, Java&#x2F;Kotlin for Android）的安装包（.ipa&#x2F;.apk）。</li>
<li><strong>渲染：</strong> <strong>不依赖浏览器引擎</strong>。RN 的核心在于其<strong>原生桥接</strong>。你的 JavaScript 代码（描述UI和逻辑）通过这个桥接与<strong>原生UI组件</strong>通信。当你在 RN 中写一个 <code>&lt;View&gt;</code> 或 <code>&lt;Text&gt;</code> 时，最终在屏幕上显示的是平台对应的原生视图（<code>UIView</code> on iOS, <code>android.view.View</code> on Android）。JavaScript 线程计算布局和逻辑，然后通过桥接将指令发送到原生主线程进行实际的渲染。</li>
<li><strong>能力：</strong> 可以<strong>直接访问绝大部分原生设备功能</strong>（摄像头、地理位置、传感器、文件系统、蓝牙等），通过 JavaScript 桥接调用原生模块实现。性能通常接近纯原生应用，尤其是在复杂UI和动画方面。</li>
<li><strong>打包：</strong> 最终打包成一个独立的、需要安装的<strong>原生移动应用</strong>。</li>
<li><strong>开发体验：</strong> 使用 JavaScript (或 TypeScript) 和 React 范式开发，但需要理解原生概念（如桥接、线程、原生模块）以及特定平台的差异。可以使用热重载。</li>
<li><strong>例子：</strong> Facebook、Instagram、Discord、Shopify 的部分功能。</li>
</ul>
</li>
<li><strong>浏览器容器 (Browser Container &#x2F; WebView)</strong><ul>
<li><strong>目标：</strong> 在<strong>任何有兼容浏览器（或 WebView 控件）</strong> 的环境（桌面、移动、电视、甚至某些嵌入式设备）中运行。</li>
<li><strong>核心：</strong> 它是一个<strong>网页渲染引擎</strong>（如 WebKit, Blink, Gecko）。浏览器容器（如 Chrome, Safari, Firefox，或者移动 App 内嵌的 <code>UIWebView</code>&#x2F;<code>WKWebView</code> on iOS, <code>WebView</code> on Android）的工作就是下载、解析 HTML&#x2F;CSS&#x2F;JavaScript 代码，并根据 Web 标准将其渲染成可视化的网页。</li>
<li><strong>渲染：</strong> <strong>完全依赖浏览器引擎</strong>。它渲染的是 <strong>HTML DOM 元素</strong> 和 <strong>CSS 样式</strong>。JavaScript 运行在浏览器提供的沙盒环境中，操作 DOM 和 CSSOM 来实现交互和动态效果。</li>
<li><strong>能力：</strong> 通过 Web APIs（如 <code>Geolocation API</code>, <code>Camera API (getUserMedia)</code>, <code>Web Bluetooth</code> 等）访问设备功能，但这些 API 的<strong>支持度、权限模型和性能通常不如原生访问直接和强大</strong>，且依赖于浏览器厂商的实现。性能受限于浏览器渲染引擎和 JavaScript 引擎。</li>
<li><strong>打包：</strong> 本质上是<strong>网页</strong>，通过 URL 访问（在线或离线包）。在移动端，可以通过 <strong>PWA</strong> 技术或简单的 <strong>WebView 封装</strong> 使其看起来更像一个 App（有图标、启动屏等），但其核心仍是网页。</li>
<li><strong>开发体验：</strong> 使用标准的 Web 技术（HTML, CSS, JavaScript）。一次编写，理论上可以在所有现代浏览器上运行（虽然存在兼容性问题）。开发工具链成熟（浏览器开发者工具）。热重载是标准功能。</li>
<li><strong>例子：</strong> 任何网站或 Web App。移动端内嵌 WebView 的混合应用（Hybrid App），或者 PWA（如 Twitter Lite, Starbucks PWA）。</li>
</ul>
</li>
</ol>
<p><strong>核心区别总结：</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">RN 容器 (React Native App)</th>
<th align="left">浏览器容器 (Web App &#x2F; WebView)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left"><strong>原生应用框架</strong> (JS驱动原生UI)</td>
<td align="left"><strong>网页渲染引擎</strong> (渲染 HTML&#x2F;CSS&#x2F;JS DOM)</td>
</tr>
<tr>
<td align="left"><strong>目标平台</strong></td>
<td align="left"><strong>原生移动平台 (iOS&#x2F;Android)</strong></td>
<td align="left"><strong>任何有兼容浏览器&#x2F;WebView的平台</strong></td>
</tr>
<tr>
<td align="left"><strong>最终产物</strong></td>
<td align="left">原生安装包 (.ipa&#x2F;.apk)</td>
<td align="left">网页资源 (HTML&#x2F;CSS&#x2F;JS)，通过 URL 访问</td>
</tr>
<tr>
<td align="left"><strong>渲染方式</strong></td>
<td align="left"><strong>原生UI组件</strong> (通过JS桥接驱动)</td>
<td align="left"><strong>HTML DOM &#x2F; CSSOM</strong> (由浏览器引擎渲染)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>接近原生</strong>，复杂UI&#x2F;动画更流畅</td>
<td align="left">受限于浏览器引擎，复杂场景可能较差</td>
</tr>
<tr>
<td align="left"><strong>设备访问</strong></td>
<td align="left"><strong>直接、强大</strong> (通过原生桥接模块)</td>
<td align="left"><strong>通过 Web APIs</strong>，支持度和能力有限</td>
</tr>
<tr>
<td align="left"><strong>开发技术</strong></td>
<td align="left">JS&#x2F;TS + React + 原生概念</td>
<td align="left">HTML + CSS + JS&#x2F;TS</td>
</tr>
<tr>
<td align="left"><strong>跨平台</strong></td>
<td align="left">需为iOS&#x2F;Android分别构建，代码可共享</td>
<td align="left"><strong>一次编写，随处运行</strong> (理论，需适配)</td>
</tr>
<tr>
<td align="left"><strong>安装</strong></td>
<td align="left">需要从应用商店下载安装</td>
<td align="left">通过URL访问，PWA可“安装”到桌面&#x2F;主屏</td>
</tr>
<tr>
<td align="left"><strong>更新</strong></td>
<td align="left">需通过应用商店审核更新</td>
<td align="left"><strong>即时更新</strong> (服务器端更新资源即可)</td>
</tr>
</tbody></table>
<p><strong>简单类比：</strong></p>
<ul>
<li><strong>RN容器：</strong> 像一个用JavaScript编写的“说明书”，交给当地（iOS&#x2F;Android）的“施工队”（原生桥接和组件）按照说明书，用当地最好的“建材”（原生UI组件）来建造房子（App）。结果是本地化的、高质量的房子。</li>
<li><strong>浏览器容器：</strong> 像一个预制的“活动板房”（网页）。施工队（浏览器引擎）按照统一的“国际标准”（Web标准），用自带的“标准化板材”（HTML&#x2F;CSS）在任何地方快速搭建。房子可以快速搭建和修改，但可能不如本地定制的那么坚固或贴合当地环境。</li>
</ul>
<p><strong>选择哪一个？</strong></p>
<ul>
<li>需要<strong>最佳性能、深度设备集成、原生用户体验</strong> -&gt; <strong>React Native</strong>。</li>
<li>需要<strong>最广泛的跨平台覆盖（包括Web）、最快的开发迭代速度、即时更新</strong> -&gt; <strong>浏览器容器 (Web技术&#x2F;PWA)</strong>。</li>
<li>混合方案：在原生App中嵌入<strong>WebView</strong>来展示部分内容（如帮助页面、营销活动页），结合两者优势。React Native 本身也提供了 <code>WebView</code> 组件来实现这一点。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/" data-id="cmchb34xk0000c4ur8wemfedc" data-title="前端性能[C" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E3%80%81%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E3%80%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" rel="tag">前端页面、错误监控、性能指标</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-基础开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/28/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2025-06-28T13:03:52.000Z" itemprop="datePublished">2025-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/28/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/">基础开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="Canvas和SVG"><a href="#Canvas和SVG" class="headerlink" title="Canvas和SVG"></a>Canvas和SVG</h2><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>Canvas</strong></th>
<th align="center"><strong>SVG</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型</strong></td>
<td align="left">位图（像素操作）</td>
<td align="center">矢量图（XML 描述）</td>
</tr>
<tr>
<td align="left"><strong>渲染方式</strong></td>
<td align="left">即时模式（绘制后不保留对象）</td>
<td align="center">保留模式（DOM 树存储对象）</td>
</tr>
<tr>
<td align="left"><strong>分辨率依赖</strong></td>
<td align="left">依赖分辨率（放大失真）</td>
<td align="center">独立分辨率（无限缩放不失真）</td>
</tr>
<tr>
<td align="left"><strong>事件处理</strong></td>
<td align="left">需手动计算坐标（无内置事件）</td>
<td align="center">支持 DOM 事件（如 click&#x2F;hover）</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">适合高频重绘（如游戏&#x2F;动画）</td>
<td align="center">元素过多时性能下降</td>
</tr>
<tr>
<td align="left"><strong>输出格式</strong></td>
<td align="left">生成 PNG&#x2F;JPG</td>
<td align="center">XML 文本（可被 CSS&#x2F;JS 操作）</td>
</tr>
<tr>
<td align="left"><strong>文本渲染</strong></td>
<td align="left">支持基础文本（无富文本）</td>
<td align="center">支持完整文本操作（含 CSS 样式）</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">低（无对象存储）</td>
<td align="center">高（每个元素占用 DOM 节点）</td>
</tr>
</tbody></table>
<h2 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h2><p><strong>src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</strong> </p>
<p>（1）src</p>
<p>src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src =”js.<span class="property">js</span>”&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js 脚本放在底部而不是头部。 </p>
<p>（2）href</p>
<p>href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果在文档中添加 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=”common.<span class="property">css</span>” rel=”stylesheet”/&gt;</span><br></pre></td></tr></table></figure>

<p>那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。</p>
<h2 id="常⽤的meta标签有哪些"><a href="#常⽤的meta标签有哪些" class="headerlink" title="常⽤的meta标签有哪些"></a>常⽤的meta标签有哪些</h2><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。</p>
<p>常用的meta标签：</p>
<p>（1）<code>charset</code>，用来描述HTML文档的编码类型：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>（2） <code>keywords</code>，页面关键词：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;关键词&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）<code>description</code>，页面描述：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;页面描述内容&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）<code>refresh</code>，页面重定向和刷新：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li><code>width viewport</code> ：宽度(数值&#x2F;device-width)</li>
<li><code>height viewport</code> ：高度(数值&#x2F;device-height)</li>
<li><code>initial-scale</code> ：初始缩放比例</li>
<li><code>maximum-scale</code> ：最大缩放比例</li>
<li><code>minimum-scale</code> ：最小缩放比例</li>
<li><code>user-scalable</code> ：是否允许用户缩放(yes&#x2F;no）</li>
</ul>
<p>（6）搜索引擎索引方式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li><code>all</code>：文件将被检索，且页面上的链接可以被查询；</li>
<li><code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li>
<li><code>index</code>：文件将被检索；</li>
<li><code>follow</code>：页面上的链接可以被查询；</li>
<li><code>noindex</code>：文件将不被检索；</li>
<li><code>nofollow</code>：页面上的链接不可以被查询</li>
</ul>
<h2 id="iframe-有那些优点和缺点？"><a href="#iframe-有那些优点和缺点？" class="headerlink" title="iframe 有那些优点和缺点？"></a><strong>iframe 有那些优点和缺点？</strong></h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p>
<p><strong>优点：</strong></p>
<ul>
<li>用来加载速度较慢的内容（如广告）</li>
<li>可以使脚本可以并行下载</li>
<li>可以实现跨子域通信</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>iframe 会阻塞主页面的 onload 事件</li>
<li>无法被一些搜索引擎索识别</li>
<li>会产生很多页面，不容易管理</li>
</ul>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><p><strong>1、层叠性（Cascading）</strong></p>
<p><strong>定义</strong>：当多个 CSS 规则作用于同一元素时，浏览器根据特定规则”层叠”这些样式，最终确定生效的样式。</p>
<p><strong>核心规则</strong>（按顺序判断）：</p>
<ol>
<li><p><strong>来源顺序</strong>：后出现的规则覆盖先出现的规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &#123; color: blue; &#125;</span><br><span class="line">p &#123; color: red; &#125; /* 最终生效 */</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>来源重要性</strong>（优先级从低到高）：</p>
<ul>
<li>浏览器默认样式</li>
<li>用户样式表（普通）</li>
<li>作者样式表（开发者写的普通样式）</li>
<li>作者样式表（<code>!important</code>）</li>
<li>用户样式表（<code>!important</code>）</li>
</ul>
</li>
<li><p><strong><code>!important</code> 标志</strong>：打破常规优先级</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: blue <span class="meta">!important</span>; <span class="comment">/* 最终生效 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.special</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: red; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>2、继承性（Inheritance）</strong></p>
<p><strong>定义</strong>：某些 CSS 属性会自动从父元素传递到子元素。</p>
<p><strong>核心特点</strong>：</p>
<ol>
<li><p><strong>可继承属性</strong>（约 30%）：</p>
<ul>
<li>文本相关：<code>font-family</code>, <code>color</code>, <code>line-height</code>, <code>text-align</code></li>
<li>列表相关：<code>list-style-type</code></li>
<li>可见性：<code>visibility</code></li>
<li>表格边框：<code>border-collapse</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: blue&quot;</span>&gt;</span></span><br><span class="line">  父元素文字</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>子元素继承蓝色文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 自动继承 color 属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不可继承属性</strong>（约 70%）：</p>
<ul>
<li>盒模型：<code>width</code>, <code>height</code>, <code>margin</code>, <code>padding</code>, <code>border</code></li>
<li>定位：<code>position</code>, <code>top</code>, <code>left</code></li>
<li>背景：<code>background-color</code></li>
</ul>
</li>
<li><p><strong>强制继承</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.child &#123;</span><br><span class="line">  border: inherit; /* 强制继承父元素的边框 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>3、优先级（Specificity）</strong></p>
<p><strong>定义</strong>：当多个选择器作用于同一元素时，通过权重计算确定哪个规则生效。</p>
<p><strong>权重计算规则</strong>（从高到低）：</p>
<table>
<thead>
<tr>
<th align="left">选择器类型</th>
<th align="left">示例</th>
<th align="left">权重值（a,b,c,d）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">行内样式</td>
<td align="left"><code>style=&quot;...&quot;</code></td>
<td align="left">1,0,0,0</td>
</tr>
<tr>
<td align="left">ID 选择器</td>
<td align="left"><code>#header</code></td>
<td align="left">0,1,0,0</td>
</tr>
<tr>
<td align="left">类&#x2F;伪类&#x2F;属性选择器</td>
<td align="left"><code>.btn</code>, <code>:hover</code></td>
<td align="left">0,0,1,0</td>
</tr>
<tr>
<td align="left">元素&#x2F;伪元素选择器</td>
<td align="left"><code>div</code>, <code>::before</code></td>
<td align="left">0,0,0,1</td>
</tr>
<tr>
<td align="left">通配符&#x2F;关系选择器</td>
<td align="left"><code>*</code>, <code>&gt;</code>, <code>+</code></td>
<td align="left">0,0,0,0</td>
</tr>
</tbody></table>
<p><strong>计算示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#nav .item:hover &#123;&#125;   /* 权重：0,1,2,0 (ID×1 + 类×2) */</span><br><span class="line">header#top h1.title &#123;&#125; /* 权重：0,1,1,2 (ID×1 + 类×1 + 元素×2) */</span><br></pre></td></tr></table></figure>

<p><strong>比较规则</strong>：</p>
<ol>
<li>从左到右逐级比较：<code>a</code> &gt; <code>b</code> &gt; <code>c</code> &gt; <code>d</code></li>
<li><code>!important</code> &gt; 行内样式 &gt; ID &gt; 类 &gt; 元素</li>
<li>相同权重时，后定义的生效</li>
</ol>
<h2 id="CSS选择器与优先级"><a href="#CSS选择器与优先级" class="headerlink" title="CSS选择器与优先级"></a><strong>CSS选择器与优先级</strong></h2><ul>
<li>!important声明的样式的优先级最高；</li>
<li>如果优先级相同，则最后出现的样式生效；</li>
<li>继承得到的样式的优先级最低；</li>
<li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li>
<li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li>
</ul>
<h2 id="display的属性值及其作用"><a href="#display的属性值及其作用" class="headerlink" title="display的属性值及其作用"></a>display的属性值及其作用</h2><table>
<thead>
<tr>
<th><strong>属性值</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>元素不显示，并且会从文档流中移除。</td>
</tr>
<tr>
<td>block</td>
<td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td>
</tr>
<tr>
<td>inline</td>
<td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td>
</tr>
<tr>
<td>inline-block</td>
<td>默认宽度为内容宽度，可以设置宽高，同行显示。</td>
</tr>
<tr>
<td>list-item</td>
<td>像块类型元素一样显示，并添加样式列表标记。</td>
</tr>
<tr>
<td>table</td>
<td>此元素会作为块级表格来显示。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承display属性的值。</td>
</tr>
</tbody></table>
<h3 id="display的block、inline和inline-block的区别"><a href="#display的block、inline和inline-block的区别" class="headerlink" title="display的block、inline和inline-block的区别"></a>display的block、inline和inline-block的区别</h3><p>　（1）**block：**会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p>
<p>　（2）**inline：**元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p>
<p>　（3）**inline-block：**将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>block (块级)</strong></th>
<th align="left"><strong>inline (行内)</strong></th>
<th align="center"><strong>inline-block (行内块)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>是否独占一行</strong></td>
<td align="left">✅ 独占整行</td>
<td align="left">❌ 与其他行内元素共享一行</td>
<td align="center">❌ 与其他行内元素共享一行</td>
</tr>
<tr>
<td align="left"><strong>尺寸设置</strong></td>
<td align="left">✅ 可设置宽高，默认撑开父元素宽度由</td>
<td align="left">❌ 默认宽高由内容决定</td>
<td align="center">✅ 可设置宽高，默认宽高由内容决定</td>
</tr>
<tr>
<td align="left"><strong>盒模型属性</strong></td>
<td align="left">✅ 完整 margin&#x2F;padding</td>
<td align="left">❌ 仅水平方向 margin&#x2F;padding</td>
<td align="center">✅ 完整 margin&#x2F;padding</td>
</tr>
<tr>
<td align="left"><strong>默认排列方式</strong></td>
<td align="left">垂直堆叠</td>
<td align="left">水平排列</td>
<td align="center">水平排列</td>
</tr>
<tr>
<td align="left"><strong>包含关系</strong></td>
<td align="left">可包含其他块级&#x2F;行内元素</td>
<td align="left">只能包含行内元素</td>
<td align="center">可包含其他块级&#x2F;行内元素</td>
</tr>
<tr>
<td align="left"><strong>典型默认元素</strong></td>
<td align="left"><code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;-&lt;h6&gt;</code></td>
<td align="left"><code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code></td>
<td align="center"><code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;button&gt;</code></td>
</tr>
</tbody></table>
<p><img src="/../img/23353.jpg"></p>
<p><strong>1. 空白间隙问题 (inline-block)</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Item1<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  <span class="comment">&lt;!-- 这里有换行符 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Item2<span class="tag">&lt;/<span class="name">span</span>&gt;</span>   <span class="comment">&lt;!-- 显示时产生 4px 间隙 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong>：</p>
<ul>
<li>父元素设置 <code>font-size: 0</code>（需重置子元素字体）</li>
<li>使用负 margin：<code>margin-right: -4px</code></li>
<li>删除 HTML 标签间的空白</li>
</ul>
<p><strong>2.垂直对齐控制</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inline-block</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: top; <span class="comment">/* 可选值: top/middle/bottom */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 行内元素边距陷阱</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">20px</span>; <span class="comment">/* 仅左右生效，上下无效！ */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="comment">/* 上下padding会覆盖其他行但无位移 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>作用：<strong>选中特殊状态的元素</strong> </p>
<p>如何理解“伪” ? — 虚假的，不是真的。 </p>
<p>如何理解“伪类”？</p>
<ol>
<li>— 像类( class )，但不是类，是元素的一种特殊状态。</li>
</ol>
<p>常用的伪类选择器： </p>
<p>一、动态伪类： </p>
<p>:link 超链接未被访问的状态。</p>
<p>:visited 超链接访问过的状态。 </p>
<p>:hover 鼠标悬停在元素上的状态。</p>
<p>:active 元素激活的状态。 什么是激活？—— 按下鼠标不松开。注意点：遵循 LVHA 的顺序，即： link 、 visited 、 hover 、 active 。 </p>
<p>:focus 获取焦点的元素。 </p>
<p>表单类元素才能使用 :focus 伪类。 当用户：点击元素、触摸元素、或通过键盘的 “ tab ” 键等方式，选择元素时，就是获 得焦点。 </p>
<p>二、结构伪类 </p>
<ol>
<li><p>:first-child 所有兄弟元素中的第一个。</p>
</li>
<li><p>:last-child 所有兄弟元素中的最后一个。</p>
</li>
<li><p>:nth-child(n) 所有兄弟元素中的第 n 个。 </p>
</li>
<li><p>:first-of-type 所有同类型兄弟元素中的第一个。 </p>
</li>
<li><p>:last-of-type 所有同类型兄弟元素中的最后一个。 </p>
</li>
<li><p>:nth-of-type(n) 所有同类型兄弟元素中的 第n个 。 </p>
<p>关于 n 的值： 1. 0 或 不写 ：什么都选不中 —— 几乎不用。 2. n ：选中所有子元素 —— 几乎不用。 3. 1~正无穷的整数 ：选中对应序号的子元素。 4. 2n 或 even ：选中序号为偶数的子元素。 5. 2n+1 或 odd ：选中序号为奇数的子元素。 6. -n+3 ：选中的是前 3 个。 div[title^&#x3D;”a”]{color:red;} &#x2F;* 选中title属性值以u结尾的元素 <em>&#x2F; div[title$&#x3D;”u”]{color:red;} &#x2F;</em> 选中title属性值包含g的元素 <em>&#x2F; div[title</em>&#x3D;”g”]{color:red;} 了解即可： 1. :nth-last-child(n) 所有兄弟元素中的倒数第 n 个。 2. :nth-last-of-type(n) 所有同类型兄弟元素中的 倒数第n个 。 3. :only-child 选择没有兄弟的元素（独生子女）。 4. :only-of-type 选择没有同类型兄弟的元素。 5. :root 根元素。 6. :empty 内容为空元素（空格也算内容）。 </p>
<p>三、否定伪类： :not(选择器) 排除满足括号中条件的元素。</p>
<p>四、UI伪类： </p>
<ol>
<li><p>:checked 被选中的复选框或单选按钮。 </p>
</li>
<li><p>:enable 可用的表单元素（没有 disabled 属性）。 </p>
</li>
<li><p>:disabled 不可用的表单元素（有 disabled 属性）。</p>
</li>
</ol>
<p>   五、目标伪类（了解） :target 选中锚点指向的元素。 </p>
<p>   六、语言伪类（了解） :lang() 根据指定的语言选择元素（本质是看 lang 属性的值）。</p>
</li>
</ol>
<h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><p><img src="/../img/13609.jpg"></p>
<h2 id="百分比计算规则"><a href="#百分比计算规则" class="headerlink" title="百分比计算规则"></a>百分比计算规则</h2><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">百分比计算基础</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>width</code></td>
<td align="left">父元素的内容宽度</td>
<td align="left">父元素width: 600px，子元素width: 50% → 300px</td>
</tr>
<tr>
<td align="left"><code>height</code></td>
<td align="left">父元素的内容高度</td>
<td align="left">父元素height: 400px，子元素height: 50% → 200px</td>
</tr>
<tr>
<td align="left"><code>padding</code></td>
<td align="left">父元素的内容宽度</td>
<td align="left">父元素width: 800px，padding: 10% → 80px</td>
</tr>
<tr>
<td align="left"><code>margin</code></td>
<td align="left">父元素的内容宽度</td>
<td align="left">父元素width: 1000px，margin: 5% → 50px</td>
</tr>
<tr>
<td align="left"><code>top/bottom</code></td>
<td align="left">包含块的高度</td>
<td align="left">包含块height: 500px，top: 20% → 100px</td>
</tr>
<tr>
<td align="left"><code>left/right</code></td>
<td align="left">包含块的宽度</td>
<td align="left">包含块width: 1200px，left: 15% → 180px</td>
</tr>
<tr>
<td align="left"><code>font-size</code></td>
<td align="left">父元素的字体大小</td>
<td align="left">父元素font-size: 16px，子元素font-size: 150% → 24px</td>
</tr>
<tr>
<td align="left"><code>line-height</code></td>
<td align="left">元素自身的字体大小</td>
<td align="left">元素font-size: 20px，line-height: 150% → 30px</td>
</tr>
<tr>
<td align="left"><code>background-position</code></td>
<td align="left">(容器尺寸 - 背景图尺寸)</td>
<td align="left">容器宽度1000px，图片宽度800px，background-position: 50% → 100px</td>
</tr>
<tr>
<td align="left"><code>transform: translate()</code></td>
<td align="left">元素自身的尺寸</td>
<td align="left">元素width: 200px，translateX(50%) → 100px</td>
</tr>
<tr>
<td align="left"><code>border-radius</code></td>
<td align="left">元素自身的尺寸</td>
<td align="left">元素200px×100px，border-radius: 50% → 100px&#x2F;50</td>
</tr>
</tbody></table>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>margin（外边距）： 盒子与外界的距离。 </p>
<ul>
<li>子元素的 margin ，是参考父元素的 content 计算的。（因为是父亲的 content 中承装着 子元素） </li>
<li>上 margin 、左 margin ：影响自己的位置；下 margin 、右 margin ：影响后面兄弟元素 的位置。 </li>
<li>块级元素、行内块元素，均可以完美地设置四个方向的 margin ；但行内元素，左右 margin 可以完美设置，上下 margin 设置无效。 </li>
<li>margin 的值也可以是 auto ，如果给一个块级元素设置左右 margin 都为 auto ，该块级 元素会在父元素中水平居中。 </li>
<li><strong>margin 的值可以是负值。</strong></li>
</ul>
<p><img src="/../img/14468.jpg"></p>
<p>border（边框）： 盒子的边框。 </p>
<p>padding（内边距）： 紧贴内容的补白区域。 </p>
<ul>
<li><strong>padding 的值不能为负数</strong> </li>
<li>行内元素 的 左右内边距是没问题的，上下内边距不能完美的设置。 </li>
<li>块级元素、行内块元素，四个方向内边距都可以完美设置<br><strong>百分比计算来源为父元素宽度</strong></li>
</ul>
<p>content（内容）：元素中的文本或后代元素都是它的内容。</p>
<p><img src="C:\Users\Zhangwenye\Desktop\博客\source\img\4611.jpg"></p>
<h2 id="文本溢出"><a href="#文本溢出" class="headerlink" title="文本溢出"></a>文本溢出</h2><ul>
<li>单行文本溢出</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行</span><br></pre></td></tr></table></figure>

<ul>
<li>多行文本溢出</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-<span class="attribute">box-orient</span>:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-<span class="selector-tag">line</span>-clamp:<span class="number">3</span>;        // 显示的行数</span><br></pre></td></tr></table></figure>

<p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器</p>
<h2 id="CSS中可继承与不可继承属性"><a href="#CSS中可继承与不可继承属性" class="headerlink" title="CSS中可继承与不可继承属性"></a>CSS中可继承与不可继承属性</h2><p><strong>一、无继承性的属性</strong></p>
<ol>
<li><strong>display</strong>：规定元素应该生成的框的类型</li>
<li><strong>文本属性</strong>：</li>
</ol>
<ul>
<li>vertical-align：垂直文本对齐</li>
<li>text-decoration：规定添加到文本的装饰</li>
<li>text-shadow：文本阴影效果</li>
<li>white-space：空白符的处理</li>
<li>unicode-bidi：设置文本的方向</li>
</ul>
<ol>
<li><strong>盒子模型的属性</strong>：width、height、margin、border、padding</li>
<li><strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li>
<li><strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li>
<li><strong>生成内容属性</strong>：content、counter-reset、counter-increment</li>
<li><strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li>
<li><strong>页面样式属性</strong>：size、page-break-before、page-break-after</li>
<li><strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li>
</ol>
<p><strong>二、有继承性的属性</strong></p>
<ol>
<li><strong>字体系列属性</strong></li>
</ol>
<ul>
<li>font-family：字体系列</li>
<li>font-weight：字体的粗细</li>
<li>font-size：字体的大小</li>
<li>font-style：字体的风格</li>
</ul>
<ol>
<li><strong>文本系列属性</strong></li>
</ol>
<ul>
<li>text-indent：文本缩进</li>
<li>text-align：文本水平对齐</li>
<li>line-height：行高</li>
<li>word-spacing：单词之间的间距</li>
<li>letter-spacing：中文或者字母之间的间距</li>
<li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li>
<li>color：文本颜色</li>
</ul>
<ol>
<li><strong>元素可见性</strong></li>
</ol>
<ul>
<li>visibility：控制元素显示隐藏</li>
</ul>
<ol>
<li><strong>列表布局属性</strong></li>
</ol>
<ul>
<li>list-style：列表风格，包括list-style-type、list-style-image等</li>
</ul>
<ol>
<li><strong>光标属性</strong></li>
</ol>
<ul>
<li>cursor：光标显示为何种形态</li>
</ul>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><ul>
<li>脱离文档流</li>
<li>不管浮动前是什么元素，浮动后：默认宽与高都是被内容撑开（尽可能小），而且可以设置宽高</li>
<li>不会独占一行，可以与其他元素共用一行 </li>
<li>不会 margin 合并，也不会 margin 塌陷，能够完美的设置四个方向的 margin 和 padding </li>
<li>不会像行内块一样被当做文本处理（没有行内块的空白问题）</li>
</ul>
<p><strong>元素浮动后会有哪些影响</strong><br>对兄弟元素的影响： 后面的兄弟元素，会占据浮动元素之前的位置，在浮动元素的下面；对前面的兄弟无影响。 </p>
<p>对父元素的影响： 不能撑起父元素的高度，导致父元素高度塌陷；但父元素的宽度依然束缚浮动的元素。 </p>
<p><strong>解决浮动产生的影响（清除浮动）</strong><br>解决方案： </p>
<ul>
<li>方案一： 给父元素指定高度 </li>
<li>方案二： 给父元素也设置浮动，带来其他影响</li>
<li>方案三： 给父元素设置 overflow:hidden </li>
<li>方案四： 在所有浮动元素的最后面，添加一个块级元素，并给该块级元素设置 clear:both </li>
<li>方案五： 给浮动元素的父元素，设置伪元素，通过伪元素清除浮动，原理与方案四相同。&#x3D;&#x3D;&#x3D;&gt; 推 荐使用 布局中的一个原则：设置浮动的时候，兄弟元素要么全都浮动，要么全都不浮动</li>
</ul>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><table>
<thead>
<tr>
<th align="left">定位类型</th>
<th align="left">定位基准</th>
<th align="left">是否脱离文档流</th>
<th align="left">特点</th>
<th align="left">常见应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>static</strong></td>
<td align="left">正常文档流</td>
<td align="left">否</td>
<td align="left">默认定位，不受 top&#x2F;right&#x2F;bottom&#x2F;left 影响</td>
<td align="left">普通文档流布局</td>
</tr>
<tr>
<td align="left"><strong>relative</strong></td>
<td align="left">自身原始位置</td>
<td align="left">否</td>
<td align="left">保留原始空间，相对自身偏移</td>
<td align="left">微调元素位置，作为 absolute 的参照</td>
</tr>
<tr>
<td align="left"><strong>absolute</strong></td>
<td align="left">最近的定位祖先元素</td>
<td align="left">是</td>
<td align="left">完全脱离文档流，不保留空间</td>
<td align="left">弹出层、下拉菜单、图标定位</td>
</tr>
<tr>
<td align="left"><strong>fixed</strong></td>
<td align="left">浏览器视口</td>
<td align="left">是</td>
<td align="left">固定于视口位置，不随滚动移动</td>
<td align="left">固定导航栏、悬浮按钮</td>
</tr>
<tr>
<td align="left"><strong>sticky</strong></td>
<td align="left">最近的滚动祖先</td>
<td align="left">否（直到达到阈值）</td>
<td align="left">混合定位，达到阈值后固定</td>
<td align="left">粘性导航、表头固定</td>
</tr>
</tbody></table>
<h3 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h3><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：</p>
<p><img src="/../img/132257ri1tw184gtv3vu8t.png" alt="img"></p>
<p>对于上图，由上到下分别是：</p>
<p>（1）背景和边框：建立当前层叠上下文元素的背景和边框。</p>
<p>（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。</p>
<p>（3）块级盒：文档流内非行内级非定位后代元素。</p>
<p>（4）浮动盒：非定位浮动元素。</p>
<p>（5）行内盒：文档流内行内级非定位后代元素。</p>
<p>（6）z-index:0：层叠级数为0的定位元素。</p>
<p>（7）正z-index：z-index属性值为正的定位元素。</p>
<p>使用clear:both吧。</p>
<p>一般使用伪元素的方式清除浮动：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block; </span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p>
<h2 id="对BFC的理解，如何创建BFC"><a href="#对BFC的理解，如何创建BFC" class="headerlink" title="对BFC的理解，如何创建BFC"></a>对BFC的理解，如何创建BFC</h2><p>先来看两个相关的概念：</p>
<ul>
<li>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。 </li>
<li>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li>
</ul>
<p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>
<p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p>
<p><strong>创建BFC的条件：</strong></p>
<ul>
<li>根元素：body；</li>
<li>元素设置浮动：float 除 none 以外的值；</li>
<li>元素设置绝对定位：position (absolute、fixed)；</li>
<li>display 值为：inline-block、table-cell、table-caption、flex等；</li>
<li>overflow 值为：hidden、auto、scroll；</li>
</ul>
<p><strong>BFC的特点：</strong></p>
<ul>
<li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li>
<li>在BFC中上下相邻的两个容器的margin会重叠</li>
<li>计算BFC的高度时，需要计算浮动元素的高度</li>
<li>BFC区域不会与浮动的容器发生重叠</li>
<li>BFC是独立的容器，容器内部元素不会影响外部元素</li>
<li>每个元素的左margin值和容器的左border相接触</li>
</ul>
<p><strong>BFC的作用：</strong></p>
<ul>
<li><strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li>
<li><strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li>
<li><strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">left</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">right</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p>
<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><ol>
<li><strong>GPU 加速</strong>：<ul>
<li>Transform 操作由 GPU 处理，不占用主线程资源</li>
<li>特别适合动画和复杂视觉效果</li>
<li>使用 <code>translate3d()</code> 或 <code>will-change</code> 可以强制启用 GPU 加速</li>
</ul>
</li>
<li><strong>不触发重排（Reflow）</strong>：<ul>
<li>应用 transform 时，浏览器跳过布局（Layout）阶段</li>
<li>元素在文档流中的位置保持不变</li>
<li>只影响元素的视觉效果，不影响布局</li>
</ul>
</li>
<li><strong>高性能动画</strong>：<ul>
<li>与 CSS transitions&#x2F;animations 结合性能极佳</li>
<li>60fps 流畅动画的理想选择</li>
<li>特别适合移动端性能优化</li>
</ul>
</li>
</ol>
<h3 id="与其他位移属性的性能对比"><a href="#与其他位移属性的性能对比" class="headerlink" title="与其他位移属性的性能对比"></a>与其他位移属性的性能对比</h3><table>
<thead>
<tr>
<th align="left">属性类型</th>
<th align="left">触发重排</th>
<th align="left">触发重绘</th>
<th align="left">性能影响</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Transform</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">最小</td>
<td align="left">动画、交互效果、视觉变换</td>
</tr>
<tr>
<td align="left"><strong>Position</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">中等</td>
<td align="left">静态定位、布局元素</td>
</tr>
<tr>
<td align="left"><strong>Margin</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">最大</td>
<td align="left">元素间距调整</td>
</tr>
<tr>
<td align="left"><strong>Padding</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">大</td>
<td align="left">内容内边距</td>
</tr>
<tr>
<td align="left"><strong>Left&#x2F;Top</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">中等</td>
<td align="left">绝对定位元素移动</td>
</tr>
</tbody></table>
<h3 id="浏览器渲染流程与性能"><a href="#浏览器渲染流程与性能" class="headerlink" title="浏览器渲染流程与性能"></a>浏览器渲染流程与性能</h3><ol>
<li><strong>渲染流水线</strong>：<ul>
<li>JavaScript → 样式计算 → 布局 → 绘制 → 合成</li>
<li>Transform 操作只在合成阶段处理</li>
<li>其他位移属性会触发布局和绘制阶段</li>
</ul>
</li>
<li><strong>优化建议</strong>：<ul>
<li>使用 <code>transform</code> 和 <code>opacity</code> 制作动画</li>
<li>避免在循环中修改布局属性</li>
<li>使用 <code>will-change</code> 提示浏览器优化</li>
<li>优先使用 CSS 动画而非 JavaScript 动画</li>
</ul>
</li>
</ol>
<h3 id="实际性能差异"><a href="#实际性能差异" class="headerlink" title="实际性能差异"></a>实际性能差异</h3><p>在动画演示中，可以看到：</p>
<ul>
<li><strong>Transform</strong>：性能最优，CPU 使用率最低</li>
<li><strong>Position</strong>：性能中等，会触发重排</li>
<li><strong>Margin</strong>：性能最差，导致完整文档重排</li>
</ul>
<h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><p>Flex 布局（弹性盒子布局）是 CSS3 中一种强大的<strong>一维布局模型</strong>，专门设计用于在<strong>单行或单列</strong>中高效分配容器空间。它解决了传统布局（如浮动和定位）的诸多痛点，特别适合构建<strong>响应式界面</strong>和<strong>复杂组件</strong>。</p>
<ul>
<li><strong>Flex 容器</strong>：应用 <code>display: flex</code> 的元素</li>
<li><strong>Flex 项目</strong>：容器内的直接子元素</li>
<li><strong>主轴 (Main Axis)</strong>：项目排列的主要方向（由 <code>flex-direction</code> 定义）</li>
<li><strong>交叉轴 (Cross Axis)</strong>：与主轴垂直的方向</li>
</ul>
<p><strong>二、Flex 容器属性详解</strong></p>
<ol>
<li><code>display</code> - 定义容器类型</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex; <span class="comment">/* 块级 flex 容器 */</span></span><br><span class="line">  <span class="attribute">display</span>: inline-flex; <span class="comment">/* 行内 flex 容器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>flex-direction</code> - 主轴方向</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row; <span class="comment">/* 默认值，水平从左到右 */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>: row-reverse; <span class="comment">/* 水平从右到左 */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>: column; <span class="comment">/* 垂直从上到下 */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>: column-reverse; <span class="comment">/* 垂直从下到上 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>flex-wrap</code> - 换行控制</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  flex-wrap: nowrap; /* 默认不换行 */</span><br><span class="line">  flex-wrap: wrap; /* 正常换行 */</span><br><span class="line">  flex-wrap: wrap-reverse; /* 反向换行 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>flex-flow</code> - 方向与换行的简写</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap; <span class="comment">/* 方向 + 换行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>justify-content</code> - 主轴对齐</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start; <span class="comment">/* 默认，起点对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: flex-end; <span class="comment">/* 终点对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 居中对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-between; <span class="comment">/* 两端对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-around; <span class="comment">/* 均匀分布 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-evenly; <span class="comment">/* 完全均匀 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>align-items</code> - 交叉轴对齐（单行）</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: stretch; <span class="comment">/* 默认，拉伸填满 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: flex-start; <span class="comment">/* 起点对齐 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: flex-end; <span class="comment">/* 终点对齐 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/* 居中对齐 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: baseline; <span class="comment">/* 基线对齐 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><code>align-content</code> - 交叉轴对齐（多行）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  align-content: stretch; /* 默认，拉伸填满 */</span><br><span class="line">  align-content: flex-start; /* 起点对齐 */</span><br><span class="line">  align-content: flex-end; /* 终点对齐 */</span><br><span class="line">  align-content: center; /* 居中对齐 */</span><br><span class="line">  align-content: space-between; /* 两端对齐 */</span><br><span class="line">  align-content: space-around; /* 均匀分布 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>三、Flex 项目属性详解</strong></p>
<ol>
<li><code>order</code> - 项目顺序</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">0</span>; <span class="comment">/* 默认值 */</span></span><br><span class="line">  <span class="attribute">order</span>: <span class="number">1</span>; <span class="comment">/* 值越大越靠后 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>flex-grow</code> - 扩展比例</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">0</span>; <span class="comment">/* 默认不扩展 */</span></span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>; <span class="comment">/* 按比例分配剩余空间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>flex-shrink</code> - 收缩比例</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>; <span class="comment">/* 默认可收缩 */</span></span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0</span>; <span class="comment">/* 禁止收缩 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>flex-basis</code> - 初始尺寸</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: auto; <span class="comment">/* 默认，基于内容 */</span></span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">200px</span>; <span class="comment">/* 固定尺寸 */</span></span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">30%</span>; <span class="comment">/* 百分比尺寸 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>flex</code> - 复合属性</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none; <span class="comment">/* 0 0 auto */</span></span><br><span class="line">  <span class="attribute">flex</span>: auto; <span class="comment">/* 1 1 auto */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 1 1 0% */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>; <span class="comment">/* 不扩展不收缩，固定200px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>align-self</code> - 单独对齐</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto; <span class="comment">/* 继承容器 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: stretch; <span class="comment">/* 拉伸填满 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: flex-start; <span class="comment">/* 顶部对齐 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: flex-end; <span class="comment">/* 底部对齐 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: center; <span class="comment">/* 垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="requestAnimationframe"><a href="#requestAnimationframe" class="headerlink" title="requestAnimationframe"></a>requestAnimationframe</h2><p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是<strong>请求动画帧</strong>。</p>
<p>MDN对该方法的描述：</p>
<p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p>
<p><strong>语法：</strong> <code>window.requestAnimationFrame(callback);</code>  其中，callback是<strong>下一次重绘之前更新动画帧所调用的函数</strong>(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于<strong>宏任务</strong>，所以会在执行完微任务之后再去执行。</p>
<p>**取消动画：**使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p>
<p><strong>优势：</strong></p>
<ul>
<li><strong>CPU节能</strong>：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li>
<li><strong>函数节流</strong>：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li>
<li><strong>减少DOM操作</strong>：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li>
</ul>
<p><strong>setTimeout执行动画的缺点</strong>：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p>
<ul>
<li>settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；</li>
<li>settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li>
</ul>
<h2 id="CSS图片格式对比，应用场景"><a href="#CSS图片格式对比，应用场景" class="headerlink" title="CSS图片格式对比，应用场景"></a>CSS图片格式对比，应用场景</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JPEG&#x2F;JPG</th>
<th align="left">PNG</th>
<th align="left">GIF</th>
<th align="left">WebP</th>
<th align="left">SVG</th>
<th align="left">AVIF</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>压缩类型</strong></td>
<td align="left">有损</td>
<td align="left">无损</td>
<td align="left">无损</td>
<td align="left">有损&#x2F;无损</td>
<td align="left">无损</td>
<td align="left">有损&#x2F;无损</td>
</tr>
<tr>
<td align="left"><strong>透明度支持</strong></td>
<td align="left">❌</td>
<td align="left">✅ (8&#x2F;24位)</td>
<td align="left">✅ (1位)</td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">✅</td>
</tr>
<tr>
<td align="left"><strong>动画支持</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">✅ (SMIL)</td>
<td align="left">❌</td>
</tr>
<tr>
<td align="left"><strong>颜色深度</strong></td>
<td align="left">24位</td>
<td align="left">8&#x2F;24&#x2F;48位</td>
<td align="left">8位(256色)</td>
<td align="left">24&#x2F;32位</td>
<td align="left">无限</td>
<td align="left">10&#x2F;12位</td>
</tr>
<tr>
<td align="left"><strong>文件大小</strong></td>
<td align="left">小</td>
<td align="left">中-大</td>
<td align="left">小(简单)</td>
<td align="left">很小</td>
<td align="left">极小(简单)</td>
<td align="left">非常小</td>
</tr>
<tr>
<td align="left"><strong>浏览器兼容性</strong></td>
<td align="left">100%</td>
<td align="left">100%</td>
<td align="left">100%</td>
<td align="left">95%+</td>
<td align="left">100%</td>
<td align="left">75%+</td>
</tr>
<tr>
<td align="left"><strong>最佳适用场景</strong></td>
<td align="left">照片</td>
<td align="left">透明图像</td>
<td align="left">简单动画</td>
<td align="left">通用</td>
<td align="left">图标&#x2F;矢量</td>
<td align="left">高清照片</td>
</tr>
</tbody></table>
<p>图片有损压缩与无损压缩的区别详解</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">有损压缩</th>
<th align="left">无损压缩</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>原理</strong></td>
<td align="left">删除人眼不易察觉的冗余数据</td>
<td align="left">通过算法重组数据，不丢失信息</td>
</tr>
<tr>
<td align="left"><strong>图像质量</strong></td>
<td align="left">质量下降，产生压缩伪影</td>
<td align="left">保持原始质量</td>
</tr>
<tr>
<td align="left"><strong>文件大小</strong></td>
<td align="left">压缩率高(可达90%)</td>
<td align="left">压缩率低(通常20-50%)</td>
</tr>
<tr>
<td align="left"><strong>数据恢复</strong></td>
<td align="left">不可恢复原始数据</td>
<td align="left">可完全恢复原始数据</td>
</tr>
<tr>
<td align="left"><strong>常用格式</strong></td>
<td align="left">JPEG, WebP, HEIC</td>
<td align="left">PNG, GIF, BMP, TIFF</td>
</tr>
<tr>
<td align="left"><strong>典型应用</strong></td>
<td align="left">网页图片、社交媒体、数码照片</td>
<td align="left">专业摄影、医学影像、设计素材</td>
</tr>
</tbody></table>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成： </p>
<ul>
<li>第一个字符必须是一个字母、下划线（_）或美元符号（$）； </li>
<li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li>
</ul>
<h2 id="let、const、var的区别"><a href="#let、const、var的区别" class="headerlink" title="let、const、var的区别"></a>let、const、var的区别</h2><p>**（1）块级作用域:**块作用域由 <code>&#123; &#125;</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p>
<ul>
<li>内层变量可能覆盖外层变量</li>
<li>用来计数的循环变量泄露为全局变量</li>
</ul>
<p>**（2）变量提升：**var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p>
<p>**（3）给全局添加属性：**浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p>
<p>**（4）重复声明：**var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p>
<p><strong>（5）暂时性死区：<strong>在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为</strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。</p>
<p>**（6）初始值设置：**在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p>
<p>**（7）指针指向：**let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p>
<table>
<thead>
<tr>
<th><strong>区别</strong></th>
<th><strong>var</strong></th>
<th><strong>let</strong></th>
<th><strong>const</strong></th>
</tr>
</thead>
<tbody><tr>
<td>是否有块级作用域</td>
<td>×</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>是否存在变量提升</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>是否添加全局属性</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>能否重复声明变量</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>是否存在暂时性死区</td>
<td>×</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>是否必须设置初始值</td>
<td>×</td>
<td>×</td>
<td>✔️</td>
</tr>
<tr>
<td>能否改变指针指向</td>
<td>✔️</td>
<td>✔️</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="const对象的属性可以修改吗"><a href="#const对象的属性可以修改吗" class="headerlink" title="const对象的属性可以修改吗"></a>const对象的属性可以修改吗</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p>
<p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Undefined、Null、Boolean、Number、 String 、 Symbol</p>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><strong>typeof 工作机制</strong></p>
<p>JavaScript 使用<strong>类型标签</strong>机制在底层表示值类型：</p>
<ul>
<li><p>值在内存中被表示为 32 位单元</p>
</li>
<li><p>低 1-3 位存储类型标签：</p>
<ul>
<li><p><code>000</code>: 对象</p>
</li>
<li><p><code>001</code>: 整数</p>
</li>
<li><p><code>010</code>: 浮点数</p>
</li>
<li><p><code>100</code>: 字符串</p>
</li>
<li><p><code>110</code>: 布尔值</p>
</li>
<li><p><code>111</code>: 符号</p>
</li>
<li><p><code>-2^30</code>: 特殊值（undefined）、</p>
<p><code>null</code> 值被表示为机器码 <code>0x00000000</code>（全零）<br><code>typeof</code> 检查类型标签时看到 <code>000</code>，判定为对象</p>
</li>
</ul>
</li>
</ul>
<h3 id="typeof-返回值表"><a href="#typeof-返回值表" class="headerlink" title="typeof 返回值表"></a>typeof 返回值表</h3><table>
<thead>
<tr>
<th align="left">值类型</th>
<th align="left">typeof 返回值</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Undefined</td>
<td align="left">“undefined”</td>
<td align="left"><code>typeof undefined</code></td>
</tr>
<tr>
<td align="left">Null</td>
<td align="left">“object”</td>
<td align="left"><code>typeof null</code></td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">“boolean”</td>
<td align="left"><code>typeof true</code></td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">“number”</td>
<td align="left"><code>typeof 42</code></td>
</tr>
<tr>
<td align="left">BigInt</td>
<td align="left">“bigint”</td>
<td align="left"><code>typeof 10n</code></td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">“string”</td>
<td align="left"><code>typeof &quot;hello&quot;</code></td>
</tr>
<tr>
<td align="left">Symbol</td>
<td align="left">“symbol”</td>
<td align="left"><code>typeof Symbol()</code></td>
</tr>
<tr>
<td align="left">Function</td>
<td align="left">“function”</td>
<td align="left"><code>typeof function()&#123;&#125;</code></td>
</tr>
<tr>
<td align="left">其他对象</td>
<td align="left">“object”</td>
<td align="left"><code>typeof &#123;&#125;</code></td>
</tr>
</tbody></table>
<h3 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h3><p>null &#x3D;&#x3D; undefined true</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">null</th>
<th align="left">undefined</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>含义</strong></td>
<td align="left">表示<strong>空对象指针</strong></td>
<td align="left">表示<strong>未定义的值</strong></td>
</tr>
<tr>
<td align="left"><strong>类型</strong></td>
<td align="left"><code>object</code> (历史遗留问题)</td>
<td align="left"><code>undefined</code></td>
</tr>
<tr>
<td align="left"><strong>产生场景</strong></td>
<td align="left">开发者显式赋值</td>
<td align="left">JavaScript 引擎自动分配</td>
</tr>
<tr>
<td align="left"><strong>数值转换</strong></td>
<td align="left"><code>Number(null) = 0</code></td>
<td align="left"><code>Number(undefined) = NaN</code></td>
</tr>
<tr>
<td align="left"><strong>典型场景</strong></td>
<td align="left">对象初始化、清除对象引用</td>
<td align="left">变量未初始化、函数无返回值</td>
</tr>
</tbody></table>
<h3 id="转化规则"><a href="#转化规则" class="headerlink" title="转化规则"></a>转化规则</h3><h4 id="转换为-Boolean-类型规则"><a href="#转换为-Boolean-类型规则" class="headerlink" title="转换为 Boolean 类型规则"></a>转换为 Boolean 类型规则</h4><table>
<thead>
<tr>
<th align="left">值类型</th>
<th align="left">转换结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>undefined</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(undefined)</code></td>
</tr>
<tr>
<td align="left"><code>null</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(null)</code></td>
</tr>
<tr>
<td align="left"><code>false</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(false)</code></td>
</tr>
<tr>
<td align="left"><code>0</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(0)</code></td>
</tr>
<tr>
<td align="left"><code>NaN</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(NaN)</code></td>
</tr>
<tr>
<td align="left"><code>&quot;&quot;</code> (空字符串)</td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(&quot;&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>其他所有值</strong></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean(1)</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean(&quot; &quot;)</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean([])</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean(&#123;&#125;)</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean(&quot;false&quot;)</code></td>
</tr>
</tbody></table>
<h4 id="转换为-Number-类型规则"><a href="#转换为-Number-类型规则" class="headerlink" title="转换为 Number 类型规则"></a>转换为 Number 类型规则</h4><table>
<thead>
<tr>
<th align="left">值类型</th>
<th align="left">转换结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>undefined</code></td>
<td align="left"><code>NaN</code></td>
<td align="left"><code>Number(undefined)</code></td>
</tr>
<tr>
<td align="left"><code>null</code></td>
<td align="left"><code>0</code></td>
<td align="left"><code>Number(null)</code></td>
</tr>
<tr>
<td align="left"><code>true</code></td>
<td align="left"><code>1</code></td>
<td align="left"><code>Number(true)</code></td>
</tr>
<tr>
<td align="left"><code>false</code></td>
<td align="left"><code>0</code></td>
<td align="left"><code>Number(false)</code></td>
</tr>
<tr>
<td align="left"><code>&quot;&quot;</code> (空字符串)</td>
<td align="left"><code>0</code></td>
<td align="left"><code>Number(&quot;&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>&quot; &quot;</code> (空白字符串)</td>
<td align="left"><code>0</code></td>
<td align="left"><code>Number(&quot; &quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>数字字符串</strong></td>
<td align="left">对应数字</td>
<td align="left"><code>Number(&quot;123&quot;) → 123</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>Number(&quot;12.3&quot;) → 12.3</code></td>
</tr>
<tr>
<td align="left"><strong>非数字字符串</strong></td>
<td align="left"><code>NaN</code></td>
<td align="left"><code>Number(&quot;123abc&quot;)</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>NaN</code></td>
<td align="left"><code>Number(&quot;abc&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>数组</strong></td>
<td align="left">特殊规则</td>
<td align="left"><code>Number([]) → 0</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>Number([1]) → 1</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>Number([1,2]) → NaN</code></td>
</tr>
<tr>
<td align="left"><strong>对象</strong></td>
<td align="left"><code>NaN</code></td>
<td align="left"><code>Number(&#123;&#125;)</code></td>
</tr>
</tbody></table>
<h4 id="转换为-String-类型规则"><a href="#转换为-String-类型规则" class="headerlink" title="转换为 String 类型规则"></a>转换为 String 类型规则</h4><table>
<thead>
<tr>
<th align="left">值类型</th>
<th align="left">转换结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>undefined</code></td>
<td align="left"><code>&quot;undefined&quot;</code></td>
<td align="left"><code>String(undefined)</code></td>
</tr>
<tr>
<td align="left"><code>null</code></td>
<td align="left"><code>&quot;null&quot;</code></td>
<td align="left"><code>String(null)</code></td>
</tr>
<tr>
<td align="left"><code>true</code></td>
<td align="left"><code>&quot;true&quot;</code></td>
<td align="left"><code>String(true)</code></td>
</tr>
<tr>
<td align="left"><code>false</code></td>
<td align="left"><code>&quot;false&quot;</code></td>
<td align="left"><code>String(false)</code></td>
</tr>
<tr>
<td align="left"><code>0</code></td>
<td align="left"><code>&quot;0&quot;</code></td>
<td align="left"><code>String(0)</code></td>
</tr>
<tr>
<td align="left"><code>NaN</code></td>
<td align="left"><code>&quot;NaN&quot;</code></td>
<td align="left"><code>String(NaN)</code></td>
</tr>
<tr>
<td align="left"><code>Infinity</code></td>
<td align="left"><code>&quot;Infinity&quot;</code></td>
<td align="left"><code>String(Infinity)</code></td>
</tr>
<tr>
<td align="left"><code>-0</code></td>
<td align="left"><code>&quot;0&quot;</code></td>
<td align="left"><code>String(-0)</code></td>
</tr>
<tr>
<td align="left"><strong>数字</strong></td>
<td align="left">数字字符串</td>
<td align="left"><code>String(123) → &quot;123&quot;</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>String(12.3) → &quot;12.3&quot;</code></td>
</tr>
<tr>
<td align="left"><strong>字符串</strong></td>
<td align="left">原字符串</td>
<td align="left"><code>String(&quot;hello&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>数组</strong></td>
<td align="left">元素拼接字符串</td>
<td align="left"><code>String([]) → &quot;&quot;</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>String([1]) → &quot;1&quot;</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>String([1,2]) → &quot;1,2&quot;</code></td>
</tr>
<tr>
<td align="left"><strong>对象</strong></td>
<td align="left"><code>&quot;[object Object]&quot;</code></td>
<td align="left"><code>String(&#123;&#125;)</code></td>
</tr>
</tbody></table>
<h4 id="特殊转换场景规则"><a href="#特殊转换场景规则" class="headerlink" title="特殊转换场景规则"></a>特殊转换场景规则</h4><p><strong>1. 加法运算 (+) 类型转换</strong></p>
<table>
<thead>
<tr>
<th align="left">操作数1类型</th>
<th align="left">操作数2类型</th>
<th align="left">转换规则</th>
<th align="left">示例</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">String</td>
<td align="left">任意类型</td>
<td align="left">都转字符串</td>
<td align="left"><code>&quot;1&quot; + 1</code></td>
<td align="left"><code>&quot;11&quot;</code></td>
</tr>
<tr>
<td align="left">任意类型</td>
<td align="left">String</td>
<td align="left">都转字符串</td>
<td align="left"><code>1 + &quot;1&quot;</code></td>
<td align="left"><code>&quot;11&quot;</code></td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">Number</td>
<td align="left">数值相加</td>
<td align="left"><code>1 + 1</code></td>
<td align="left"><code>2</code></td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">Number</td>
<td align="left">布尔转数字再相加</td>
<td align="left"><code>true + 1</code></td>
<td align="left"><code>2</code></td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">Number</td>
<td align="left">null转0再相加</td>
<td align="left"><code>null + 1</code></td>
<td align="left"><code>1</code></td>
</tr>
<tr>
<td align="left">undefined</td>
<td align="left">Number</td>
<td align="left">返回 NaN</td>
<td align="left"><code>undefined + 1</code></td>
<td align="left"><code>NaN</code></td>
</tr>
</tbody></table>
<p><strong>2. 相等比较 (&#x3D;&#x3D;) 类型转换</strong></p>
<table>
<thead>
<tr>
<th align="left">比较类型</th>
<th align="left">转换规则</th>
<th align="left">示例</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">null &#x3D;&#x3D; undefined</td>
<td align="left">总是相等</td>
<td align="left"><code>null == undefined</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">数字 &#x3D;&#x3D; 字符串</td>
<td align="left">字符串转数字</td>
<td align="left"><code>1 == &quot;1&quot;</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">布尔 &#x3D;&#x3D; 非布尔</td>
<td align="left">布尔转数字再比较</td>
<td align="left"><code>true == 1</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">对象 &#x3D;&#x3D; 原始值</td>
<td align="left">对象转原始值再比较</td>
<td align="left"><code>[1] == 1</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">相同类型</td>
<td align="left">直接比较</td>
<td align="left"><code>&quot;1&quot; == &quot;1&quot;</code></td>
<td align="left"><code>true</code></td>
</tr>
</tbody></table>
<h3 id="for…of-与-for…in-对比"><a href="#for…of-与-for…in-对比" class="headerlink" title="for…of 与 for…in 对比"></a>for…of 与 for…in 对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">for…of</th>
<th align="left">for…in</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>迭代对象</strong></td>
<td align="left">可迭代对象的值</td>
<td align="left">对象的可枚举属性名</td>
</tr>
<tr>
<td align="left"><strong>返回值</strong></td>
<td align="left">元素值</td>
<td align="left">属性键名</td>
</tr>
<tr>
<td align="left"><strong>适用数据类型</strong></td>
<td align="left">Array, Map, Set, String, TypedArray, NodeList</td>
<td align="left">普通对象, 数组(不推荐)</td>
</tr>
<tr>
<td align="left"><strong>原型链属性</strong></td>
<td align="left">不遍历</td>
<td align="left">会遍历(除非使用 hasOwnProperty)</td>
</tr>
<tr>
<td align="left"><strong>迭代顺序</strong></td>
<td align="left">按元素插入顺序(有序集合)</td>
<td align="left">无保证顺序(依赖于JS引擎实现)</td>
</tr>
<tr>
<td align="left"><strong>Symbol属性</strong></td>
<td align="left">支持迭代 Symbol.iterator</td>
<td align="left">默认不迭代 Symbol 属性</td>
</tr>
<tr>
<td align="left"><strong>空元素处理</strong></td>
<td align="left">跳过数组空位(sparse arrays)</td>
<td align="left">会处理空位(返回 undefined)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">较高</td>
<td align="left">较低</td>
</tr>
</tbody></table>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="数组检测"><a href="#数组检测" class="headerlink" title="数组检测"></a>数组检测</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Object.prototype.toString.call()做判断</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>,-<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过原型链做判断</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过ES6的Array.isArray()做判断</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArrray</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过instanceof做判断</span></span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Array.prototype.isPrototypeOf</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(obj)</span><br></pre></td></tr></table></figure>



<h4 id="数组方法详解"><a href="#数组方法详解" class="headerlink" title="数组方法详解"></a>数组方法详解</h4><h5 id="数组方法分类概览"><a href="#数组方法分类概览" class="headerlink" title="数组方法分类概览"></a>数组方法分类概览</h5><table>
<thead>
<tr>
<th align="left"><strong>方法类型</strong></th>
<th align="left"><strong>特点</strong></th>
<th align="left"><strong>代表方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">改变原数组</td>
<td align="left">直接修改数组</td>
<td align="left">push, pop, splice, sort, reverse</td>
</tr>
<tr>
<td align="left">不改变原数组</td>
<td align="left">返回新数组或值</td>
<td align="left">map, filter, slice, concat, reduce</td>
</tr>
<tr>
<td align="left">可中断遍历</td>
<td align="left">可通过返回值提前结束遍历</td>
<td align="left">some, every, find, findIndex</td>
</tr>
<tr>
<td align="left">不可中断遍历</td>
<td align="left">必须完整遍历所有元素</td>
<td align="left">forEach, map, filter, reduce</td>
</tr>
</tbody></table>
<h5 id="原生数组方法详细解析"><a href="#原生数组方法详细解析" class="headerlink" title="原生数组方法详细解析"></a>原生数组方法详细解析</h5><p><strong>1. 改变原数组的方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">参数</th>
<th align="left">是否改变原数组</th>
<th align="left">遍历是否可暂停</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>push</strong></td>
<td align="left">(item1, item2, …, itemN)</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">新数组长度</td>
</tr>
<tr>
<td align="left"><strong>pop</strong></td>
<td align="left">()</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">移除的元素</td>
</tr>
<tr>
<td align="left"><strong>shift</strong></td>
<td align="left">()</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">移除的元素</td>
</tr>
<tr>
<td align="left"><strong>unshift</strong></td>
<td align="left">(item1, item2, …, itemN)</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">新数组长度</td>
</tr>
<tr>
<td align="left"><strong>splice</strong></td>
<td align="left">(start, deleteCount, item1, item2, …, itemN)</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">被删除元素组成的数组</td>
</tr>
<tr>
<td align="left"><strong>sort</strong></td>
<td align="left">[compareFunction(a, b)]</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">排序后的数组</td>
</tr>
<tr>
<td align="left"><strong>reverse</strong></td>
<td align="left">()</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">反转后的数组</td>
</tr>
<tr>
<td align="left"><strong>fill</strong></td>
<td align="left">(value, [start], [end])</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">修改后的数组</td>
</tr>
<tr>
<td align="left"><strong>copyWithin</strong></td>
<td align="left">(target, [start], [end])</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">修改后的数组</td>
</tr>
</tbody></table>
<p><strong>2. 不改变原数组的方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">参数</th>
<th align="left">是否改变原数组</th>
<th align="left">遍历是否可暂停</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>concat</strong></td>
<td align="left">(array1, array2, …, arrayN)</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">合并后的新数组</td>
</tr>
<tr>
<td align="left"><strong>slice</strong></td>
<td align="left">([start], [end])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">提取元素组成的新数组</td>
</tr>
<tr>
<td align="left"><strong>join</strong></td>
<td align="left">([separator])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">连接后的字符串</td>
</tr>
<tr>
<td align="left"><strong>toString</strong></td>
<td align="left">()</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">数组的字符串表示</td>
</tr>
<tr>
<td align="left"><strong>indexOf</strong></td>
<td align="left">(searchElement, [fromIndex])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">元素的索引或 -1</td>
</tr>
<tr>
<td align="left"><strong>lastIndexOf</strong></td>
<td align="left">(searchElement, [fromIndex])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">元素的索引或 -1</td>
</tr>
<tr>
<td align="left"><strong>includes</strong></td>
<td align="left">(searchElement, [fromIndex])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left"><strong>map</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">处理后的新数组</td>
</tr>
<tr>
<td align="left"><strong>filter</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">过滤后的新数组</td>
</tr>
<tr>
<td align="left"><strong>reduce</strong></td>
<td align="left">(callback(acc, current, index, array), [initialValue])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">累计结果值</td>
</tr>
<tr>
<td align="left"><strong>reduceRight</strong></td>
<td align="left">(callback(acc, current, index, array), [initialValue])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">累计结果值</td>
</tr>
</tbody></table>
<p><strong>3. 可中断遍历的方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">参数</th>
<th align="left">是否改变原数组</th>
<th align="left">遍历是否可暂停</th>
<th align="left">暂停条件</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>some</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">callback 返回 true</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left"><strong>every</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">callback 返回 false</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left"><strong>find</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">callback 返回 true</td>
<td align="left">找到的元素或 undefined</td>
</tr>
<tr>
<td align="left"><strong>findIndex</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">callback 返回 true</td>
<td align="left">元素的索引或 -1</td>
</tr>
</tbody></table>
<p><strong>4. 不可中断遍历的方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">参数</th>
<th align="left">是否改变原数组</th>
<th align="left">遍历是否可暂停</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>forEach</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">遍历所有元素</td>
</tr>
<tr>
<td align="left"><strong>entries</strong></td>
<td align="left">()</td>
<td align="left">❌</td>
<td align="left">⚠️*</td>
<td align="left">返回迭代器，可用 break</td>
</tr>
<tr>
<td align="left"><strong>keys</strong></td>
<td align="left">()</td>
<td align="left">❌</td>
<td align="left">⚠️*</td>
<td align="left">返回迭代器，可用 break</td>
</tr>
<tr>
<td align="left"><strong>values</strong></td>
<td align="left">()</td>
<td align="left">❌</td>
<td align="left">⚠️*</td>
<td align="left">返回迭代器，可用 break</td>
</tr>
</tbody></table>
<blockquote>
<p>*注：entries&#x2F;keys&#x2F;values 方法返回的是迭代器对象，本身不进行遍历，使用迭代器时可配合 <code>break</code> 暂停</p>
</blockquote>
<h2 id="JavaScript-集合类型对比与应用场景指南"><a href="#JavaScript-集合类型对比与应用场景指南" class="headerlink" title="JavaScript 集合类型对比与应用场景指南"></a>JavaScript 集合类型对比与应用场景指南</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Map</th>
<th align="left">Set</th>
<th align="left">WeakMap</th>
<th align="left">WeakSet</th>
<th align="left">Object</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>键类型</strong></td>
<td align="left">任意类型</td>
<td align="left">任意类型</td>
<td align="left">仅对象</td>
<td align="left">仅对象</td>
<td align="left">字符串&#x2F;Symbol</td>
</tr>
<tr>
<td align="left"><strong>值类型</strong></td>
<td align="left">任意类型</td>
<td align="left">无值(仅存储键)</td>
<td align="left">任意类型</td>
<td align="left">无值(仅存储键)</td>
<td align="left">任意类型</td>
</tr>
<tr>
<td align="left"><strong>可迭代性</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅(需辅助方法)</td>
</tr>
<tr>
<td align="left"><strong>大小获取</strong></td>
<td align="left">直接(size属性)</td>
<td align="left">直接(size属性)</td>
<td align="left">不可获取</td>
<td align="left">不可获取</td>
<td align="left">需计算</td>
</tr>
<tr>
<td align="left"><strong>垃圾回收</strong></td>
<td align="left">强引用(阻止回收)</td>
<td align="left">强引用(阻止回收)</td>
<td align="left">弱引用(不阻止回收)</td>
<td align="left">弱引用(不阻止回收)</td>
<td align="left">强引用(阻止回收)</td>
</tr>
<tr>
<td align="left"><strong>顺序保证</strong></td>
<td align="left">插入顺序</td>
<td align="left">插入顺序</td>
<td align="left">无顺序</td>
<td align="left">无顺序</td>
<td align="left">无顺序(ES6后有序)</td>
</tr>
<tr>
<td align="left"><strong>键冲突处理</strong></td>
<td align="left">可覆盖</td>
<td align="left">自动去重</td>
<td align="left">可覆盖</td>
<td align="left">自动去重</td>
<td align="left">属性名覆盖</td>
</tr>
<tr>
<td align="left"><strong>序列化支持</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅</td>
</tr>
<tr>
<td align="left"><strong>原型链影响</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅</td>
</tr>
<tr>
<td align="left"><strong>性能(增删)</strong></td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">较低</td>
</tr>
</tbody></table>
<p><strong>应用场景详解</strong></p>
<ol>
<li>Map 最佳应用场景</li>
</ol>
<ul>
<li><strong>复杂键值存储</strong>：当需要使用非字符串键（如对象、函数）时</li>
<li><strong>DOM元素关联</strong>：将DOM元素与元数据关联，不污染DOM本身</li>
<li><strong>频率计数</strong>：高效统计元素出现频率</li>
<li><strong>有序键值对</strong>：需要保持键值对插入顺序的场景</li>
<li><strong>类私有属性</strong>：实现类实例的私有属性存储</li>
</ul>
<ol start="2">
<li>Set 最佳应用场景</li>
</ol>
<ul>
<li><strong>值唯一性保证</strong>：自动去除重复元素的场景</li>
<li><strong>集合运算</strong>：实现并集、交集、差集等数学集合操作</li>
<li><strong>存在性检查</strong>：快速检查元素是否存在的场景</li>
<li><strong>事件订阅管理</strong>：管理唯一的事件处理器集合</li>
<li><strong>数据过滤</strong>：从大型数据集中快速过滤唯一值</li>
</ul>
<ol start="3">
<li>WeakMap 最佳应用场景</li>
</ol>
<ul>
<li><strong>私有数据存储</strong>：关联对象与私有数据，不暴露给外部</li>
<li><strong>DOM元数据关联</strong>：当DOM元素被移除时自动清除关联数据</li>
<li><strong>缓存系统</strong>：对象缓存，当对象不再使用时自动清除缓存</li>
<li><strong>资源管理</strong>：对象与资源的关联，资源随对象自动释放</li>
<li><strong>避免内存泄漏</strong>：需要对象作为键且自动垃圾回收的场景</li>
</ul>
<ol start="4">
<li>WeakSet 最佳应用场景</li>
</ol>
<ul>
<li><strong>对象标记</strong>：标记对象状态（如”已处理”），不阻止垃圾回收</li>
<li><strong>循环引用检测</strong>：跟踪对象访问状态，防止无限递归</li>
<li><strong>临时对象集合</strong>：存储临时使用的对象集合，自动清理</li>
<li><strong>访问控制</strong>：检查对象是否具有特定权限，自动清理无效对象</li>
<li><strong>依赖管理</strong>：管理对象依赖关系，随主对象自动清除</li>
</ul>
<ol start="5">
<li>Object 最佳应用场景</li>
</ol>
<ul>
<li><strong>配置对象</strong>：结构化配置参数的存储</li>
<li><strong>JSON数据</strong>：需要序列化和反序列化的数据</li>
<li><strong>方法命名空间</strong>：组织相关函数和方法</li>
<li><strong>简单键值对</strong>：键为字符串&#x2F;Symbol的简单数据结构</li>
<li><strong>模块导出</strong>：作为模块的导出容器</li>
<li><strong>原型继承</strong>：需要利用原型链实现继承的场景</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>3种定义方式 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 全局提升</span></span><br><span class="line"><span class="keyword">const</span> fn =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 函数表达式</span></span><br><span class="line">箭头表达式</span><br><span class="line"><span class="comment">// 0或多个参数，1个可以没有（）</span></span><br><span class="line"><span class="comment">// 1行语句可以没有&#123;&#125;</span></span><br><span class="line">()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 引擎在任何代码执行之前，会<strong>先读取函数声明，并在执行上下文中生成函数定义</strong>。</p>
<p>而<strong>函数表达式必须等到代码执行到它那一行</strong>，才会在执行上下文中生成函数定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没问题  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">	<span class="keyword">return</span> num1 + num2;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>只有var 修饰的变量，存在<strong>变量声明提升</strong>，且在赋值前允许访问,<strong>但不赋值</strong>，返回undefiend</p>
<p>let存在<strong>变量声明提升</strong>，但是<strong>在赋值前不允许访问</strong>,报错</p>
<p>以上代码可以正常运行，因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个 过程叫作<strong>函数声明提升</strong>（function declaration hoisting）</p>
<p>在<strong>执行代码时，JavaScript 引擎会先执行一遍扫描， 把发现的函数声明提升到源代码树的顶部</strong>。因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部<font color="red">为了性能</font></p>
<p>这两提升适用于函数作用域<br><img src="/../img/image-20240216221556720.png" alt="image-20240216221556720"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会出错 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));  </span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">	<span class="keyword">return</span> num1 + num2;  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>上面的代码之所以会出错，是因为这个函数定义包含在一个变量初始化语句中，而不是函数声明中。 这意味着代码如果没有执行到加粗的那一行，那么执行上下文中就没有函数的定义，所以上面的代码会 出错。</p>
<p><strong>函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量 functionName。这样创建的函数叫作匿名函数（anonymous funtion），因为 function 关键字后面没有 标识符。（匿名函数有也时候也被称为兰姆达函数）。未赋值给其他变量的匿名函数的 name 属性是空字符串</strong>。</p>
<p>箭头函数箭头后面一行代码想要返回一个对像{}是不行的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span>=(<span class="params"></span>)=&gt;&#123;<span class="attr">test</span>:<span class="string">&quot;name&quot;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> res=<span class="title function_">fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//&#123;&#123;&#125;&#125;也不行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（&#123;&#125;）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span>=(<span class="params"></span>)=&gt;(&#123;<span class="attr">test</span>:<span class="string">&quot;name&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> res=<span class="title function_">fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);<span class="comment">//&#123;test:&quot;name&quot;&#125;</span></span><br></pre></td></tr></table></figure>



<p><strong>函数名</strong></p>
<p>函数名就是指向函数的指针，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着 一个函数可以有多个名称，如下所示： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">	<span class="keyword">return</span> num1 + num2;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20  </span></span><br><span class="line"><span class="keyword">let</span> anotherSum = sum;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherSum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20  </span></span><br><span class="line">sum = <span class="literal">null</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherSum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20  </span></span><br></pre></td></tr></table></figure>

<p>以上代码定义了一个名为 sum()的函数，用于求两个数之和。然后又声明了一个变量 anotherSum， 并将它的值设置为等于 sum。</p>
<p><strong>注意，使用不带括号的函数名会访问函数指针，而不会执行函数。</strong></p>
<p>此时， anotherSum 和 sum 都指向同一个函数。调用 anotherSum()也可以返回结果。</p>
<p>把 sum 设置为 null 之后，就切断了它与函数之间的关联。而 anotherSum()还是可以照常调用，没有问题</p>
<p>ECMAScript 6 的所有函数对象都会暴露一个只读的 <strong>name 属性</strong>，其中包含关于函数的信息。多数情 况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称， 也会如实显示成空字符串。<strong>如果它是使用 Function 构造函数创建的，则会标识成”anonymous”</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">baz</span> = (<span class="params"></span>) =&gt; &#123;&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">name</span>); <span class="comment">// foo </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">name</span>); <span class="comment">// bar </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">name</span>); <span class="comment">// baz </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="function">() =&gt;</span> &#123;&#125;).<span class="property">name</span>); <span class="comment">//（空字符串）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">new</span> <span class="title class_">Function</span>()).<span class="property">name</span>); <span class="comment">// anonymous </span></span><br></pre></td></tr></table></figure>

<p>如果函数是一个获取函数、设置函数，或者使用 bind()实例化，那么标识符前面会加上一个前缀：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">bind</span>(<span class="literal">null</span>).<span class="property">name</span>); <span class="comment">// bound foo  </span></span><br><span class="line"><span class="keyword">let</span> dog = &#123;  </span><br><span class="line">    <span class="attr">years</span>: <span class="number">1</span>,  </span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">age</span>() &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">years</span>;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">newAge</span>) &#123;  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">years</span> = newAge;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">let</span> propertyDescriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(dog, <span class="string">&#x27;age&#x27;</span>); <span class="variable language_">console</span>.<span class="title function_">log</span>(propertyDescriptor.<span class="property">get</span>.<span class="property">name</span>); <span class="comment">// get age  console.log(propertyDescriptor.set.name); // set age </span></span><br></pre></td></tr></table></figure>





<p><strong>函数参数</strong></p>
<p>定义形参就相当于<strong>在函数中声明了对应的变量，但是没有赋值</strong></p>
<p><img src="/../img/image-20240216221930349.png" alt="image-20240216221930349"></p>
<p><img src="/../img/image-20240216222103472.png" alt="image-20240216222103472"></p>
<p><img src="/../img/image-20240216222423936.png" alt="image-20240216222423936"></p>
<p><strong>ECMAScript 函数的参数在内部表现为一个数组</strong>。</p>
<p>函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。</p>
<p>如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没问题。</p>
<p>事实上，在使用 function 关键字定义（非箭头）函数时，<strong>可以在函数内部访问 arguments 对象</strong>，从中取得传进来的每个参数值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">howManyArgs</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">howManyArgs</span>(<span class="string">&quot;string&quot;</span>, <span class="number">45</span>); <span class="comment">// 2 </span></span><br><span class="line"><span class="title function_">howManyArgs</span>(); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">howManyArgs</span>(<span class="number">12</span>); <span class="comment">// 1 </span></span><br></pre></td></tr></table></figure>

<p><strong>arguments 对象</strong>可以跟命名参数一起使用，比如： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAdd</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;  </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + <span class="number">10</span>);  </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;  </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在这个 doAdd()函数中，同时使用了两个命名参数和 arguments 对象。命名参数 num1 保存着与 arugments[0]一样的值，因此使用谁都无所谓。（同样，num2 也保存着跟 arguments[1]一样的值。）</p>
<p> arguments 对象的另一个有意思的地方就是，<strong>它的值始终会与对应的命名参数同步</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAdd</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个 doAdd()函数把第二个参数的值重写为 10。因为 <strong>arguments 对象的值会自动同步到对应的命名参数</strong>，所以修改 arguments[1]也会修改 num2 的值，因此两者的值都是 10。但这并不意味着它们都访问同一个内存地址，<strong>它们在内存中还是分开的，只不过会保持同步而已</strong>。另外还要记住一点：如果只传了一个参数，然后把 arguments[1]设置为某个值，那么这个值并不会反映到第二个命名参数。这是 <strong>因为 arguments 对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的</strong></p>
<p>特例</p>
<p><strong>箭头函数中的参数</strong> </p>
<p>如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 arguments 关键字访问，而只能通过定义的命名参数访问。</p>
<p>注意 <strong>ECMAScript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。</strong></p>
<p>在JavaScript中，<strong>原始类型的内容是存储在栈中，而对象的内容是存储在堆中，指向堆的地址存储在栈中</strong>。</p>
<p>(Number、Stirng、Boolean、Null、Underfined这些基本数据类型，他们的值直接保存在栈中；<br>Object、Function、Array、Date、RegExp这些引用类型，他们的引用变量储存在栈中，通过指针指向储存在堆中的实际对象)</p>
<p>原始变量及他们的值储存在栈中，当把一个原始变量传递给另一个原始变量时，是把一个栈房间的东西复制到另一个栈房间，且这两个原始变量互不影响。</p>
<p>引用值是把引用变量的名称储存在栈中，但是其实际对象储存在堆中，且存在一个指针由变量名指向储存在堆中的实际对象，当把引用对象传递给另一个变量时，复制的其实是指向实际对象的指针，此时两者指向的是同一个数据，若通过方法改变其中一个变量的值，则访问另一个变量时，其值也会随之加以改变；但若通过重新赋值  ，此时相当于重新开了一个房间 ，该值的原指针改变，而另外一个值不会随它的改变而改变</p>
<p><strong>原始变量赋值给参数时，将栈中数据发给参数，两个数相互独立</strong></p>
<p><strong>引用变量给的是栈中的内存地址，所以，在函数内部发生属性值得改变，是对堆中对象的修改，所以另一个值得属性也发生，除非在函数中修改参数的内存的地址，也即参数重新赋值，才会再次相互独立</strong></p>
<p><strong>默认参数值</strong></p>
<p>1、使用默认参数时，arguments 对象的值不反映参数的默认值，只反映传给函数的参数</p>
<p>2、默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值：</p>
<p>3、函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数 只有在调用函数但未传相应参数时才会被调用。 箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了</p>
<p>4、默认参数会按照定义它们的顺序依次被初始化，后定义默认值的参数可以引用先定义的参数</p>
<p>5、参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的</p>
<p>6、参数也存在于自己的作用域中，它们不能引用函数体的作用域</p>
<p><strong>扩展参数</strong></p>
<p>对可迭代对象适用 …,这也适用于argument数组，箭头函数中也能这么写</p>
<p><strong>函数作为传递值</strong></p>
<p>函数作为值 因为函数名在 ECMAScript 中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。</p>
<h3 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h3><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a><strong>arguments</strong></h3><p>一个类数组对象，包含调用函数时传入的所有参数。这 个对象只有以 function 关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包 含函数参数，但 arguments 对象其实还有一个 callee 属性，是一个指向 arguments 对象所在函数的 指针。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a><strong>this</strong></h3><p>它在标准函数和箭头函数中有不同的行为。 在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 this 值（在 网页的全局上下文中调用函数时，this 指向 windows）</p>
<p>在箭头函数中，this引用的是定义箭头函数的上下文。</p>
<h4 id="对this对象的理解"><a href="#对this对象的理解" class="headerlink" title="对this对象的理解"></a>对this对象的理解</h4><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p>
<ul>
<li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li>
<li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li>
<li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li>
<li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li>
</ul>
<p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p>
<h4 id="对this-的补充"><a href="#对this-的补充" class="headerlink" title="对this 的补充"></a>对this 的补充</h4><ol>
<li>函数默认执行 执行window.也就是什么都不做直接执行</li>
<li>对象调用函数,会隐式绑定把this指向对象</li>
<li>显示绑定,通过call , apply , bind,会指向输入的参数,如果不输入参数,则默认绑定为window</li>
<li>通过new操作符来绑定this.</li>
</ol>
<p>它们的优先级是:</p>
<p>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。</p>
<p>还有一个考察的知识点就是箭头函数.它的this由定义它的结构代码时父级执行上下文决定的</p>
<ul>
<li>如果是在全局环境,或者是在一个对象里,它的父级执行上下文就是全局环境,它的this就指向了window</li>
<li>如果它的<strong>外部是一个函数,那么它的this就指向了函数的执行上下文.而函数的执行上下文就是活的.取决于调用时的情况.也就上面列举的四种情况</strong>.</li>
</ul>
<p>根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。</p>
<p>要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined</p>
<h4 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h4><p>函数的 <code>this</code> 关键字在 <code>JavaScript</code> 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别</p>
<p>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值（运行时绑定）</p>
<p><code>this</code> 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置是全局作用域</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;baz&quot;</span> );</span><br><span class="line">    <span class="title function_">bar</span>(); <span class="comment">// &lt;-- bar的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz --&gt; bar</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在baz中</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;bar&quot;</span> );</span><br><span class="line">    <span class="title function_">foo</span>(); <span class="comment">// &lt;-- foo的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz --&gt; bar --&gt; foo</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在bar中</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;foo&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">baz</span>(); <span class="comment">// &lt;-- baz的调用位置</span></span><br></pre></td></tr></table></figure>



<p>同时，<code>this</code>在函数执行过程中，<code>this</code>一旦被确定了，就不可以再更改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span> = obj; <span class="comment">// 修改this，运行后会报错</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>



<h4 id="二、绑定规则"><a href="#二、绑定规则" class="headerlink" title="二、绑定规则"></a>二、绑定规则</h4><p>根据不同的使用场合，<code>this</code>有不同的值，主要分为下面几种情况：</p>
<ul>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>new绑定</li>
<li>显示绑定</li>
</ul>
<h5 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h5><p>全局环境中定义<code>person</code>函数，内部使用<code>this</code>关键字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jenny&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">person</span>());  <span class="comment">//Jenny</span></span><br></pre></td></tr></table></figure>



<p>上述代码输出<code>Jenny</code>，原因是调用函数的对象在游览器中位<code>window</code>，因此<code>this</code>指向<code>window</code>，所以输出<code>Jenny</code></p>
<p>注意：</p>
<p>严格模式下，不能将全局对象用于默认绑定，this会绑定到<code>undefined</code>，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象</p>
<h5 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h5><p>函数还可以作为某个对象的方法调用，这时<code>this</code>就指这个上级对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">m</span> = test;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">m</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<p>这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，<code>this</code>指向的也只是它上一级的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>:&#123;</span><br><span class="line">        <span class="attr">fn</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">//undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.<span class="property">b</span>.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>



<p>上述代码中，<code>this</code>的上一级对象为<code>b</code>，<code>b</code>内部并没有<code>a</code>变量的定义，所以输出<code>undefined</code></p>
<p>这里再举一种特殊情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>:&#123;</span><br><span class="line">        <span class="attr">a</span>:<span class="number">12</span>,</span><br><span class="line">        <span class="attr">fn</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">//undefined</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//window</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = o.<span class="property">b</span>.<span class="property">fn</span>;</span><br><span class="line"><span class="title function_">j</span>();</span><br></pre></td></tr></table></figure>



<p>此时<code>this</code>指向的是<code>window</code>，这里的大家需要记住，<code>this</code>永远指向的是最后调用它的对象，虽然<code>fn</code>是对象<code>b</code>的方法，但是<code>fn</code>赋值给<code>j</code>时候并没有执行，所以最终指向<code>window</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure>

<h5 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h5><p>通过构建函数<code>new</code>关键字生成一个实例对象，此时<code>this</code>指向这个实例对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">　<span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">test</span>();</span><br><span class="line">obj.<span class="property">x</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<p>上述代码之所以能过输出1，是因为<code>new</code>关键字改变了<code>this</code>的指向</p>
<p>这里再列举一些特殊情况：</p>
<p><code>new</code>过程遇到<code>return</code>一个对象，此时<code>this</code>指向为返回的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">fn</span>();  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>



<p>如果返回一个简单类型的时候，则<code>this</code>指向实例对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//xxx</span></span><br></pre></td></tr></table></figure>



<p>注意的是<code>null</code>虽然也是对象，但是此时<code>new</code>仍然指向实例对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//xxx</span></span><br></pre></td></tr></table></figure>



<h5 id="显示修改"><a href="#显示修改" class="headerlink" title="显示修改"></a>显示修改</h5><p><code>apply()、call()、bind()</code>是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时<code>this</code>指的就是这第一个参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">　<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">m</span> = test;</span><br><span class="line">obj.<span class="property">m</span>.<span class="title function_">apply</span>(obj) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<p>关于<code>apply、call、bind</code>三者的区别，我们后面再详细说</p>
<h4 id="三、箭头函数"><a href="#三、箭头函数" class="headerlink" title="三、箭头函数"></a>三、箭头函数</h4><p>在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 <code>this</code> 的指向（编译时绑定）</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">sayThis</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">sayThis</span>(); <span class="comment">// window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了</span></span><br><span class="line"><span class="keyword">const</span> globalSay = obj.<span class="property">sayThis</span>;</span><br><span class="line"><span class="title function_">globalSay</span>(); <span class="comment">// window 浏览器中的 global 对象</span></span><br></pre></td></tr></table></figure>



<p>虽然箭头函数的<code>this</code>能够在编译的时候就确定了<code>this</code>的指向，但也需要注意一些潜在的坑</p>
<p>下面举个例子：</p>
<p>绑定事件监听</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mngb&#x27;</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;clicked button&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>上述可以看到，我们其实是想要<code>this</code>为点击的<code>button</code>，但此时<code>this</code>指向了<code>window</code></p>
<p>包括在原型上添加方法时候，此时<code>this</code>指向<code>window</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">//true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;mm&#x27;</span>);</span><br><span class="line">cat.<span class="title function_">sayName</span>()</span><br></pre></td></tr></table></figure>



<p>同样的，箭头函数不能作为构建函数</p>
<h4 id="四、优先级"><a href="#四、优先级" class="headerlink" title="四、优先级"></a>四、优先级</h4><h5 id="隐式绑定-VS-显式绑定"><a href="#隐式绑定-VS-显式绑定" class="headerlink" title="隐式绑定 VS 显式绑定"></a>隐式绑定 VS 显式绑定</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br><span class="line">obj2.<span class="title function_">foo</span>(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>( obj2 ); <span class="comment">// 3</span></span><br><span class="line">obj2.<span class="property">foo</span>.<span class="title function_">call</span>( obj1 ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<p>显然，显示绑定的优先级更高</p>
<h5 id="new绑定-VS-隐式绑定"><a href="#new绑定-VS-隐式绑定" class="headerlink" title="new绑定 VS 隐式绑定"></a>new绑定 VS 隐式绑定</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>( <span class="number">2</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>( obj2, <span class="number">3</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj2.<span class="property">a</span> ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.<span class="title function_">foo</span>( <span class="number">4</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( bar.<span class="property">a</span> ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>



<p>可以看到，new绑定的优先级<code>&gt;</code>隐式绑定</p>
<h5 id="new绑定-VS-显式绑定"><a href="#new绑定-VS-显式绑定" class="headerlink" title="new绑定 VS 显式绑定"></a><code>new</code>绑定 VS 显式绑定</h5><p>因为<code>new</code>和<code>apply、call</code>无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>( obj1 );</span><br><span class="line"><span class="title function_">bar</span>( <span class="number">2</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>( <span class="number">3</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( baz.<span class="property">a</span> ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar`被绑定到obj1上，但是`new bar(3)` 并没有像我们预计的那样把`obj1.a`修改为3。但是，`new`修改了绑定调用`bar()`中的`this</span><br></pre></td></tr></table></figure>

<p>我们可认为<code>new</code>绑定优先级<code>&gt;</code>显式绑定</p>
<p>综上，new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p>
<p>**new.target **</p>
<p>ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性。如果函数是正常调用的</p>
<p>则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的 构造函数。</p>
<p><strong>函数的属性和方法</strong></p>
<p>length 属性保存函数定义的命名参数的个数</p>
<p>prototype 属性也许是 ECMAScript 核心中最有趣的部分。prototype 是保存引用类型所有实例 方法的地方，这意味着 toString()、valueOf()等方法实际上都保存在 prototype 上，进而由所有实 例共享</p>
<p>apply()和 call()。这两个方法都会以指定的 this 值来调用函数，即会设 置调用函数时函数体内 this 对象的值。</p>
<p>apply()方法接收两个参数：函数内 this 的值和一个参数数组。第二个参数可以是 Array 的实例，但也可以是 arguments 对象</p>
<p>call()方法与 apply()的作用一样，只是传参的形式不同。第一个参数跟 apply()一样，也是 this 值，而剩下的要传给被调用函数的参数则是逐个传递的。换句话说，通过 call()向函数传参时，必须 将参数一个一个地列出来</p>
<p><strong>严格模式下，调用函数时如果没有指定上下文对象，则 this 值不会指向 window。 除非使用 apply()或 call()把函数指定给一个对象，否则 this 的值会变成 undefined。</strong></p>
<p>bind() bind()方法会创建一个新的函数实例， 其 this 值会被绑定到传给 bind()的对象。</p>
<h3 id="三个函数方法的原理实现"><a href="#三个函数方法的原理实现" class="headerlink" title=" 三个函数方法的原理实现"></a><font color="red"> <strong>三个函数方法的原理实现</strong></font></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断调用对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">      result = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">    context = context || <span class="variable language_">window</span>;</span><br><span class="line">    <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">    <span class="comment">// 将属性删除</span></span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">        fn = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">            <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context,</span><br><span class="line">            args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>尾调用优化的条件</strong> </p>
<p>代码在严格模式下执行； </p>
<p>外部函数的返回值是对尾调用函数的调用； </p>
<p>尾调用函数返回后不需要执行额外的逻辑； </p>
<p>尾调用函数不是引用外部函数作用域中自由变量的闭包</p>
<h3 id="函数垃圾回收"><a href="#函数垃圾回收" class="headerlink" title="函数垃圾回收"></a><strong>函数垃圾回收</strong></h3><p><strong>标记清理</strong></p>
<p> JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。</p>
<p>当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永 远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时， 也会被加上离开上下文的标记。 </p>
<p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下 文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现 并不重要，关键是策略。 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它 会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记 的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内 存清理，销毁带标记的所有值并收回它们的内存。</p>
<p><strong>引用计数</strong></p>
<p> 另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被 引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变 量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一 个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序 下次运行的时候就会释放引用数为 0 的值的内存。 引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：<strong>循环引用</strong>。所谓循环引 用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定 了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的<strong>变量对象（variable object）</strong>， 而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它</p>
<p><strong>全局上下文</strong></p>
<p>是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一 样。在浏览器中，全局上下文就是我们常说的 window 对象，因此<strong>所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。</strong></p>
<p><strong>使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义 在它上面的所有变量和函数</strong>（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。<br>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。 在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。</p>
<p>ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。 上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定 了各级上下文中的代码在访问变量和函数时的顺序。</p>
<p>代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有 一个定义变量：arguments。（全局上下文中没有这个变量）作用域链中的下一个变量对象来自包含上 下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；</p>
<p><strong>就近原则</strong></p>
<p>**全局上下文的变量对象始终是作用域链的最后一个变量对象。 **</p>
<p><strong>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符</strong></p>
<p><strong>作用域链增强</strong> </p>
<p>虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时： </p>
<p>try&#x2F;catch 语句的 catch 块 </p>
<p>with 语句 这两种情况下，都会在作用域链前端添加一个变量对象。</p>
<p><strong>对 with 语句来说，会向作用域链前端添 加指定的对象；</strong></p>
<p><strong>对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明</strong></p>
<h3 id="作用域、作用域链的理解"><a href="#作用域、作用域链的理解" class="headerlink" title="作用域、作用域链的理解"></a>作用域、作用域链的理解</h3><h5 id="1）全局作用域和函数作用域"><a href="#1）全局作用域和函数作用域" class="headerlink" title="1）全局作用域和函数作用域"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p>
<ul>
<li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li>
<li>所有未定义直接赋值的变量自动声明为全局作用域</li>
<li>所有window对象的属性拥有全局作用域</li>
<li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li>
</ul>
<p>（2）函数作用域</p>
<ul>
<li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li>
<li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li>
</ul>
<h5 id="2）块级作用域"><a href="#2）块级作用域" class="headerlink" title="2）块级作用域"></a>2）块级作用域</h5><ul>
<li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li>
<li>let和const声明的变量不会有变量提升，也不可以重复声明</li>
<li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li>
</ul>
<p><strong>作用域链：</strong></p>
<p>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p>
<p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p>
<p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p>
<p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><font color="red">函数的作用域，<strong>在函数创建时就已经确定的</strong>(词法作用域)和调用的位置无关</font></p>
<font color="red">

<p>闭包的生命周期:1闭包在外部函数调用时产生，外部函数每次调用都会产生一个全新的闭包2在内部函数丢失时销毁(内部函数被垃圾回收了，闭包才会消失)</p>
</font>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> a=<span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    <span class="title function_">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>



<p><img src="/../img/image-20240217084901274.png" alt="image-20240217084901274"></p>
<p>指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。比如，下面是之前展示的 createComparisonFunction()函数，</p>
<p>注 意其中加粗的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;  </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">object1, object2</span>) &#123;  </span><br><span class="line">		    <span class="keyword">let</span> value1 = object1[propertyName];  </span><br><span class="line">		    <span class="keyword">let</span> value2 = object2[propertyName];  </span><br><span class="line">		    <span class="keyword">if</span> (value1 &lt; value2) &#123;  </span><br><span class="line">		    	<span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">		    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;  </span><br><span class="line">		    	<span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">		    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">		    	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">		    &#125;  </span><br><span class="line">	 &#125;;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p><img src="/../img/image-20240217094012495.png" alt="image-20240217094012495"></p>
<h3 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h3><p>普通函数（外层函数）</p>
<p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义 compare()函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的[[Scope]]中。在 调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[Scope]]来创建其作用域链。接着会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。在这个例子中，这意味着 compare() 函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。</p>
<p><img src="/../img/image-20240217100208940.png" alt="image-20240217100208940"></p>
<p>函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。 在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。因此，在 createComparisonFunction()函数中，匿名函数的作用域链中实际上包含 createComparisonFunction()的活动对象。图 10-2 展示了以下代码执行后的结果</p>
<p><img src="/../img/image-20240217100229047.png" alt="image-20240217100229047"></p>
<p><font color="red">闭包在外部函数调用时且在外部函数作用域已被调用或者已被返回才会产生</font></p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>占用的内存没有及时释放</p>
<p>内存泄露积累多了就容易导致内存溢出</p>
<p>常见的内存泄露:<br>意外的全局变量</p>
<p>没有及时清理的计时器或回调函数</p>
<p>闭包</p>
<p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line"></span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法有三种：</p>
<p>●第一种是使用闭包的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  ;(<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line"></span><br><span class="line">​    &#125;, j * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">  &#125;)(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。</p>
<p>●第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(</span><br><span class="line"></span><br><span class="line">​    function timer(j) &#123;</span><br><span class="line"></span><br><span class="line">​      console.log(j)</span><br><span class="line"></span><br><span class="line">​    &#125;,</span><br><span class="line"></span><br><span class="line">​    i * 1000,</span><br><span class="line"></span><br><span class="line">​    i</span><br><span class="line"></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>●第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line"></span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a><strong>立即调用的函数表达式</strong></h2><p>立即调用的函数表达式（IIFE，Immediately Invoked Function  Expression）。</p>
<p>它类似于函数声明，但<strong>由于被包含在括号中，所以会被解释为函数表达式</strong>。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式。下面是一个简单的例子： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line"><span class="comment">// 块级作用域  </span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p> 使用 IIFE 可以<strong>模拟块级作用域</strong>，即在<strong>一个函数表达式内部声明变量，然后立即调用这个函数</strong>。这 样位于函数体作用域的变量就像是在块级作用域中一样。ECMAScript 5 尚未支持块级作用域，使用 IIFE 模拟块级作用域是相当普遍的。比如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// IIFE  </span><br><span class="line">(function () &#123;  </span><br><span class="line">	for (var i = 0; i &lt; count; i++) &#123;  </span><br><span class="line">		console.log(i);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;)();  console.log(i); // 抛出错误 </span><br></pre></td></tr></table></figure>

<p>前面的代码在执行到 IIFE 外部的 console.log()时会出错，因为它访问的变量是在 IIFE 内部定义的，在外部访问不到。</p>
<p>在 ECMAScript 5.1 及以前，为了防止变量定义外泄，IIFE 是个非常有效的方式。 这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕， 其作用域链就可以被销毁。 在 </p>
<p>ECMAScript 6 以后，IIFE 就没有那么必要了，因为块级作用域中的变量无须 IIFE 就可以实现同 样的隔离。下面展示了两种不同的块级作用域形式： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内嵌块级作用域  </span></span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">let</span> i;  </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;  </span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">		&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误 </span></span><br><span class="line"><span class="comment">// 循环的块级作用域 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;  </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误 </span></span><br></pre></td></tr></table></figure>

<p>说明 IIFE 用途的一个实际的例子，就是可以用它锁定参数值。比如： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);  <span class="comment">// 达不到目的！  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;  </span><br><span class="line">	divs[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">	&#125;);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里使用 var 关键字声明了循环迭代变量 i，但这个变量并不会被限制在 for 循环的块级作用域内。 因此，渲染到页面上之后，点击每个都会弹出元素总数。这是因为在执行单击处理程序时，迭代变 量的值是循环结束时的最终值，即元素的个数。而且，这个变量 i 存在于循环体外部，随时可以访问。 以前，为了实现点击第几个</p>
<p>就显示相应的索引值，需要借助 IIFE 来执行一个函数表达式，传 入每次循环的当前索引，从而“锁定”点击时应该显示的索引值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;  </span><br><span class="line">	divs[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, (<span class="keyword">function</span>(<span class="params">frozenCounter</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(frozenCounter);  </span><br><span class="line">        &#125;;  </span><br><span class="line">        &#125;)(i));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而使用 ECMAScript 块级作用域变量，就不用这么大动干戈了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;  </span><br><span class="line">	divs[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">	&#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/28/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/" data-id="cmcgaht3600004sur1w0e7uo4" data-title="基础开发" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html-css-javascript/" rel="tag">html css javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-前端基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2025-06-27T13:36:28.000Z" itemprop="datePublished">2025-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="计算机网络模型"><a href="#计算机网络模型" class="headerlink" title="计算机网络模型"></a>计算机网络模型</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p><code>ISO</code>为了更好的使网络应用更为普及，推出了<code>OSI</code>参考模型。</p>
<p><img src="/../img/25037.jpg" alt="img"></p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p><code>OSI</code>参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：<code>HTTP</code>，<code>HTTPS</code>，<code>FTP</code>，<code>POP3</code>、<code>SMTP</code>等。</p>
<ul>
<li>在客户端与服务器中经常会有数据的请求，这个时候就是会用到<code>http(hyper text transfer protocol)(超文本传输协议)</code>或者<code>https</code>.在后端设计数据接口时，我们常常使用到这个协议。</li>
<li><code>FTP</code>是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如<code>百度网盘``迅雷</code>应该是基于此协议的。</li>
<li><code>SMTP</code>是<code>simple mail transfer protocol（简单邮件传输协议）</code>。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。</li>
</ul>
<h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<p>在项目开发中，为了方便数据传输，可以使用<code>base64</code>对数据进行编解码。如果按功能来划分，<code>base64</code>应该是工作在表示层。</p>
<h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4><p>会话层就是<strong>负责建立、管理和终止表示层实体之间的通信会话</strong>。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，<code>TCP</code> <code>UDP</code>就是在这一层。端口号既是这里的“端”。</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>本层通过<code>IP</code>寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的<code>IP</code>层。这一层就是我们经常说的<code>IP</code>协议层。<code>IP</code>协议是<code>Internet</code>的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。</p>
<h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>将比特组合成字节,再将**字节组合成帧,**使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p>
<p>网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。</p>
<h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<p><strong>OSI七层模型通信特点：对等通信</strong></p>
<p>对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p>
<h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p><img src="/../img/bf34a01c9faf2dffc49a31e63858804.png" alt="image-20250628113806329"></p>
<table>
<thead>
<tr>
<th>OSI层</th>
<th>PDU名称</th>
<th>组成说明</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>报文&#x2F;消息</td>
<td>用户数据（如HTTP请求、FTP文件）</td>
</tr>
<tr>
<td>表示层</td>
<td>报文</td>
<td>加密&#x2F;压缩后的数据（如SSL&#x2F;TLS加密的HTTP数据）</td>
</tr>
<tr>
<td>会话层</td>
<td>报文</td>
<td>建立&#x2F;维护会话的数据（如RPC调用、NetBIOS会话）</td>
</tr>
<tr>
<td>传输层</td>
<td>段</td>
<td>TCP&#x2F;UDP数据，添加端口号、校验和（如TCP段包含序列号、窗口大小）</td>
</tr>
<tr>
<td>网络层</td>
<td>包</td>
<td>IP数据包，包含源&#x2F;目的IP地址（如IPv4包）</td>
</tr>
<tr>
<td>数据链路层</td>
<td>帧</td>
<td>以太网帧，添加MAC地址、CRC校验（如Ethernet II帧）</td>
</tr>
<tr>
<td>物理层</td>
<td>比特流</td>
<td>二进制信号（如电脉冲、光信号）</td>
</tr>
</tbody></table>
<p><strong>PDU的封装与解封装过程</strong><br>数据在发送时从上到下逐层封装，接收时从下到上逐层解封装：</p>
<p>  发送方（封装流程）</p>
<ul>
<li><p>应用层生成原始数据（如HTTP请求）。</p>
</li>
<li><p>传输层（TCP&#x2F;UDP）添加端口号、校验和，形成Segment。</p>
</li>
<li><p>网络层（IP）添加源&#x2F;目的IP地址，形成Packet。</p>
</li>
<li><p>数据链路层（以太网）添加MAC地址、帧头&#x2F;尾，形成Frame。</p>
</li>
</ul>
<p>物理层将帧转为比特流，通过介质传输。</p>
<ul>
<li>接收方（解封装流程）物理层接收比特流，还原为帧。</li>
<li>数据链路层校验帧，去除MAC头，提取Packet。</li>
<li>网络层检查IP地址，去除IP头，提取Segment。</li>
<li>传输层验证端口和校验和，去除TCP&#x2F;UDP头，传递数据给应用层。</li>
</ul>
<p>关键点<br>每层只处理本层的PDU</p>
<p>例如，路由器（网络层设备）只处理IP包，不关心TCP段或以太网帧的内容,交换机（数据链路层设备）只处理MAC帧，不解析IP包。</p>
<p><strong>PDU的命名差异</strong></p>
<ul>
<li><p>TCP&#x2F;IP模型中：</p>
</li>
<li><p>网络接口层PDU称Frame（帧）。</p>
</li>
<li><p>互联网层（IP）PDU称Packet（包）。</p>
</li>
<li><p>传输层（TCP&#x2F;UDP）PDU仍称Segment（段）。</p>
</li>
</ul>
<p><strong>封装开销</strong></p>
<p>每层添加的头部&#x2F;尾部会增加传输开销（如以太网帧头14字节，IP头20字节，TCP头20字节）。</p>
<h5 id="实例分析（HTTP-over-TCP-IP）"><a href="#实例分析（HTTP-over-TCP-IP）" class="headerlink" title="实例分析（HTTP over TCP&#x2F;IP）"></a>实例分析（HTTP over TCP&#x2F;IP）</h5><p>假设用户访问一个网页，PDU变化如下：</p>
<ul>
<li><p>应用层：HTTP请求（GET &#x2F;index.html） → Message。</p>
</li>
<li><p>传输层：添加TCP头（源端口、目的端口80） → Segment。</p>
</li>
<li><p>网络层：添加IP头（源IP 192.168.1.2，目的IP 93.184.216.34） → Packet。</p>
</li>
<li><p>数据链路层：添加以太网头（源MAC 00:1A:2B:3C:4D:5E，目的MAC 网关MAC） → Frame。</p>
</li>
<li><p>物理层：转为比特流发送。</p>
</li>
</ul>
<h2 id="Linux-接收网络包的流程"><a href="#Linux-接收网络包的流程" class="headerlink" title="Linux 接收网络包的流程"></a>Linux 接收网络包的流程</h2><p>网卡是计算机里的一个硬件，专门负责接收和发送网络包，当网卡接收到一个网络包后，会通过 DMA 技术，将网络包写入到指定的内存地址，也就是写入到 Ring Buffer ，这个是一个环形缓冲区，接着就会告诉操作系统这个网络包已经到达。</p>
<h3 id="告诉操作系统网络包已到达"><a href="#告诉操作系统网络包已到达" class="headerlink" title="告诉操作系统网络包已到达"></a>告诉操作系统网络包已到达</h3><p>那应该怎么告诉操作系统这个网络包已经到达了呢？</p>
<p>最简单的一种方式就是触发中断，也就是每当网卡收到一个网络包，就触发一个中断告诉操作系统。</p>
<p>但是，这存在一个问题，在高性能网络场景下，网络包的数量会非常多，那么就会触发非常多的中断，要知道当 CPU 收到了中断，就会停下手里的事情，而去处理这些网络包，处理完毕后，才会回去继续其他事情，那么频繁地触发中断，则会导致 CPU 一直没完没了的处理中断，而导致其他任务可能无法继续前进，从而影响系统的整体效率。</p>
<p>所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 <strong>NAPI 机制</strong>，它是混合「中断和轮询」的方式来接收网络包，它的核心概念就是<strong>不采用中断的方式读取数据</strong>，而是首先采用中断唤醒数据接收的服务程序，然后 poll 的方法来轮询数据。</p>
<p>因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着网卡向 CPU 发起硬件中断，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。</p>
<p>硬件中断处理函数会做如下的事情：</p>
<ul>
<li>需要先「暂时屏蔽中断」，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，避免 CPU 不停的被中断。</li>
<li>接着，发起「软中断」，然后恢复刚才屏蔽的中断。</li>
</ul>
<p>至此，硬件中断处理函数的工作就已经完成。</p>
<p>硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。</p>
<h3 id="软中断的处理"><a href="#软中断的处理" class="headerlink" title="软中断的处理"></a>软中断的处理</h3><p>内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来轮询处理数据。</p>
<p>ksoftirqd 线程会从 Ring Buffer 中获取一个数据帧，用 <code>sk_buff</code> 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。</p>
<h3 id="网络协议栈"><a href="#网络协议栈" class="headerlink" title="网络协议栈"></a>网络协议栈</h3><p>首先，会先进入到网络接口层，在这一层会检查报文的合法性，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再去掉帧头和帧尾，然后交给网络层。</p>
<p>到了网络层，则取出 IP 包，判断网络包下一步的走向，比如是交给上层处理还是转发出去。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着去掉 IP 头，然后交给传输层。</p>
<p>传输层取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把数据放到 Socket 的接收缓冲区。</p>
<p>最后，应用层程序调用 Socket 接口，将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区，然后唤醒用户进程。</p>
<p>至此，一个网络包的接收过程就已经结束了。下图左边部分描述的就是网络包接收的流程，右边部分刚好反过来，它是网络包发送的流程。</p>
<p><img src="/../img/receive-and-send-network-packets.d585a7bd.png" alt="网络包接收和发送流程"></p>
<h2 id="Linux-发送网络包的流程"><a href="#Linux-发送网络包的流程" class="headerlink" title="Linux 发送网络包的流程"></a>Linux 发送网络包的流程</h2><p>如上图的右半部分，发送网络包的流程正好和接收流程相反。</p>
<h3 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h3><p>首先，应用程序会调用 Socket 发送数据包的接口，由于这个是系统调用，所以会从用户态陷入到内核态中的 Socket 层，内核会申请一个内核态的 <code>sk_buff</code> 内存，<strong>将用户待发送的数据拷贝到 <code>sk_buff</code> 内存，并将其加入到发送缓冲区</strong>。</p>
<h3 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h3><p>接下来，网络协议栈从 Socket 发送缓冲区中取出 <code>sk_buff</code>，并按照 TCP&#x2F;IP 协议栈从上到下逐层处理。</p>
<p>如果使用的是 TCP 传输协议发送数据，那么<strong>先拷贝一个新的 <code>sk_buff</code> 副本</strong>，这是因为 <code>sk_buff</code> 后续在调用网络层，最后到达网卡发送完成的时候，这个 <code>sk_buff</code> 会被释放掉。而 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 <code>sk_buff</code> 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 <code>sk_buff</code> 的一个拷贝，等收到 ACK 再真正删除。</p>
<p>接着，对 <code>sk_buff</code> 填充 TCP 头。这里提一下，<code>sk_buff</code> 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment（段），在 IP 层我们叫 packet（包），在数据链路层称为 frame（帧）。</p>
<p>你可能会好奇，为什么全部数据包只用一个结构体来描述呢？协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头，如果每一层都用一个结构体，那在层之间传递数据的时候，就要发生多次拷贝，这将大大降低 CPU 效率。</p>
<p>于是，为了在层级之间传递数据时，不发生拷贝，只用 <code>sk_buff</code> 一个结构体来描述所有的网络包，那它是如何做到的呢？是通过调整 <code>sk_buff</code> 中 data 的指针，比如：</p>
<ul>
<li>当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb -&gt; data 的值，来逐步剥离协议首部。</li>
<li>当要发送报文时，创建 <code>sk_buff</code> 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb -&gt; data 的值来增加协议首部。</li>
</ul>
<p>至此，传输层的工作也就都完成了。</p>
<h3 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h3><p>然后交给网络层，在网络层里会做这些工作：选取路由（确认下一跳的 IP）、填充 IP 头、netfilter 过滤、对超过 MTU 大小的数据包进行分片。处理完这些工作后会交给网络接口层处理。</p>
<h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>网络接口层会通过 ARP 协议获得下一跳的 MAC 地址，然后对 <code>sk_buff</code> 填充帧头和帧尾，接着将 <code>sk_buff</code> 放到网卡的发送队列中。</p>
<h3 id="通知网卡有包要发送"><a href="#通知网卡有包要发送" class="headerlink" title="通知网卡有包要发送"></a>通知网卡有包要发送</h3><p>这一些工作准备好后，会触发「软中断」告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会从发送队列中读取 <code>sk_buff</code>，将这个 <code>sk_buff</code> 挂到 RingBuffer 中，接着将 <code>sk_buff</code> 数据映射到网卡可访问的内存 DMA 区域，最后触发真实的发送。</p>
<h3 id="完成网络包的发送"><a href="#完成网络包的发送" class="headerlink" title="完成网络包的发送"></a>完成网络包的发送</h3><p>当数据发送完成以后，其实工作并没有结束，因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存，主要是释放 <code>sk_buff</code> 内存和清理 RingBuffer 内存。</p>
<p>最后，当收到这个 TCP 报文的 ACK 应答时，传输层就会释放原始的 <code>sk_buff</code> 。</p>
<p>发送网络数据的时候，涉及几次内存拷贝操作？</p>
<ul>
<li>第一次，调用发送数据的系统调用的时候，内核会申请一个内核态的 <code>sk_buff</code> 内存，将用户待发送的数据拷贝到 <code>sk_buff</code> 内存，并将其加入到发送缓冲区。</li>
<li>第二次，在使用 TCP 传输协议的情况下，从传输层进入网络层的时候，每一个 <code>sk_buff</code> 都会被克隆一个新的副本出来。副本 <code>sk_buff</code> 会被送往网络层，等它发送完的时候就会释放掉，然后原始的 <code>sk_buff</code> 还保留在传输层，目的是为了实现 TCP 的可靠传输，等收到这个数据包的 ACK 时，才会释放原始的 <code>sk_buff</code>。</li>
<li>第三次，当 IP 层发现 <code>sk_buff</code> 大于 MTU 时才需要进行。会再申请额外的 <code>sk_buff</code>，并将原来的 <code>sk_buff</code> 拷贝为多个小的 <code>sk_buff</code>。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>电脑与电脑之间通常都是通过话网卡、交换机、路由器等网络设备连接到一起，那由于网络设备的异构性，国际标准化组织定义了一个七层的 OSI 网络模型，但是这个模型由于比较复杂，实际应用中并没有采用，而是采用了更为简化的 TCP&#x2F;IP 模型，Linux 网络协议栈就是按照了该模型来实现的。</p>
<p>TCP&#x2F;IP 模型主要分为应用层、传输层、网络层、网络接口层四层，每一层负责的职责都不同，这也是 Linux 网络协议栈主要构成部分。</p>
<p>当应用程序通过 Socket 接口发送数据包，数据包会被网络协议栈从上到下进行逐层处理后，才会被送到网卡队列中，随后由网卡将网络包发送出去。</p>
<p>而在接收网络包时，同样也要先经过网络协议栈从下到上的逐层处理，最后才会被送到应用程序。</p>
<p>在网上看到一张不错的动图，附上：</p>
<p><img src="/../img/receive-and-send-network-packets-in-osi.70a653a6.gif" alt="OSI 七层协议数据传输的封包与解包过程"></p>
<p>各层协议与设备<br><img src="/../img/16ce7eb72c0dc44c.webp"></p>
<p><img src="/../img/16ce7ee86d166933.webp"></p>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h2 id="IP协议的基本功能"><a href="#IP协议的基本功能" class="headerlink" title="IP协议的基本功能"></a>IP协议的基本功能</h2><p>IP的主要目的是通过一个互联的网络传输数据报，涉及两个最基本的功能。</p>
<ul>
<li><strong>寻址（Addressing）</strong>：IP协议根据数据报首部中包括的目的地址将数据报传送到目的节点，这就要涉及传送路径的选择，即路由功能。IP协议使用IP地址来实现路由。</li>
<li><strong>分片（Fragmentation）</strong>：IP协议还提供对数据大小的分片和重组，以适应不同网络对数据包大小的限制。如果网络只能传送小数据包，IP协议将对数据报进行分段并重新组成小块再进行传送</li>
</ul>
<h2 id="IP协议的特性"><a href="#IP协议的特性" class="headerlink" title="IP协议的特性"></a>IP协议的特性</h2><p>IP 是一个<strong>无连接的、不可靠的、点对点</strong>的协议，只能尽力（Best Effort）传送数据，不能保证数据的到达。</p>
<p>在IP网络中，“点对点”（Point-to-Point，简称P2P）指<strong>两个网络节点之间建立直接、独占的通信链路</strong></p>
<p>具体地讲，主要有以下特性。</p>
<ul>
<li>IP协议提供无连接数据报服务，各个数据报独立传输，可能沿着不同的路径到达目的地，也可能不会按序到达目的地。</li>
<li>IP 协议不含错误检测或错误恢复的编码，属于不可靠的协议。所谓不可靠，是从数据传输的可靠性不能保证的角度而言的，查询的延误及其他网络通信故障都有可能导致所传数据的丢失。对这种情况，IP 协议本身不处理。它的不可靠并不能说明整个 TCP&#x2F;IP 协议不可靠。如果要求数据传输具有可靠性，则要在IP的上面使用TCP协议加以保证。位于上一层的TCP协议则提供了错误检测和恢复机制。</li>
<li>作为一种点对点协议，虽然 IP 数据报携带源 IP 地址和目的 IP 地址，但进行数据传输时的对等实体一定是相邻设备（同一网络）中的对等实体。</li>
<li>IP协议的效率非常高，实现起来也较简单。这是因为IP协议采用了尽力传输的思想，随着底层网络质量的日益提高，IP协议的尽力传输的优势体现得更加明显。</li>
</ul>
<h2 id="IP协议的工作方式"><a href="#IP协议的工作方式" class="headerlink" title="IP协议的工作方式"></a>IP协议的工作方式</h2><p>在一个路由式网络中，源地址主机向目标地址主机发送数据时，IP协议是如何将数据成功发送到目标主机上的呢？由于网络分同网段和不同网段两种情况，工作方式如下：</p>
<h3 id="同网段"><a href="#同网段" class="headerlink" title="同网段"></a>同网段</h3><p>如果源地址主机和目标地址主机在同一网段，目标IP地址被ARP协议解析为MAC地址，然后根据MAC地址，源主机直接把数据包发给目标主机。</p>
<h3 id="不同网段"><a href="#不同网段" class="headerlink" title="不同网段"></a>不同网段</h3><p>如果源地址主机和目标地址主机在不同网段，数据包发送过程如下：</p>
<p>（1）网关（一般为路由器）的IP地址被ARP协议解析为MAC地址。根据该MAC地址，源主机将数据包发送到网关。</p>
<p>（2）网关根据数据包中的网段ID寻找目标网络。如果找到，将数据包发送到目标网段；如果没找到，重复步骤（1）将数据包发送到上一级网关。</p>
<p>（3）数据包经过网关被发送到正确的网段中。目标IP地址被ARP协议解析为MAC地址。根据该MAC地址，数据包被发送给目标地址的主机。</p>
<h2 id="ip地址分类"><a href="#ip地址分类" class="headerlink" title="ip地址分类"></a><strong>ip地址分类</strong></h2><ul>
<li><p>A类地址：范围从0.0.0.0到127.255.255.255，默认子网掩码为255.0.0.0，适用于大型网络。</p>
</li>
<li><p>B类地址：范围从128.0.0.0到191.255.255.255，默认子网掩码为255.255.0.0，适用于中型网络。</p>
</li>
<li><p>C类地址：范围从192.0.0.0到223.255.255.255，默认子网掩码为255.255.255.0，适用于小型网络。</p>
</li>
<li><p>D类地址：范围从224.0.0.0到239.255.255.255，用于多播地址。</p>
</li>
<li><p>E类地址：范围从240.0.0.0到255.255.255.255，保留用于实验和研究。</p>
</li>
</ul>
<p><img src="/../img/21928.jpg"></p>
<h1 id="TCP、UDP"><a href="#TCP、UDP" class="headerlink" title="TCP、UDP"></a>TCP、UDP</h1><h2 id="TCP-和-UDP的概念及特点"><a href="#TCP-和-UDP的概念及特点" class="headerlink" title="TCP 和 UDP的概念及特点"></a>TCP 和 UDP的概念及特点</h2><p>TCP 和 UDP都是传输层协议，他们都属于TCP&#x2F;IP协议族：</p>
<p><strong>（1）UDP</strong></p>
<p>UDP的全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p>它的特点如下：</p>
<p><strong>1）面向无连接</strong></p>
<p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>
<p>具体来说就是：</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<p><strong>2）有单播，多播，广播的功能</strong></p>
<p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
<p><strong>3）面向报文</strong></p>
<p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
<p><strong>4）不可靠性</strong></p>
<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>
<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
<p><strong>5）头部开销小，传输数据报文时是很高效的。</strong></p>
<p><img src="/../img/2019-03-21-03.png" alt="img"></p>
<p>UDP 头部包含了以下几个数据：</p>
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
<p>因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。</p>
<p><strong>（2）TCP</strong></p>
<p>TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。</p>
<p>它有以下几个特点：</p>
<p><strong>1）面向连接</strong></p>
<p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>
<p><strong>2）仅支持单播传输</strong></p>
<p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>
<p><strong>3）面向字节流</strong></p>
<p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>
<p><strong>4）可靠传输</strong></p>
<p>对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
<p><strong>5）提供拥塞控制</strong></p>
<p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。</p>
<p><strong>6）提供全双工通信</strong></p>
<p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输（数据顺序和正确性），使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于实时应用，例如视频会议、直播</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<h2 id="TCP和UDP的使用场景"><a href="#TCP和UDP的使用场景" class="headerlink" title="TCP和UDP的使用场景"></a>TCP和UDP的使用场景</h2><ul>
<li><strong>TCP应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</li>
<li><strong>UDP应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</li>
</ul>
<h2 id="UDP协议为什么不可靠？"><a href="#UDP协议为什么不可靠？" class="headerlink" title="UDP协议为什么不可靠？"></a>UDP协议为什么不可靠？</h2><p>UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</p>
<ul>
<li>不保证消息交付：不确认，不重传，无超时</li>
<li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li>
<li>不跟踪连接状态：不必建立连接或重启状态机</li>
<li>不进行拥塞控制：不内置客户端或网络反馈机制</li>
</ul>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="/../img/850de5c566ae60989f45cff4b1aad94c.png" alt="img"></p>
<p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>
<p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。</li>
</ul>
<p>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p>
<ul>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li>
</ul>
<p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y</p>
<ul>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</li>
</ul>
<p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
<p><strong>那为什么要三次握手呢？两次不行吗？</strong></p>
<ul>
<li>为了确认双方的接收能力和发送能力都正常</li>
<li>如果是用两次握手，则会出现下面这种情况：</li>
</ul>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
<h4 id="第一次握手丢失了，会发生什么？"><a href="#第一次握手丢失了，会发生什么？" class="headerlink" title="第一次握手丢失了，会发生什么？"></a>第一次握手丢失了，会发生什么？</h4><p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code>SYN_SENT</code> 状态。</p>
<p>在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「<strong>超时重传</strong>」机制，重传 SYN 报文，而且<strong>重传的 SYN 报文的序列号都是一样的</strong>。</p>
<p>对于超时时间，不同版本的操作系统可能不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的，如果想要更改则需要重新编译内核，比较麻烦。</p>
<p>当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文，那到底重发几次呢？</p>
<p>在 Linux 里，客户端的 SYN 报文最大重传次数由 <code>tcp_syn_retries</code> 内核参数控制，这个参数是可以自定义的，默认值一般是 5。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/net/ipv4/tcp_syn_retries</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，<strong>每次超时的时间是上一次的 2 倍</strong>。</p>
<p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</p>
<p>所以，总耗时是 1+2+4+8+16+32&#x3D;63 秒，大约 1 分钟左右。</p>
<p>举个例子，假设 <code>tcp_syn_retries</code> 参数值为 3，那么当客户端的 SYN 报文一直在网络中丢失时，会发生下图的过程：</p>
<p><img src="/../img/lost-in-first-handshake.b62af538.png" alt="第一次握手丢失"></p>
<p>（第一次握手丢失）</p>
<p>具体过程：</p>
<ul>
<li>当客户端超时重传 3 次 SYN 报文后，由于 <code>tcp_syn_retries</code> 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</li>
</ul>
<h4 id="第二次握手丢失了，会发生什么？"><a href="#第二次握手丢失了，会发生什么？" class="headerlink" title="第二次握手丢失了，会发生什么？"></a>第二次握手丢失了，会发生什么？</h4><p>当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN_RCVD</code> 状态。</p>
<p>第二次握手的 SYN-ACK 报文其实有两个目的：</p>
<ul>
<li>第二次握手里的 ACK， 是对第一次握手的确认报文；</li>
<li>第二次握手里的 SYN，是服务端发起建立 TCP 连接的报文；</li>
</ul>
<p>所以，如果第二次握手丢了，就会发生比较有意思的事情，具体会怎么样呢？</p>
<p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p>
<p>然后，因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。</p>
<p>那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是服务端这边会触发超时重传机制，重传 SYN-ACK 报文。</p>
<p>因此，当第二次握手丢失了，<strong>客户端和服务端都会重传</strong>：</p>
<ul>
<li>客户端会重传 SYN 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code> 内核参数决定；</li>
<li>服务端会重传 SYN-ACK 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</li>
</ul>
<p>在 Linux 下，SYN-ACK 报文的最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定，默认值是 5。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/net/ipv4/tcp_synack_retries</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>举个例子，假设 <code>tcp_syn_retries</code> 参数值为 1，<code>tcp_synack_retries</code> 参数值为 2，那么当第二次握手一直丢失时，发生的过程如下图：</p>
<p><img src="/../img/lost-in-second-handshake.1e63a9ff.png" alt="第二次握手丢失"></p>
<p>具体过程：</p>
<ul>
<li>当客户端超时重传 1 次 SYN 报文后，由于 <code>tcp_syn_retries</code> 为 1，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次握手（SYN-ACK 报文），那么客户端就会断开连接。</li>
<li>当服务端超时重传 2 次 SYN-ACK 报文后，由于 <code>tcp_synack_retries</code> 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。</li>
</ul>
<h4 id="第三次握手丢失了，会发生什么？"><a href="#第三次握手丢失了，会发生什么？" class="headerlink" title="第三次握手丢失了，会发生什么？"></a>第三次握手丢失了，会发生什么？</h4><p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 <code>ESTABLISH</code> 状态。</p>
<p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p>
<p>注意，<strong>ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文</strong>。</p>
<p>举个例子，假设 <code>tcp_synack_retries</code> 参数值为 2，那么当第三次握手一直丢失时，发生的过程如下图：</p>
<p><img src="/../img/lost-in-third-handshake.7f728e63.png" alt="第三次握手丢失"></p>
<p>具体过程：</p>
<ul>
<li>当服务端超时重传 2 次 SYN-ACK 报文后，由于 <code>tcp_synack_retries</code> 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第三次握手（ACK 报文），那么服务端就会断开连接。</li>
</ul>
<h4 id="关于-SYN-攻击"><a href="#关于-SYN-攻击" class="headerlink" title="关于 SYN 攻击"></a>关于 SYN 攻击</h4><h5 id="什么是-SYN-攻击"><a href="#什么是-SYN-攻击" class="headerlink" title="什么是 SYN 攻击"></a>什么是 SYN 攻击</h5><p>我们都知道 TCP 连接建立是需要三次握手，假设攻击者短时间伪造不同 IP 地址的 <code>SYN</code> 报文，服务端每接收到一个 <code>SYN</code> 报文，就进入 <code>SYN_RCVD</code> 状态，但服务端发送出去的 <code>SYN-ACK</code> 报文，无法得到未知 IP 主机的 <code>ACK</code> 应答，久而久之就会<strong>占满服务端的半连接队列</strong>，使得服务器不能为正常用户服务。</p>
<p><img src="/../img/syn-attack.23a59005.png" alt="SYN 攻击"></p>
<p>下面先来看一下什么是 TCP 半连接和全连接队列。</p>
<h5 id="半连接和全连接队列"><a href="#半连接和全连接队列" class="headerlink" title="半连接和全连接队列"></a>半连接和全连接队列</h5><p>在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：</p>
<ul>
<li>半连接队列，也称 SYN 队列。</li>
<li>全连接队列，也称 Accpet 队列。</li>
</ul>
<p>先来看下 Linux 内核的 <code>SYN</code> 队列（半连接队列）与 <code>Accpet</code> 队列（全连接队列）是如何工作的？</p>
<p><img src="/../img/syn-queue-and-accpet-queue-1.61cea3b1.png" alt="SYN 攻击"></p>
<p>正常流程：</p>
<ul>
<li>当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「SYN 队列」。</li>
<li>接着发送 SYN-ACK 给客户端，等待客户端回应 ACK 报文。</li>
<li>服务端接收到 ACK 报文后，从「SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「Accept 队列」。</li>
<li>应用通过调用 <code>accpet()</code> socket 接口，从「Accept 队列」取出连接对象。</li>
</ul>
<p>不管是半连接队列还是全连接队列，都有最大长度限制，超过限制时，默认情况都会丢弃报文。</p>
<p>SYN 攻击方式最直接的表现就是把 TCP 半连接队列打满，这样<strong>当 TCP 半连接队列满了，后续再收到 SYN 报文就会丢弃</strong>，导致客户端无法和服务端建立连接。</p>
<h4 id="避免-SYN-攻击方式"><a href="#避免-SYN-攻击方式" class="headerlink" title="避免 SYN 攻击方式"></a>避免 SYN 攻击方式</h4><p>避免 SYN 攻击方式，可以有以下四种方法：</p>
<ul>
<li>调大 <code>netdev_max_backlog</code></li>
<li>增大 TCP 半连接队列</li>
<li>开启 <code>tcp_syncookies</code></li>
<li>减少 SYN-ACK 重传次数</li>
</ul>
<h5 id="1）方式一：调大-netdev-max-backlog"><a href="#1）方式一：调大-netdev-max-backlog" class="headerlink" title="1）方式一：调大 netdev_max_backlog"></a>1）方式一：调大 <code>netdev_max_backlog</code></h5><p>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。控制该队列的最大值如下参数，默认值是 1000，我们要适当调大该参数的值，比如设置为 10000：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.core.netdev_max_backlog = 10000</span><br></pre></td></tr></table></figure>

<h5 id="2）方式二：增大-TCP-半连接队列"><a href="#2）方式二：增大-TCP-半连接队列" class="headerlink" title="2）方式二：增大 TCP 半连接队列"></a>2）方式二：增大 TCP 半连接队列</h5><p>增大 TCP 半连接队列，要同时增大下面这三个参数：</p>
<ul>
<li>增大 <code>net.ipv4.tcp_max_syn_backlog</code></li>
<li>增大 <code>listen()</code> 函数中的 <code>backlog</code></li>
<li>增大 <code>net.core.somaxconn</code></li>
</ul>
<p>具体为什么是这三个参数决定 TCP 半连接队列的大小，这里暂不深入研究。</p>
<h5 id="3）方式三：开启-net-ipv4-tcp-syncookies"><a href="#3）方式三：开启-net-ipv4-tcp-syncookies" class="headerlink" title="3）方式三：开启 net.ipv4.tcp_syncookies"></a>3）方式三：开启 <code>net.ipv4.tcp_syncookies</code></h5><p>开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。</p>
<p><img src="/../img/syn-queue-and-accpet-queue-2.65bc64b2.png" alt="SYN 队列占满，启动 cookie"></p>
<p>具体过程：</p>
<ul>
<li>当「SYN 队列」满之后，后续服务器收到 SYN 包，不会丢弃，而是根据算法，计算出一个 cookie 值。</li>
<li>将 cookie 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端。</li>
<li>服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「Accept 队列」。</li>
<li>最后应用程序通过调用 <code>accpet()</code> 接口，从「Accept 队列」取出的连接。</li>
</ul>
<p>可以看到，当开启了 <code>tcp_syncookies</code> 了，即使受到 SYN 攻击而导致 SYN 队列满时，也能保证正常的连接成功建立。</p>
<p><code>net.ipv4.tcp_syncookies</code> 参数主要有以下三个值：</p>
<ul>
<li><code>0</code> 值，表示关闭该功能。</li>
<li><code>1</code> 值，表示仅当 SYN 半连接队列放不下时，再启用它。</li>
<li><code>2</code> 值，表示无条件开启功能。</li>
</ul>
<p>那么在应对 SYN 攻击时，只需要设置为 <code>1</code> 即可：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/tcp_syncookies</span><br></pre></td></tr></table></figure>

<h5 id="4）减少-SYN-ACK-重传次数"><a href="#4）减少-SYN-ACK-重传次数" class="headerlink" title="4）减少 SYN-ACK 重传次数"></a>4）减少 SYN-ACK 重传次数</h5><p>当服务端受到 SYN 攻击时，就会有大量处于 <code>SYN_REVC</code> 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN-ACK ，当重传超过次数达到上限后，就会断开连接。</p>
<p>那么针对 SYN 攻击的场景，我们可以减少 SYN-ACK 的重传次数，以加快处于 <code>SYN_REVC</code> 状态的 TCP 连接断开。</p>
<p>SYN-ACK 报文的最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定（默认值是 5 次），比如将 <code>tcp_synack_retries</code> 减少到 2 次：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 2 &gt; /proc/sys/net/ipv4/tcp_synack_retries</span><br></pre></td></tr></table></figure>



<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="/../img/0dc25c2e6ae3de02cc4039553165d8cf.png" alt="img"></p>
<p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<ul>
<li>第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li>
</ul>
<p>即发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p>
<ul>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li>
</ul>
<p>即服务端收到连接释放报文段后即发出确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p>
<ul>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li>
</ul>
<p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p>
<ul>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ul>
<p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p>
<p><strong>那为什么需要四次挥手呢？</strong></p>
<p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p>
<p><strong>简单来说就是以下四步：</strong></p>
<ul>
<li><strong>第一次挥手</strong>：若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li>
<li><strong>第二次挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li>
<li><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</li>
<li><strong>第四次挥手</strong>：客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li>
</ul>
<p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。</p>
<p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭</p>
<h4 id="第一次挥手丢失了，会发生什么？"><a href="#第一次挥手丢失了，会发生什么？" class="headerlink" title="第一次挥手丢失了，会发生什么？"></a>第一次挥手丢失了，会发生什么？</h4><p>当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 <code>FIN_WAIT_1</code> 状态。</p>
<p>正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 <code>FIN_WAIT2</code> 状态。</p>
<p>如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发<strong>超时重传</strong>机制，重传 FIN 报文，重发次数由 <code>tcp_orphan_retries</code> 参数控制。</p>
<p>当客户端重传 FIN 报文的次数超过 <code>tcp_orphan_retries</code> 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 <code>close</code> 状态。</p>
<p>举个例子，假设 <code>tcp_orphan_retries</code> 参数值为 3，当第一次挥手一直丢失时，发生的过程如下图：</p>
<p><img src="/../img/lost-in-first-wave.c639c167.png" alt="第一次挥手丢失"></p>
<p>具体过程：</p>
<ul>
<li>当客户端超时重传 3 次 FIN 报文后，由于 <code>tcp_orphan_retries</code> 为 3，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。</li>
</ul>
<h4 id="第二次挥手丢失了，会发生什么？"><a href="#第二次挥手丢失了，会发生什么？" class="headerlink" title="第二次挥手丢失了，会发生什么？"></a>第二次挥手丢失了，会发生什么？</h4><p>当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 <code>CLOSE_WAIT</code> 状态。</p>
<p>在前面我们也提了，ACK 报文是不会重传的，所以如果服务端的第二次挥手丢失了，客户端就会触发超时重传机制，重传 FIN 报文，直到收到服务端的第二次挥手，或者达到最大的重传次数。</p>
<p>举个例子，假设 <code>tcp_orphan_retries</code> 参数值为 2，当第二次挥手一直丢失时，发生的过程如下图：</p>
<p><img src="/../img/lost-in-second-wave.27229796.png" alt="第二次挥手丢失"></p>
<p>具体过程：</p>
<ul>
<li>当客户端超时重传 2 次 FIN 报文后，由于 <code>tcp_orphan_retries</code> 为 2，已达到最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到服务端的第二次挥手（ACK 报文），那么客户端就会断开连接。</li>
</ul>
<p>这里提一下，当客户端收到第二次挥手，也就是收到服务端发送的 ACK 报文后，客户端就会处于 <code>FIN_WAIT2</code> 状态，在这个状态需要等服务端发送第三次挥手，也就是服务端的 FIN 报文。</p>
<p>对于 close 函数关闭的连接，由于无法再发送和接收数据，所以 <code>FIN_WAIT2</code> 状态不可以持续太久，而 <code>tcp_fin_timeout</code> 控制了这个状态下连接的持续时长，默认值是 60 秒。</p>
<p>这意味着对于调用 close 关闭的连接，如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭，如下图：</p>
<p><img src="/../img/fin_wait_2-by-close.59fd1ca9.png" alt="调用 close 关闭的连接"></p>
<p>但是注意，如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。</p>
<p>此时，如果主动关闭方一直没收到第三次挥手，那么主动关闭方的连接将会一直处于 <code>FIN_WAIT2</code> 状态（<code>tcp_fin_timeout</code> 无法控制 shutdown 关闭的连接）。如下图：</p>
<p><img src="/../img/fin_wait_2-by-shutdown.f485c6fb.png" alt="调用 shutdown 关闭的连接"></p>
<h4 id="第三次挥手丢失了，会发生什么？"><a href="#第三次挥手丢失了，会发生什么？" class="headerlink" title="第三次挥手丢失了，会发生什么？"></a>第三次挥手丢失了，会发生什么？</h4><p>当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 <code>CLOSE_WAIT</code> 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。</p>
<p>此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。</p>
<p>服务端处于 <code>CLOSE_WAIT</code> 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 <code>LAST_ACK</code> 状态，等待客户端返回 ACK 来确认连接关闭。</p>
<p>如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 <code>tcp_orphan_retries</code> 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。</p>
<p>举个例子，假设 <code>tcp_orphan_retries = 3</code>，当第三次挥手一直丢失时，发生的过程如下图：</p>
<p><img src="/../img/lost-in-third-wave.b8f03061.png" alt="第三次挥手丢失"></p>
<p>具体过程：</p>
<ul>
<li>当服务端重传第三次挥手报文的次数达到了 3 次后，由于 <code>tcp_orphan_retries</code> 为 3，达到了重传最大次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK报文），那么服务端就会断开连接。</li>
<li>客户端因为是通过 close 函数关闭连接的，处于 <code>FIN_WAIT_2</code> 状态是有时长限制的，如果 <code>tcp_fin_timeout</code> 时间内还是没能收到服务端的第三次挥手（FIN 报文），那么客户端就会断开连接。</li>
</ul>
<h4 id="第四次挥手丢失了，会发生什么？"><a href="#第四次挥手丢失了，会发生什么？" class="headerlink" title="第四次挥手丢失了，会发生什么？"></a>第四次挥手丢失了，会发生什么？</h4><p>当客户端收到服务端的第三次挥手的 FIN 报文后，就会回 ACK 报文，也就是第四次挥手，此时客户端连接进入 <code>TIME_WAIT</code> 状态。</p>
<p>在 Linux 系统，<code>TIME_WAIT</code> 状态会持续 2MSL 后才会进入关闭状态。</p>
<p>然后，服务端（被动关闭方）没有收到 ACK 报文前，还是处于 <code>LAST_ACK</code> 状态。</p>
<p>如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 <code>tcp_orphan_retries</code> 参数控制。</p>
<p>举个例子，假设 <code>tcp_orphan_retries</code> 为 2，当第四次挥手一直丢失时，发生的过程如下：</p>
<p><img src="/../img/lost-in-fourth-wave.80200bab.png" alt="第四次挥手丢失"></p>
<p>具体过程：</p>
<ul>
<li>当服务端重传第三次挥手报文达到 2 时，由于 <code>tcp_orphan_retries</code> 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。</li>
<li>客户端在收到第三次挥手后，就会进入 <code>TIME_WAIT</code> 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。</li>
</ul>
<h4 id="关于TIME-WAIT"><a href="#关于TIME-WAIT" class="headerlink" title="关于TIME_WAIT"></a>关于<code>TIME_WAIT</code></h4><h5 id="为什么-TIME-WAIT-等待的时间是-2MSL？"><a href="#为什么-TIME-WAIT-等待的时间是-2MSL？" class="headerlink" title="为什么 TIME_WAIT 等待的时间是 2MSL？"></a>为什么 <code>TIME_WAIT</code> 等待的时间是 2MSL？</h5><p><code>MSL</code> 是 Maximum Segment Lifetime，<strong>报文最大生存时间</strong>，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p>
<p><strong>TTL 的值一般是 64，Linux 将 MSL 设置为 30 秒，意味着 Linux 认为数据报文经过 64 个路由器的时间不会超过 30 秒，如果超过了，就认为报文已经消失在网络中了</strong>。</p>
<p><code>TIME_WAIT</code> 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以<strong>一来一回需要等待 2 倍的时间</strong>。</p>
<p>比如，如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会触发超时重发 FIN 报文，另一方接收到 FIN 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。</p>
<p>可以看到 <strong>2MSL时长</strong> 这其实是相当于<strong>至少允许报文丢失一次</strong>。比如，若 ACK 在一个 MSL 内丢失，这样被动方重发的 FIN 会在第 2 个 MSL 内到达，<code>TIME_WAIT</code> 状态的连接可以应对。</p>
<p>为什么不是 4 或者 8 MSL 的时长呢？你可以想象一个丢包率达到百分之一的糟糕网络，连续两次丢包的概率只有万分之一，这个概率实在是太小了，忽略它比解决它更具性价比。</p>
<p><code>2MSL</code> 的时间是<strong>从客户端接收到 FIN 后发送 ACK 开始计时的</strong>。如果在 <code>TIME_WAIT</code> 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 <strong>2MSL 时间将重新计时</strong>。</p>
<p>在 Linux 系统里 <code>2MSL</code> 默认是 <code>60</code> 秒，那么一个 <code>MSL</code> 也就是 <code>30</code> 秒。<strong>Linux 系统停留在 <code>TIME_WAIT</code> 的时间为固定的 60 秒</strong>。</p>
<p>其定义在 Linux 内核代码里的名称为 <code>TCP_TIMEWAIT_LEN</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TCP_TIMEWAIT_LEN (60*HZ) <span class="comment">/* how long to wait to destroy TIME-WAIT </span></span></span><br><span class="line"><span class="comment"><span class="meta">                                    state, about 60 seconds  */</span></span></span><br></pre></td></tr></table></figure>

<p>如果要修改 <code>TIME_WAIT</code> 的时间长度，只能修改 Linux 内核代码里 <code>TCP_TIMEWAIT_LEN</code> 的值，并重新编译 Linux 内核。</p>
<h5 id="为什么需要-TIME-WAIT-状态？"><a href="#为什么需要-TIME-WAIT-状态？" class="headerlink" title="为什么需要 TIME_WAIT 状态？"></a>为什么需要 <code>TIME_WAIT</code> 状态？</h5><p>主动发起关闭连接的一方，才会有 <code>TIME_WAIT</code> 状态。</p>
<p>需要 <code>TIME_WAIT</code> 状态，主要是两个原因：</p>
<ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收。</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭。</li>
</ul>
<h5 id="TIME-WAIT-过多有什么危害？"><a href="#TIME-WAIT-过多有什么危害？" class="headerlink" title="TIME_WAIT 过多有什么危害？"></a><code>TIME_WAIT</code> 过多有什么危害？</h5><p>过多的 <code>TIME_WAIT</code> 状态主要的危害有两种：</p>
<ul>
<li>第一是占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</li>
<li>第二是占用端口资源，端口资源也是有限的，一般可以开启的端口为 <code>32768～61000</code>，也可以通过 <code>net.ipv4.ip_local_port_range</code> 参数指定范围。</li>
</ul>
<p>客户端和服务端 <code>TIME_WAIT</code> 过多，造成的影响是不同的。</p>
<p><strong>如果客户端（发起连接方）的 <code>TIME_WAIT</code> 状态过多</strong>，占满了所有端口资源，那么就无法对「目的IP + 目的PORT」都一样的服务器发起连接了，但是被使用的端口，还是可以继续对另外一个服务器发起连接的。具体可以看这篇文章：<a target="_blank" rel="noopener" href="https://wenyuan.github.io/basic-skills/network/tcp-wave-exception/#%E8%BF%98%E6%B2%A1%E5%86%99">客户端的端口可以重复使用吗？</a></p>
<p>因此，客户端（发起连接方）都是和「目的IP + 目的PORT 」都一样的服务器建立连接的话，当客户端的 <code>TIME_WAIT</code> 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的IP + 目的PORT」都一样的服务器建立连接了。</p>
<p>不过，即使是在这种场景下，只要连接的是不同的服务器，端口是可以重复使用的，所以客户端还是可以向其他服务器发起连接的，这是因为内核在定位一个连接的时候，是通过四元组（源IP、源端口、目的IP、目的端口）信息来定位的，并不会因为客户端的端口一样，而导致连接冲突。</p>
<p><strong>如果服务端（发起连接方）的 <code>TIME_WAIT</code> 状态过多</strong>，并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等。</p>
<h4 id="如何优化-TIME-WAIT？"><a href="#如何优化-TIME-WAIT？" class="headerlink" title="如何优化 TIME_WAIT？"></a>如何优化 <code>TIME_WAIT</code>？</h4><p>这里给出优化 <code>TIME_WAIT</code> 的几个方式，都是有利有弊：</p>
<ul>
<li>打开 <code>net.ipv4.tcp_tw_reuse</code> 和 <code>net.ipv4.tcp_timestamps</code> 选项。</li>
<li><code>net.ipv4.tcp_max_tw_buckets</code></li>
<li>程序中使用 <code>SO_LINGER</code>，应用强制使用 <code>RST</code> 关闭。</li>
</ul>
<p><strong>1）方式一：<code>net.ipv4.tcp_tw_reuse</code> 和 <code>tcp_timestamps</code></strong></p>
<p>如下的 Linux 内核参数开启后，则可以<strong>复用处于 <code>TIME_WAIT</code> 的 socket 为新的连接所用</strong>。</p>
<p>有一点需要注意的是，<strong><code>tcp_tw_reuse</code> 功能只能用客户端（连接发起方），因为开启了该功能，在调用 <code>connect()</code> 函数时，内核会随机找一个 <code>time_wait</code> 状态超过 <code>1</code> 秒的连接给新的连接复用</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br></pre></td></tr></table></figure>

<p>使用这个选项，还有一个前提，需要打开对 TCP 时间戳的支持，即</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_timestamps=1（默认即为 1）</span><br></pre></td></tr></table></figure>

<p>这个时间戳的字段是在 TCP 头部的「选项」里，它由一共 8 个字节表示时间戳，其中第一个 4 字节字段用来保存发送该数据包的时间，第二个 4 字节字段用来保存最近一次接收对方发送到达数据的时间。</p>
<p>由于引入了时间戳，我们在前面提到的 <code>2MSL</code> 问题就不复存在了，因为重复的数据包会因为时间戳过期被自然丢弃。</p>
<p><strong>2）方式二：<code>net.ipv4.tcp_max_tw_buckets</code></strong></p>
<p>这个值默认为 18000，<strong>当系统中处于 <code>TIME_WAIT</code> 的连接一旦超过这个值时，系统就会将后面的 <code>TIME_WAIT</code> 连接状态重置</strong>，这个方法比较暴力。</p>
<p><strong>3）方式三：程序中使用 <code>SO_LINGER</code></strong></p>
<p>我们可以通过设置 socket 选项，来设置调用 close 关闭连接行为。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct linger so_linger;</span><br><span class="line">so_linger.l_onoff = 1;</span><br><span class="line">so_linger.l_linger = 0;</span><br><span class="line">setsockopt(s, SOL_SOCKET, SO_LINGER, &amp;so_linger,sizeof(so_linger));</span><br></pre></td></tr></table></figure>

<p>如果 <code>l_onoff</code> 为非 0， 且 <code>l_linger</code> 值为 0，那么调用 <code>close</code> 后，会立该发送一个 <code>RST</code> 标志给对端，该 TCP 连接将跳过四次挥手，也就跳过了 <code>TIME_WAIT</code> 状态，直接关闭。</p>
<p>但这为跨越 <code>TIME_WAIT</code> 状态提供了一个可能，不过是一个非常危险的行为，不值得提倡。</p>
<p>前面介绍的方法都是试图越过 <code>TIME_WAIT</code> 状态的，这样其实不太好。虽然 <code>TIME_WAIT</code> 状态持续的时间是有一点长，显得很不友好，但是它被设计来就是用来避免发生乱七八糟的事情。</p>
<p>所以更好的方法应该是：</p>
<p><strong>如果服务端要避免过多的 <code>TIME_WAIT</code> 状态的连接，就永远不要主动断开连接，让客户端去断开，由分布在各处的客户端去承受 <code>TIME_WAIT</code></strong>。</p>
<h3 id="TCP-重传机制"><a href="#TCP-重传机制" class="headerlink" title="TCP 重传机制"></a>TCP 重传机制</h3><h4 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h4><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，如果还没有收到对方的ACK确认应答报文，就会重发该数据，也就是我们常说的超时重传。</p>
<p>那么这个指定的时间，应该是多久比较合适呢？<br> 这里先介绍两个概念：<code>RTT</code>和<code>RTO</code></p>
<ul>
<li><code>RTT</code>(Round-Trip Time) 往返时延，指的是数据发送时刻到接收到确认的时刻的差值，也就是包的往返时间</li>
<li><code>RTO</code>(Retransmission Timeout)，就是超时重传时间。</li>
</ul>
<p>通常<code>RTO</code>应该略大于<code>RTT</code>：</p>
<ul>
<li>如果<code>RTO</code>太短，有可能数据没有丢失就重发，增加网络拥塞。</li>
<li>如果<code>RTO</code>太长，重发就慢，性能差。</li>
</ul>
<p>由于网络的不稳定，<code>RTT</code>是经常变化的，导致<code>RTO</code>也会是一个动态变化的值。</p>
<p>如果超时重发的数据，再次超时的话，下一次重传的时间间隔则会加倍。<br> 超时重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？</p>
<p>TCP用<strong>快速重传</strong>机制来解决超时重发的时间等待。</p>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>发送方发包的时候，并不总是等待ACK的响应再发送下一个包，而是会在窗口大小内，连续发多个包：</p>
<p>如果其中一个包丢失了，而后续的包到达时，接收方会发丢失的包的ACK给发送方。当发送方连接收到三个相同的ACK时，就知道这个包丢失了，于是不用等重传定时，直接就可以重新发送了</p>
<h4 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h4><p>快速重传机制解决了超时时间的问题，但是它面临着另外一个问题：那就是重传的时候，是重传一个包，还是重传所有的包？像上面的例子，客户端发出19个包，当触发快速重传的时候，客户端只知道第2个包丢失了，那其他包是否丢失，客户端并不清楚，这时候有两种选择：</p>
<ul>
<li>重发2~19所有的包，显然会造成数据的浪费，因为后面17个包都是已经收到的。</li>
<li>只重发第2个包。但如果第3个包也丢失的话，那么又得等到三次ACK才能重发第3个包，效率较低。</li>
</ul>
<p>这时候，<code>SACK(Selective Acknowledgment)</code>，选择性确认，就可以起作用了。<br> 这种方式需要在TCP头部<strong>选项</strong>字段里加一个<code>SACK</code>的选项，它可以将已收到的数据的信息发送给发送方 ，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据了 。</p>
<p>在这个例子中，<code>SACK</code>表示<code>15870601~15873581</code>之间的数据是已经收到的，所以客户端只需要重发<code>15869201~15870600</code>之间的数据就行了。</p>
<p>由于TCP头部大小的限制，在选项中最多能支持四组SACK的数据</p>
<h3 id="TCP的拥塞控制机制"><a href="#TCP的拥塞控制机制" class="headerlink" title="TCP的拥塞控制机制"></a>TCP的拥塞控制机制</h3><p>TCP的拥塞控制机制主要是以下四种机制：</p>
<ul>
<li>慢启动（慢开始）</li>
<li>拥塞避免</li>
<li>快速重传</li>
<li>快速恢复</li>
</ul>
<p><strong>（1）慢启动（慢开始）</strong></p>
<ul>
<li><p>在开始发送的时候设置cwnd &#x3D; 1（cwnd指的是拥塞窗口）</p>
</li>
<li><p>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</p>
</li>
<li><p>为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)</p>
</li>
<li><ul>
<li>当cnwd &lt; ssthresh，使用慢开始算法</li>
<li>当cnwd &#x3D; ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li>
<li>当cnwd &gt; ssthresh，使用拥塞避免算法</li>
</ul>
</li>
</ul>
<p><strong>（2）拥塞避免</strong></p>
<ul>
<li>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。</li>
<li>思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一</li>
<li>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:<br><img src="/../img/20200802172257514.png" alt="img"><br>其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。</li>
</ul>
<p><strong>（3）快速重传</strong></p>
<ul>
<li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>
<li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</li>
</ul>
<p><strong>（4）快速恢复</strong></p>
<ul>
<li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li>
<li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。<br><img src="/../img/2020080217284188.png" alt="img"></li>
</ul>
<h3 id="TCP的流量控制机制"><a href="#TCP的流量控制机制" class="headerlink" title="TCP的流量控制机制"></a>TCP的流量控制机制</h3><p>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的<strong>滑动窗口</strong>进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p>
<ul>
<li><p>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</p>
</li>
<li><p>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）</p>
</li>
<li><p>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</p>
</li>
<li><p>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。</p>
</li>
</ul>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。</p>
<p>HTTP协议具有以下<strong>优点</strong>：</p>
<ul>
<li>支持客户端&#x2F;服务器模式</li>
<li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li>
<li><strong>无连接</strong>：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li>
<li><strong>无状态</strong>：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</li>
<li><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li>
</ul>
<p>HTTP协议具有以下<strong>缺点</strong>：</p>
<ul>
<li>**无状态：**HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</li>
<li>**明文传输：**协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。</li>
<li><strong>不安全</strong></li>
</ul>
<p>（1）通信使用明文（不加密），内容可能会被窃听；</p>
<p>（2）不验证通信方的身份，因此有可能遭遇伪装；</p>
<p>（3）无法证明报文的完整性，所以有可能已遭篡改；</p>
<h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><p>请求报⽂有4部分组成: </p>
<ul>
<li><p>请求⾏ ：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET &#x2F;index.html HTTP&#x2F;1.1。 </p>
</li>
<li><p>请求头部 </p>
</li>
<li><p>请求头部：</p>
<p>由关键字&#x2F;值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔  </p>
<ul>
<li>User-Agent：产⽣请求的浏览器类型。 </li>
<li>Accept：客户端可识别的内容类型列表。 </li>
<li>Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机</li>
</ul>
</li>
<li><p>空⾏</p>
</li>
<li><p>请求体 ：post put等请求携带的数据</p>
</li>
</ul>
<p><strong>请求方法：</strong></p>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>get</th>
<th>post</th>
<th>put</th>
</tr>
</thead>
<tbody><tr>
<td><strong>幂等</strong></td>
<td>Get 请求用于对服务器资源不会产生影响</td>
<td>更新服务器资源</td>
<td>创建服务器资源</td>
</tr>
<tr>
<td><strong>缓存</strong></td>
<td>请求缓存</td>
<td>默认不缓存</td>
<td>默认不缓存</td>
</tr>
<tr>
<td><strong>数据位置</strong></td>
<td>URL</td>
<td>请求体body</td>
<td>请求体body</td>
</tr>
<tr>
<td><strong>浏览器刷新</strong></td>
<td>回车&#x2F;刷新无害</td>
<td>重复提交会触发警告（需确认是否重新发送）</td>
<td></td>
</tr>
</tbody></table>
<p><strong>options方法</strong></p>
<p>OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。</p>
<p>OPTIONS方法是用于请求获得由<code>Request-URI</code>标识的资源在请求&#x2F;响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</p>
<p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p>
<ul>
<li>获取服务器支持的所有HTTP请求方法；</li>
<li>用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限</li>
</ul>
<p><strong>简单请求 (Simple Request)</strong></p>
<p>一个请求必须<strong>同时满足以下所有条件</strong>，才是简单请求：</p>
<ol>
<li><strong>HTTP 方法限制为以下三种之一：</strong><ul>
<li><code>GET</code></li>
<li><code>HEAD</code></li>
<li><code>POST</code></li>
</ul>
</li>
<li><strong>HTTP 头部限制 (由浏览器自动设置的头除外)：</strong> 只能包含以下<strong>安全列表</strong>中的请求头字段：<ul>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Content-Language</code></li>
<li><code>Content-Type</code> (但值有额外限制，见下一点)</li>
<li><code>DPR</code></li>
<li><code>Downlink</code></li>
<li><code>Save-Data</code></li>
<li><code>Viewport-Width</code></li>
<li><code>Width</code></li>
<li>… (这个列表相对固定，主要是浏览器自动设置或非常基础的头部)</li>
</ul>
</li>
<li><strong><code>Content-Type</code> 头的值限制为以下三种之一：</strong><ul>
<li><code>application/x-www-form-urlencoded</code></li>
<li><code>multipart/form-data</code></li>
<li><code>text/plain</code></li>
</ul>
</li>
</ol>
<p><strong>🌟 简单请求的特点：</strong></p>
<ul>
<li>浏览器会<strong>直接发送</strong>实际请求（GET&#x2F;POST等）。</li>
<li>在请求中自动添加 <code>Origin</code> 头，表明来源。</li>
<li>服务器需要在响应中包含至少 <code>Access-Control-Allow-Origin</code> 头（值可以是 <code>*</code> 或具体的请求来源域）来允许跨域。如果涉及凭据（如 Cookies），还需要 <code>Access-Control-Allow-Credentials: true</code>。</li>
<li><strong>常见例子：</strong><ul>
<li>使用原生 HTML <code>&lt;form&gt;</code> 提交的 POST 请求（<code>enctype</code> 为上述三种之一）。</li>
<li>使用原生 <code>XMLHttpRequest</code> 或 <code>fetch</code> 发起的 GET 请求（不带自定义头，<code>Content-Type</code> 为上述三种之一）。</li>
<li>使用 <code>fetch</code> 发起的 POST 请求，请求体是 <code>FormData</code> 或 URL 编码字符串，且没有设置自定义头。</li>
</ul>
</li>
</ul>
<p>🚧 <strong>非简单请求 (Preflighted Request &#x2F; 预检请求)</strong></p>
<p>如果一个请求<strong>不满足</strong>上述简单请求的<strong>任何一个条件</strong>，它就是非简单请求（预检请求）。</p>
<p><strong>触发非简单请求的常见情况：</strong></p>
<ol>
<li><strong>使用了 <code>GET</code>, <code>HEAD</code>, <code>POST</code> 之外的 HTTP 方法：</strong><ul>
<li><code>PUT</code></li>
<li><code>DELETE</code></li>
<li><code>PATCH</code></li>
<li><code>CONNECT</code></li>
<li><code>OPTIONS</code> (虽然 OPTIONS 本身用于预检，但其他方法触发预检时用 OPTIONS)</li>
<li><code>TRACE</code></li>
<li><strong>或者任何自定义方法（如 <code>PURGE</code>）</strong></li>
</ul>
</li>
<li><strong>设置了不在“安全列表”中的请求头：</strong><ul>
<li>任何<strong>自定义请求头</strong>（如 <code>X-Auth-Token</code>, <code>X-Requested-With</code>）。</li>
<li>一些不在安全列表中的标准头（如 <code>Authorization</code>, <code>Content-Type</code> 的值超出简单请求范围）。</li>
</ul>
</li>
<li><strong><code>Content-Type</code> 的值不是简单请求允许的三种：</strong><ul>
<li>最常见的就是 <code>application/json</code>。</li>
<li><code>application/xml</code> 或 <code>text/xml</code> 等。</li>
<li>任何其他非 <code>text/plain</code>, <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code> 的值。</li>
</ul>
</li>
</ol>
<p><strong>非简单请求的特点：</strong></p>
<ul>
<li><strong>浏览器会先自动发送一个 <code>OPTIONS</code> 方法的“预检请求”</strong> 到目标服务器。</li>
<li>预检请求携带关键头信息询问服务器：<ul>
<li><code>Origin</code>: 请求来源。</li>
<li><code>Access-Control-Request-Method</code>: 后续实际请求想要使用的 HTTP 方法（如 PUT, DELETE）。</li>
<li><code>Access-Control-Request-Headers</code>: 后续实际请求想要携带的自定义请求头列表（如 <code>Content-Type</code>, <code>Authorization</code>）。</li>
</ul>
</li>
<li><strong>服务器必须响应预检请求 (<code>OPTIONS</code>)：</strong><ul>
<li>返回状态码通常是 <code>204 No Content</code> 或 <code>200 OK</code>。</li>
<li><strong>必须包含关键的 CORS 响应头：</strong><ul>
<li><code>Access-Control-Allow-Origin</code>: 允许的来源（<code>*</code> 或具体域）。</li>
<li><code>Access-Control-Allow-Methods</code>: 允许的实际请求方法（如 <code>PUT, DELETE</code>）。</li>
<li><code>Access-Control-Allow-Headers</code>: 允许的实际请求头（如 <code>Content-Type, Authorization</code>）。</li>
<li>(可选) <code>Access-Control-Allow-Credentials: true</code>（如需凭据）。</li>
<li>(可选) <code>Access-Control-Max-Age</code>: 预检结果缓存时间（秒）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>浏览器决策：</strong><ul>
<li>如果预检响应头<strong>符合</strong>后续实际请求的要求（方法、头、来源都被允许），浏览器才会<strong>接着发送真正的实际请求</strong>（PUT, DELETE, 带 JSON 的 POST 等）。</li>
<li>如果预检响应头<strong>拒绝</strong>了实际请求（比如没包含某个方法或头），浏览器会<strong>阻止</strong>后续实际请求的发送，并在控制台报 CORS 错误。</li>
</ul>
</li>
<li><strong>常见例子：</strong><ul>
<li>发送 <code>application/json</code> 数据的 POST&#x2F;PUT 请求。</li>
<li>发送 DELETE 请求。</li>
<li>在请求头中添加 <code>Authorization: Bearer &lt;token&gt;</code> 进行认证。</li>
<li>发送任何自定义 HTTP 方法的请求。</li>
<li>使用自定义头如 <code>X-Custom-Header</code>。</li>
</ul>
</li>
</ul>
<h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><p>请求报⽂有4部分组成: </p>
<ul>
<li>响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP&#x2F;1.1 200 OK 。 </li>
<li>响应头：响应部⾸组成 </li>
<li>空行</li>
<li>响应体：服务器响应的数据</li>
</ul>
<h2 id="HTTP-版本演进对比"><a href="#HTTP-版本演进对比" class="headerlink" title="HTTP 版本演进对比"></a>HTTP 版本演进对比</h2><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>HTTP&#x2F;0.9 (1991)</strong></th>
<th align="left"><strong>HTTP&#x2F;1.0 (1996)</strong></th>
<th align="left"><strong>HTTP&#x2F;1.1 (1997&#x2F;1999)</strong></th>
<th align="left"><strong>HTTP&#x2F;2 (2015)</strong></th>
<th align="left"><strong>HTTP&#x2F;3 (2022)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>协议基础</strong></td>
<td align="left">单行文本协议</td>
<td align="left">文本协议 + 头部</td>
<td align="left">文本协议（增强版）</td>
<td align="left">二进制分帧协议</td>
<td align="left"><strong>基于 QUIC 的 UDP 协议</strong></td>
</tr>
<tr>
<td align="left"><strong>连接方式</strong></td>
<td align="left">⚡ 单请求后立即关闭</td>
<td align="left">⚡ 默认短连接（可手动设 <code>Connection: keep-alive</code>）</td>
<td align="left">✅ <strong>默认长连接</strong>（持久化）</td>
<td align="left">✅ 多路复用单连接</td>
<td align="left">✅ 多路复用 + <strong>连接迁移</strong></td>
</tr>
<tr>
<td align="left"><strong>并行请求</strong></td>
<td align="left">❌ 不支持</td>
<td align="left">❌ 不支持（串行）</td>
<td align="left">🟡 有限并行（6-8个&#x2F;域名，需域名分片）</td>
<td align="left">✅ <strong>真并行</strong>（单连接多流）</td>
<td align="left">✅ <strong>零队头阻塞</strong>（流独立）</td>
</tr>
<tr>
<td align="left"><strong>头部传输</strong></td>
<td align="left">❌ 无头部</td>
<td align="left">✅ 文本头部（未压缩）</td>
<td align="left">✅ 文本头部（未压缩）</td>
<td align="left">✅ <strong>HPACK 压缩</strong>（二进制）</td>
<td align="left">✅ <strong>QPACK 压缩</strong>（动态表）</td>
</tr>
<tr>
<td align="left"><strong>数据传输</strong></td>
<td align="left">❌ 仅文本（无类型&#x2F;长度）</td>
<td align="left">✅ 支持二进制（<code>Content-Type</code>）</td>
<td align="left">✅ 支持分块传输（<code>Transfer-Encoding: chunked</code>）</td>
<td align="left">✅ 二进制帧（<code>DATA</code>帧）</td>
<td align="left">✅ 二进制帧（<code>STREAM</code>帧）</td>
</tr>
<tr>
<td align="left"><strong>关键性能优化</strong></td>
<td align="left">-</td>
<td align="left">-</td>
<td align="left">🔹 管道化（易队头阻塞） 🔹 缓存控制（<code>Cache-Control</code>）</td>
<td align="left">🔹 <strong>多路复用</strong> 🔹 服务器推送（<code>PUSH_PROMISE</code>）</td>
<td align="left">🔹 <strong>0-RTT 快速握手</strong> 🔹 改进的丢包恢复</td>
</tr>
<tr>
<td align="left"><strong>队头阻塞问题</strong></td>
<td align="left">❌ 无（单请求）</td>
<td align="left">❌ 无（串行）</td>
<td align="left">🔴 <strong>存在</strong>（响应必须顺序返回）</td>
<td align="left">🔴 <strong>TCP 层队头阻塞</strong></td>
<td align="left">✅ <strong>彻底解决</strong>（QUIC 流隔离）</td>
</tr>
<tr>
<td align="left"><strong>安全性</strong></td>
<td align="left">❌ 无加密</td>
<td align="left">❌ 无强制加密</td>
<td align="left">❌ 无强制加密</td>
<td align="left">⚠️ 事实需 HTTPS（浏览器强制）</td>
<td align="left">✅ <strong>内置 TLS 1.3</strong></td>
</tr>
<tr>
<td align="left"><strong>握手延迟</strong></td>
<td align="left">1× RTT（TCP）</td>
<td align="left">1× RTT（TCP）</td>
<td align="left">1× RTT（TCP）</td>
<td align="left">1~3× RTT（TCP+TLS）</td>
<td align="left">✅ <strong>0~1× RTT</strong>（QUIC 0-RTT）</td>
</tr>
<tr>
<td align="left"><strong>典型请求示例</strong></td>
<td align="left"><code>GET /page</code></td>
<td align="left"><code>&lt;br&gt;GET /page HTTP/1.0&lt;br&gt;Host: example.com&lt;br&gt;</code></td>
<td align="left"><code>&lt;br&gt;GET /page HTTP/1.1&lt;br&gt;Host: example.com&lt;br&gt;Connection: keep-alive&lt;br&gt;</code></td>
<td align="left">二进制帧（含流ID、头部块等）</td>
<td align="left">QUIC 数据包（含连接ID、流ID）</td>
</tr>
<tr>
<td align="left"><strong>核心缺陷</strong></td>
<td align="left">功能极简</td>
<td align="left">连接开销大</td>
<td align="left">队头阻塞 + 头部冗余</td>
<td align="left">TCP 队头阻塞</td>
<td align="left">部署复杂度高</td>
</tr>
</tbody></table>
<hr>
<h3 id="关键特性详解"><a href="#关键特性详解" class="headerlink" title="关键特性详解"></a>关键特性详解</h3><h4 id="1-HTTP-1-1-核心改进"><a href="#1-HTTP-1-1-核心改进" class="headerlink" title="1. HTTP&#x2F;1.1 核心改进"></a>1. <strong>HTTP&#x2F;1.1 核心改进</strong></h4><ul>
<li><strong>持久连接</strong>：复用 TCP 连接（省去重复握手开销）。</li>
<li><strong>管道化（Pipelining）</strong>：允许连续发送多个请求（但响应必须按序返回 → <strong>队头阻塞</strong>）。</li>
<li><strong>分块传输</strong>：支持流式大数据传输（<code>Transfer-Encoding: chunked</code>）。</li>
<li><strong>缓存控制</strong>：<code>Cache-Control</code>、<code>ETag</code> 等精细化缓存策略。</li>
</ul>
<h4 id="2-HTTP-2-革命性突破"><a href="#2-HTTP-2-革命性突破" class="headerlink" title="2. HTTP&#x2F;2 革命性突破"></a>2. <strong>HTTP&#x2F;2 革命性突破</strong></h4><ul>
<li><strong>二进制分帧层</strong>：<ul>
<li>将消息拆分为 <strong>HEADERS 帧</strong>和 <strong>DATA 帧</strong>，通过<strong>流标识符（Stream ID）</strong> 重组。</li>
</ul>
</li>
<li><strong>多路复用（Multiplexing）</strong>：<ul>
<li>单 TCP 连接上并行传输多个流，解决 HTTP&#x2F;1.1 并发限制。</li>
</ul>
</li>
<li><strong>头部压缩（HPACK）</strong>：<ul>
<li>静态霍夫曼编码 + 动态表减少头部冗余（尤其 Cookie）。</li>
</ul>
</li>
<li><strong>服务器推送（Server Push）</strong>：<ul>
<li>主动推送关联资源（如 CSS&#x2F;JS）减少客户端请求。</li>
</ul>
</li>
</ul>
<h4 id="3-HTTP-3-的底层革新"><a href="#3-HTTP-3-的底层革新" class="headerlink" title="3. HTTP&#x2F;3 的底层革新"></a>3. <strong>HTTP&#x2F;3 的底层革新</strong></h4><ul>
<li><strong>QUIC 协议取代 TCP</strong>：<ul>
<li>基于 UDP 实现可靠传输，内置加密（TLS 1.3）和拥塞控制。</li>
</ul>
</li>
<li><strong>连接迁移</strong>：<ul>
<li>切换网络时（WiFi→4G）<strong>连接 ID 不变</strong>，无需重新握手。</li>
</ul>
</li>
<li><strong>零 RTT 建连</strong>：<ul>
<li>首次访问 1-RTT，后续访问 0-RTT（类似 TLS 会话恢复）。</li>
</ul>
</li>
<li><strong>彻底解决队头阻塞</strong>：<ul>
<li>QUIC 的流（Stream）独立传输，丢包只影响当前</li>
</ul>
</li>
</ul>
<p>HTTP&#x2F;3 基于 UDP 实现可靠传输的核心技术是 <strong>QUIC 协议</strong>（Quick UDP Internet Connections）。QUIC 在 UDP 之上重建了可靠性机制，同时融合了 TCP 和 TLS 的优点。以下是其实现可靠传输的关键技术：</p>
<hr>
<h3 id="一、QUIC-的核心可靠性机制"><a href="#一、QUIC-的核心可靠性机制" class="headerlink" title="一、QUIC 的核心可靠性机制"></a>一、QUIC 的核心可靠性机制</h3><h4 id="1-数据包编号机制"><a href="#1-数据包编号机制" class="headerlink" title="1. 数据包编号机制"></a>1. <strong>数据包编号机制</strong></h4><ul>
<li><p><strong>单调递增的 Packet Number</strong>：</p>
<ul>
<li>每个数据包都有唯一递增编号（不同于 TCP 序列号）</li>
<li>解决 TCP 重传歧义问题（重传包使用新编号）</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<p>plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始发送：Packet #1, #2, #3</span><br><span class="line">丢包重传：重传的包变为 Packet #4（而非复用旧编号）</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-改进的确认机制"><a href="#2-改进的确认机制" class="headerlink" title="2. 改进的确认机制"></a>2. <strong>改进的确认机制</strong></h4><ul>
<li><strong>ACK 帧带延迟信息</strong>：<ul>
<li>携带精确的接收时间戳（用于 RTT 计算）</li>
<li>支持<strong>选择性确认（SACK）</strong>，明确告知丢失范围</li>
</ul>
</li>
<li><strong>显式丢包通知</strong>：<ul>
<li>通过 NACK（Negative ACK）快速报告丢包</li>
</ul>
</li>
</ul>
<h4 id="3-前向纠错（FEC）"><a href="#3-前向纠错（FEC）" class="headerlink" title="3. 前向纠错（FEC）"></a>3. <strong>前向纠错（FEC）</strong></h4><p>图表</p>
<p>代码</p>
<ul>
<li>发送冗余的 FEC 包（异或校验包）</li>
<li>丢失单个包时可通过其他包+FEC包重建数据</li>
<li>减少小规模丢包时的重传</li>
</ul>
<hr>
<h3 id="二、连接管理机制"><a href="#二、连接管理机制" class="headerlink" title="二、连接管理机制"></a>二、连接管理机制</h3><h4 id="1-连接迁移"><a href="#1-连接迁移" class="headerlink" title="1. 连接迁移"></a>1. <strong>连接迁移</strong></h4><ul>
<li><p><strong>Connection ID 标识连接</strong>：</p>
<p>javascript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 连接标识（IP变化时仍有效）</span><br><span class="line">connection_id = 0x8a4f3b2c</span><br></pre></td></tr></table></figure>
</li>
<li><p>当客户端 IP 改变（如 WiFi 切 4G），TCP 需重建连接，QUIC 保持连接</p>
</li>
</ul>
<h4 id="2-0-RTT-快速重启"><a href="#2-0-RTT-快速重启" class="headerlink" title="2. 0-RTT 快速重启"></a>2. <strong>0-RTT 快速重启</strong></h4><ul>
<li>基于 TLS 1.3 的会话恢复</li>
<li>之前连接过的客户端可在首次包中携带数据</li>
</ul>
<hr>
<h3 id="三、多路复用与流控制"><a href="#三、多路复用与流控制" class="headerlink" title="三、多路复用与流控制"></a>三、多路复用与流控制</h3><h4 id="1-流（Stream）隔离"><a href="#1-流（Stream）隔离" class="headerlink" title="1. 流（Stream）隔离"></a>1. <strong>流（Stream）隔离</strong></h4><p>图表</p>
<p>代码</p>
<ul>
<li>单个 QUIC 连接支持多个独立 Stream</li>
<li><strong>关键优势</strong>：一个 Stream 丢包不影响其他 Stream（解决 TCP 队头阻塞）</li>
</ul>
<h4 id="2-分级流量控制"><a href="#2-分级流量控制" class="headerlink" title="2. 分级流量控制"></a>2. <strong>分级流量控制</strong></h4><ul>
<li><p>两层控制：</p>
<ol>
<li><strong>连接级控制</strong>（总带宽限制）</li>
<li><strong>流级控制</strong>（每个流的独立窗口）</li>
</ol>
</li>
<li><p>动态窗口调整算法：</p>
<p>c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码：窗口增长逻辑</span><br><span class="line">if (no_loss_event) &#123;</span><br><span class="line">    window_size *= 1.5; // 指数增长</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    window_size *= 0.7; // 乘性减少</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="四、安全与拥塞控制"><a href="#四、安全与拥塞控制" class="headerlink" title="四、安全与拥塞控制"></a>四、安全与拥塞控制</h3><h4 id="1-深度集成加密"><a href="#1-深度集成加密" class="headerlink" title="1. 深度集成加密"></a>1. <strong>深度集成加密</strong></h4><ul>
<li><strong>头部加密</strong>：连包类型都加密（防中间设备干扰）</li>
<li><strong>认证加密</strong>：使用 AES-GCM&#x2F;ChaCha20-Poly1305</li>
<li><strong>密钥轮换</strong>：每个包使用不同密钥</li>
</ul>
<h4 id="2-智能拥塞控制"><a href="#2-智能拥塞控制" class="headerlink" title="2. 智能拥塞控制"></a>2. <strong>智能拥塞控制</strong></h4><ul>
<li><strong>可插拔算法</strong>：<ul>
<li>默认使用 <strong>Cubic</strong>（类似 TCP）</li>
<li>可选 <strong>BBR</strong>（Google 的 Bottleneck Bandwidth and RTT）</li>
</ul>
</li>
<li><strong>带宽预测模型</strong>：<br>BDP&#x3D;Bmax×RTTmin<em>B<strong>D</strong>P</em>&#x3D;<em>B<strong>ma</strong>x</em>​×<em>RT<strong>T</strong>min</em>​<br>（BDP：带宽延迟积，决定最优窗口大小）</li>
</ul>
<hr>
<h3 id="五、QUIC-vs-TCP-可靠性对比"><a href="#五、QUIC-vs-TCP-可靠性对比" class="headerlink" title="五、QUIC vs TCP 可靠性对比"></a>五、QUIC vs TCP 可靠性对比</h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>TCP</strong></th>
<th align="left"><strong>QUIC over UDP</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">握手延迟</td>
<td align="left">3-RTT（TCP+TLS）</td>
<td align="left">1-RTT（0-RTT 可选）</td>
</tr>
<tr>
<td align="left">队头阻塞</td>
<td align="left">有（单流阻塞）</td>
<td align="left">无（多流隔离）</td>
</tr>
<tr>
<td align="left">重传歧义</td>
<td align="left">有（相同序列号）</td>
<td align="left">无（唯一递增包号）</td>
</tr>
<tr>
<td align="left">连接迁移</td>
<td align="left">不支持</td>
<td align="left">原生支持</td>
</tr>
<tr>
<td align="left">前向纠错</td>
<td align="left">无</td>
<td align="left">可选支持</td>
</tr>
<tr>
<td align="left">加密范围</td>
<td align="left">仅加密负载</td>
<td align="left">加密头部+负载</td>
</tr>
</tbody></table>
<hr>
<h3 id="六、典型数据传输流程"><a href="#六、典型数据传输流程" class="headerlink" title="六、典型数据传输流程"></a>六、典型数据传输流程</h3><p>以文件下载为例：</p>
<ol>
<li><p><strong>连接建立</strong>：</p>
<p>plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Client → Server: Client Hello (携带 0-RTT 数据)</span><br><span class="line">Server → Client: Server Hello + ACK</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>数据传输</strong>：</p>
<p>plaintext</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Client: 发送 Stream1 数据包#1-#10</span><br><span class="line">Server: 收到 #1,#3-#10 → 回复 ACK(范围) + NACK(#2)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>丢包恢复</strong>：</p>
<ul>
<li>选项1：快速重传（收到3个重复ACK后立即重传#2）</li>
<li>选项2：FEC重建（若配置了前向纠错）</li>
</ul>
</li>
<li><p><strong>拥塞响应</strong>：</p>
<ul>
<li>检测到丢包 → 窗口减半</li>
<li>持续无丢包 → 窗口指数增长</li>
</ul>
</li>
</ol>
<hr>
<h3 id="七、技术挑战与解决方案"><a href="#七、技术挑战与解决方案" class="headerlink" title="七、技术挑战与解决方案"></a>七、技术挑战与解决方案</h3><table>
<thead>
<tr>
<th align="left"><strong>挑战</strong></th>
<th align="left"><strong>QUIC 解决方案</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">UDP 不可靠</td>
<td align="left">自定义ACK&#x2F;NACK+重传</td>
</tr>
<tr>
<td align="left">NAT 防火墙阻挡UDP</td>
<td align="left">回落TCP（HTTP&#x2F;2备用）</td>
</tr>
<tr>
<td align="left">中间设备干扰UDP</td>
<td align="left">加密所有头部信息</td>
</tr>
<tr>
<td align="left">操作系统内核限制</td>
<td align="left">用户空间实现（无需内核升级）</td>
</tr>
<tr>
<td align="left">移动网络切换断连</td>
<td align="left">Connection ID 保持连接</td>
</tr>
</tbody></table>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>HTTP&#x2F;3 通过 QUIC 在 UDP 上实现可靠传输的关键是：</p>
<ol>
<li><strong>重建可靠性基础</strong>：包编号、ACK&#x2F;NACK、重传</li>
<li><strong>创新设计</strong>：流隔离、连接迁移、0-RTT</li>
<li><strong>深度安全集成</strong>：全加密、密钥轮换</li>
<li><strong>灵活拥塞控制</strong>：可插拔算法、带宽预测</li>
</ol>
<p>这使得 QUIC 在保留 UDP 高效性的同时，获得了比 TCP 更优的可靠性和性能，尤其在高丢包、移动网络环境下表现显著提升。</p>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS &#x3D; HTTP + TLS&#x2F;SSL，通过<strong>加密传输</strong>和<strong>身份认证</strong>保障安全。以下是完整连接过程（以 TLS 1.3 简化流程为例）：</p>
<hr>
<h3 id="🔗-HTTPS-连接建立流程"><a href="#🔗-HTTPS-连接建立流程" class="headerlink" title="🔗 HTTPS 连接建立流程"></a>🔗 <strong>HTTPS 连接建立流程</strong></h3><h4 id="阶段-1：TCP-三次握手（基础连接）"><a href="#阶段-1：TCP-三次握手（基础连接）" class="headerlink" title="阶段 1：TCP 三次握手（基础连接）"></a><strong>阶段 1：TCP 三次握手</strong>（基础连接）</h4><ol>
<li>客户端 → 服务器：<code>SYN</code></li>
<li>服务器 → 客户端：<code>SYN + ACK</code></li>
<li>客户端 → 服务器：<code>ACK</code><br>✅ <strong>此时建立 TCP 连接（未加密）</strong></li>
</ol>
<hr>
<h4 id="阶段-2：TLS-握手（核心安全层）"><a href="#阶段-2：TLS-握手（核心安全层）" class="headerlink" title="阶段 2：TLS 握手（核心安全层）"></a><strong>阶段 2：TLS 握手</strong>（核心安全层）</h4><h5 id="步骤-1：Client-Hello"><a href="#步骤-1：Client-Hello" class="headerlink" title="步骤 1：Client Hello"></a><strong>步骤 1：Client Hello</strong></h5><ul>
<li>客户端发送：<ul>
<li>支持的 TLS 版本</li>
<li>客户端随机数（Client Random）</li>
<li>支持的加密套件列表（如 <code>TLS_AES_128_GCM_SHA256</code>）</li>
</ul>
</li>
</ul>
<h5 id="步骤-2：Server-Hello"><a href="#步骤-2：Server-Hello" class="headerlink" title="步骤 2：Server Hello"></a><strong>步骤 2：Server Hello</strong></h5><ul>
<li>服务器响应：<ul>
<li>选定的 TLS 版本</li>
<li>服务器随机数（Server Random）</li>
<li>选定的加密套件</li>
<li><strong>🔑 服务器证书链</strong>（含公钥、域名、CA 签名）</li>
</ul>
</li>
</ul>
<h5 id="步骤-3：证书验证（关键安全步骤）"><a href="#步骤-3：证书验证（关键安全步骤）" class="headerlink" title="步骤 3：证书验证（关键安全步骤）"></a><strong>步骤 3：证书验证</strong>（关键安全步骤）</h5><ol>
<li>客户端验证证书：<ul>
<li>检查域名是否匹配</li>
<li>检查有效期</li>
<li><strong>验证 CA 签名链</strong>（详见下方 CA 验证机制）</li>
<li>查询 OCSP 或 CRL 确认未吊销</li>
</ul>
</li>
</ol>
<h5 id="步骤-4：密钥交换"><a href="#步骤-4：密钥交换" class="headerlink" title="步骤 4：密钥交换"></a><strong>步骤 4：密钥交换</strong></h5><ul>
<li><strong>非对称加密阶段</strong>（仅此阶段使用）：<ul>
<li>客户端生成 <strong>Pre-Master Secret</strong></li>
<li>用<strong>服务器证书公钥</strong>加密后发送 → 服务器</li>
</ul>
</li>
<li>服务器用<strong>私钥解密</strong>获取 Pre-Master Secret</li>
</ul>
<h5 id="步骤-5：生成会话密钥"><a href="#步骤-5：生成会话密钥" class="headerlink" title="步骤 5：生成会话密钥"></a><strong>步骤 5：生成会话密钥</strong></h5><ul>
<li><p>双方通过以下参数生成<strong>对称会话密钥</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Master Secret = PRF(Client Random + Server Random + Pre-Master Secret)  </span><br></pre></td></tr></table></figure>
</li>
<li><p>✅ <strong>会话密钥用于后续对称加密</strong></p>
</li>
</ul>
<h5 id="步骤-6：完成握手"><a href="#步骤-6：完成握手" class="headerlink" title="步骤 6：完成握手"></a><strong>步骤 6：完成握手</strong></h5><ul>
<li>双方发送 <code>Finished</code> 消息（用会话密钥加密）</li>
<li>验证握手完整性</li>
</ul>
<hr>
<h4 id="阶段-3：加密数据传输"><a href="#阶段-3：加密数据传输" class="headerlink" title="阶段 3：加密数据传输"></a><strong>阶段 3：加密数据传输</strong></h4><ul>
<li><p><strong>对称加密阶段</strong>（高效加密）：</p>
<ul>
<li><p>所有 HTTP 数据被拆分为 <strong>TLS Record</strong></p>
</li>
<li><p>使用会话密钥进行 AES&#x2F;GCM 加密传输</p>
</li>
<li><p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[加密后] 2F 8A 01 9C... → 传输 → 服务器解密为 &quot;GET /index.html HTTP/1.1&quot;  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h3 id="🛡️-CA-证书验证机制"><a href="#🛡️-CA-证书验证机制" class="headerlink" title="🛡️ CA 证书验证机制"></a>🛡️ <strong>CA 证书验证机制</strong></h3><p>证书验证是防范中间人攻击的核心：</p>
<ol>
<li><strong>证书链校验</strong>：<ul>
<li>服务器证书 → 中间 CA 证书 → 根 CA 证书</li>
<li>客户端用<strong>本地信任的根 CA 公钥</strong>验证签名链</li>
</ul>
</li>
<li><strong>吊销检查</strong>：<ul>
<li><strong>OCSP（在线证书状态协议）</strong>：实时查询证书状态</li>
<li><strong>CRL（证书吊销列表）</strong>：定期下载黑名单</li>
</ul>
</li>
<li><strong>扩展验证</strong>：<ul>
<li>EV 证书验证组织真实性（显示绿色企业名称）</li>
</ul>
</li>
</ol>
<hr>
<h3 id="⚠️-无响应时的处理策略"><a href="#⚠️-无响应时的处理策略" class="headerlink" title="⚠️ 无响应时的处理策略"></a>⚠️ <strong>无响应时的处理策略</strong></h3><p>TLS 协议内置超时重传机制：</p>
<table>
<thead>
<tr>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>处理方式</strong></th>
<th align="left">超时时间</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Client Hello 无响应</td>
<td align="left">客户端重发（指数退避算法）</td>
<td align="left">初始 1s → 最大 60s</td>
</tr>
<tr>
<td align="left">握手中途失败</td>
<td align="left">关闭连接并触发 <code>TLS Handshake Failed</code> 错误</td>
<td align="left">TCP 层决定</td>
</tr>
<tr>
<td align="left">应用数据传输超时</td>
<td align="left">TCP 重传机制触发</td>
<td align="left">动态 RTO 计算</td>
</tr>
</tbody></table>
<hr>
<h3 id="🛡️-防范中间人攻击（MitM）措施"><a href="#🛡️-防范中间人攻击（MitM）措施" class="headerlink" title="🛡️ 防范中间人攻击（MitM）措施"></a>🛡️ <strong>防范中间人攻击（MitM）措施</strong></h3><p>HTTPS 通过四重机制防御：</p>
<ol>
<li><strong>证书签名体系</strong>：<ul>
<li>攻击者无法伪造 CA 签名的合法证书（除非控制根 CA）</li>
</ul>
</li>
<li><strong>公钥绑定</strong>：<ul>
<li>浏览器强制检查证书域名（HSTS 可阻止降级攻击）</li>
</ul>
</li>
<li><strong>密钥交换保密</strong>：<ul>
<li>Pre-Master Secret 用<strong>服务器公钥加密</strong>，仅私钥持有者可解密</li>
</ul>
</li>
<li><strong>双向认证（可选）</strong>：<ul>
<li>服务器要求客户端提供证书（用于银行等高安全场景）</li>
</ul>
</li>
</ol>
<p><strong>经典 MitM 攻击失败原因</strong>：<br>攻击者截获流量时：</p>
<ul>
<li>若提供<strong>自签名证书</strong> → 浏览器显示 <code>NET::ERR_CERT_AUTHORITY_INVALID</code></li>
<li>若提供<strong>盗用证书</strong> → 私钥不在攻击者手中，无法解密 Pre-Master Secret</li>
</ul>
<hr>
<h3 id="🔐-加密技术总结"><a href="#🔐-加密技术总结" class="headerlink" title="🔐 加密技术总结"></a>🔐 加密技术总结</h3><table>
<thead>
<tr>
<th align="left"><strong>阶段</strong></th>
<th align="left">加密类型</th>
<th align="left">算法示例</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">证书公钥传输</td>
<td align="left">非对称加密</td>
<td align="left">RSA 2048 &#x2F; ECC secp256r1</td>
<td align="left">安全传递 Pre-Master Secret</td>
</tr>
<tr>
<td align="left">会话密钥生成</td>
<td align="left">密钥协商</td>
<td align="left">ECDHE &#x2F; DHE</td>
<td align="left">前向保密保障</td>
</tr>
<tr>
<td align="left">应用数据传输</td>
<td align="left">对称加密</td>
<td align="left">AES-128-GCM &#x2F; ChaCha20</td>
<td align="left">高效加密实际内容</td>
</tr>
</tbody></table>
<hr>
<h3 id="💎-核心安全设计思想"><a href="#💎-核心安全设计思想" class="headerlink" title="💎 核心安全设计思想"></a>💎 核心安全设计思想</h3><ol>
<li><strong>非对称加密建立信任</strong> → 解决密钥分发问题</li>
<li><strong>对称加密高效通信</strong> → 解决性能瓶颈</li>
<li><strong>PKI 体系验证身份</strong> → 防范中间人攻击</li>
<li><strong>前向保密（PFS）</strong> → 即使私钥泄露，历史会话仍安全</li>
</ol>
<p>通过以上机制，HTTPS 在开放网络中构建了机密性、完整性和身份认证三大安全支柱。</p>
<h2 id="与浏览器相关"><a href="#与浏览器相关" class="headerlink" title="与浏览器相关"></a>与浏览器相关</h2><h3 id="1-渲染进程（Renderer-Process）-请求发起"><a href="#1-渲染进程（Renderer-Process）-请求发起" class="headerlink" title="1. 渲染进程（Renderer Process） - 请求发起"></a><strong>1. 渲染进程（Renderer Process） - 请求发起</strong></h3><ul>
<li><p><strong>触发位置</strong>：Blink渲染引擎（如V8执行JavaScript）</p>
</li>
<li><p><strong>关键操作</strong>：</p>
<ul>
<li>解析HTML中的<code>&lt;a&gt;</code>、<code>&lt;img&gt;</code>等资源标签</li>
<li>执行JavaScript中的<code>fetch()</code>或<code>XMLHttpRequest</code></li>
<li>生成<strong>HTTP请求头</strong>（包含URL、Method、Cookie等）</li>
</ul>
</li>
<li><p><strong>协议栈入口</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：JS发起请求</span></span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/data&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>&#125;,</span><br><span class="line">  <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;<span class="attr">key</span>: <span class="string">&#x27;value&#x27;</span>&#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>跨进程通信</strong>：通过<strong>Mojo IPC</strong>将请求发送给网络进程</p>
</li>
</ul>
<h3 id="2-网络进程（Network-Service）-协议栈核心"><a href="#2-网络进程（Network-Service）-协议栈核心" class="headerlink" title="2. 网络进程（Network Service） - 协议栈核心"></a><strong>2. 网络进程（Network Service） - 协议栈核心</strong></h3><ul>
<li><p><strong>核心组件</strong>：</p>
<ul>
<li><strong>HTTP&#x2F;HTTP2栈</strong>：处理应用层协议</li>
<li><strong>QUIC实现</strong>：基于UDP的HTTP&#x2F;3</li>
<li><strong>TLS&#x2F;SSL引擎</strong>：加密解密</li>
<li><strong>TCP&#x2F;UDP套接字管理</strong></li>
</ul>
</li>
<li><p><strong>协议处理流程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────┐</span><br><span class="line">│ 接收渲染进程请求     │</span><br><span class="line">├─────────────────────┤</span><br><span class="line">│ 1. 检查缓存         │ → MemoryCache/DiskCache</span><br><span class="line">├─────────────────────┤</span><br><span class="line">│ 2. 解析URL          │ → 提取协议/主机/端口</span><br><span class="line">├─────────────────────┤</span><br><span class="line">│ 3. 处理HTTP语义     │ → 添加Cookie/UA/Referer</span><br><span class="line">├─────────────────────┤</span><br><span class="line">│ 4. TLS握手协商      │ → RSA/ECDHE密钥交换</span><br><span class="line">├─────────────────────┤</span><br><span class="line">│ 5. TCP连接管理      │ → 复用连接或三次握手</span><br><span class="line">├─────────────────────┤</span><br><span class="line">│ 6. 数据分帧发送      │ → HTTP/2二进制分帧</span><br><span class="line">├─────────────────────┤</span><br><span class="line">│ 7. 接收响应         │ → 处理重定向/压缩</span><br><span class="line">├─────────────────────┤</span><br><span class="line">│ 8. 流式传输给渲染进程│ ← 通过IPC管道</span><br><span class="line">└─────────────────────┘</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-浏览器进程（Browser-Process）-全局管控"><a href="#3-浏览器进程（Browser-Process）-全局管控" class="headerlink" title="3. 浏览器进程（Browser Process） - 全局管控"></a><strong>3. 浏览器进程（Browser Process） - 全局管控</strong></h3><ul>
<li><p><strong>关键职责</strong>：</p>
<ul>
<li><strong>Cookie管理</strong>：通过CookieStore访问存储</li>
<li><strong>证书验证</strong>：调用系统证书库</li>
<li><strong>代理配置</strong>：应用PAC脚本或系统代理</li>
<li><strong>安全策略</strong>：CORS预检、HSTS强制HTTPS</li>
<li><strong>网络隔离</strong>：实施Site Isolation策略</li>
</ul>
</li>
<li><p><strong>跨域处理示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">渲染进程 → 请求api.other.com</span><br><span class="line">网络进程 → 触发CORS预检OPTIONS请求</span><br><span class="line">浏览器进程 → 验证跨域策略</span><br><span class="line">网络进程 → 转发实际请求</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-操作系统内核-底层协议执行"><a href="#4-操作系统内核-底层协议执行" class="headerlink" title="4. 操作系统内核 - 底层协议执行"></a><strong>4. 操作系统内核 - 底层协议执行</strong></h3><ul>
<li><p><strong>TCP&#x2F;IP栈</strong>：内核处理三次握手、拥塞控制</p>
</li>
<li><p><strong>套接字操作</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码：网络进程调用系统API</span></span><br><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">connect(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">write(sockfd, http_request, <span class="built_in">strlen</span>(http_request));</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>从本质上说，进程和线程都是 CPU 工作时间片的一个描述：</p>
<ul>
<li>进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</li>
<li>线程是进程中的更小单位，描述了执行一段指令所需的时间。</li>
</ul>
<p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p>
<p><strong>进程和线程的区别</strong></p>
<ul>
<li>进程可以看做独立应用，线程不能</li>
<li>资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</li>
<li>通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</li>
<li>调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I&#x2F;O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小</li>
</ul>
<p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。</p>
<p><strong>进程是运行在虚拟内存上的</strong>，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。</p>
<p><strong>如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存</strong>。</p>
<p>进程和线程之间的关系有以下四个特点：</p>
<p><strong>（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p>
<p><strong>（2）线程之间共享进程中的数据。</strong></p>
<p><strong>（3）当一个进程关闭之后，操作系统会回收进程所占用的内存</strong>。当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>
<p><strong>（4）进程之间的内容相互隔离</strong>进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>
<p>系统中的资源可以分为两类：</p>
<ul>
<li>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li>
<li>不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li>
</ul>
<p><strong>产生死锁的原因：</strong></p>
<p><strong>（1）竞争资源</strong></p>
<ul>
<li>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</li>
<li>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</li>
</ul>
<p><strong>（2）进程间推进顺序非法</strong></p>
<p>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p>
<p><strong>产生死锁的必要条件：</strong></p>
<ul>
<li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。</li>
</ul>
<p><strong>预防死锁的方法：</strong></p>
<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
<p><strong>孤儿进程</strong>：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<p><strong>僵尸进程</strong>：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程</p>
<h3 id="进程之间的通信方式"><a href="#进程之间的通信方式" class="headerlink" title="进程之间的通信方式"></a>进程之间的通信方式</h3><p><strong>（1）管道通信</strong></p>
<p>管道是一种最基本的进程间通信机制。<strong>管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。</strong></p>
<p>管道的特点：</p>
<ul>
<li>只能单向通信</li>
<li>只能血缘关系的进程进行通信</li>
<li>依赖于文件系统</li>
<li>生命周期随进程</li>
<li>面向字节流的服务</li>
<li>管道内部提供了同步机制</li>
</ul>
<p><strong>（2）消息队列通信</strong></p>
<p>消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p>
<p>使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。</p>
<p><strong>（3）信号量通信</strong></p>
<p>共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p>
<p><strong>（4）信号通信</strong></p>
<p>信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。</p>
<p><strong>（5）共享内存通信</strong></p>
<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<p><strong>（6）套接字通信</strong></p>
<p>上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p>
<h2 id="Chrome浏览器的架构图："><a href="#Chrome浏览器的架构图：" class="headerlink" title="Chrome浏览器的架构图："></a><strong>Chrome浏览器的架构图</strong>：</h2><p><img src="/../img/21994.jpg" alt="img"></p>
<p>从图中可以看出，最新的 Chrome 浏览器包括：</p>
<ul>
<li>1 个浏览器主进程</li>
<li>1 个 GPU 进程</li>
<li>1 个网络进程</li>
<li>多个渲染进程</li>
<li>多个插件进程</li>
</ul>
<p>这些进程的功能：</p>
<ul>
<li><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li><strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li><strong>GPU 进程</strong>：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li><strong>网络进程</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>
<li><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ul>
<p>所以，<strong>打开一个网页，最少需要四个进程</strong>：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p>
<p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p>
<ul>
<li><strong>更高的资源占用</strong>：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li>
<li><strong>更复杂的体系架构</strong>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li>
</ul>
<h3 id="浏览器渲染进程的线程有哪些"><a href="#浏览器渲染进程的线程有哪些" class="headerlink" title="浏览器渲染进程的线程有哪些"></a>浏览器渲染进程的线程有哪些</h3><p>浏览器的渲染进程的线程总共有五种：</p>
<p><img src="/../img/19964.jpg" alt="img"></p>
<p><strong>（1）GUI渲染线程</strong></p>
<p>负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要<strong>重绘</strong>或由于某种操作引发<strong>回流</strong>时，该线程就会执行。</p>
<p>浏览器渲染主要有以下步骤：</p>
<ul>
<li>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li>
<li>然后对 CSS 进行解析，生成 CSSOM 规则树。</li>
<li>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li>
<li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li>
<li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li>
</ul>
<p>大致过程如图所示：</p>
<p><img src="/../img/1810.jpg" alt="img"></p>
<p><strong>注意</strong>：这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<p>注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>
<h4 id="浏览器渲染优化"><a href="#浏览器渲染优化" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h4><p>  （1）针对JavaScript：JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：</p>
<ol>
<li><p>尽量将JavaScript文件放在body的最后</p>
</li>
<li><p>body中间尽量不要写﻿script标签</p>
</li>
<li><p>script标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：</p>
</li>
</ol>
<p>   ● script 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；</p>
<p>   ● async 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序</p>
<p>   ● defer 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。</p>
<p> （2）针对CSS：使用CSS有三种方式：使用link、@import、内联样式，</p>
<p>其中link和@import都是导入外部样式。它们之间的区别：</p>
<ul>
<li>link：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码</li>
<li>@import：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)</li>
<li>style：GUI直接渲染</li>
</ul>
<p> 外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。</p>
<p> 所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</p>
<p> （3）针对DOM树、CSSOM树：<br> 可以通过以下几种方式来减少渲染的时间：<br> ● HTML文件的代码层级尽量不要太深<br> ● 使用语义化的标签，来避免不标准语义化的特殊处理<br> ● 减少CSSD代码的层级，因为选择器是从左向右进行解析的</p>
<p> （4）减少回流与重绘：<br> ● 操作DOM时，尽量在低层级的DOM节点进行操作<br> ● 不要使用﻿table﻿布局， 一个小的改动可能会使整个﻿table﻿进行重新布局<br> ● 使用CSS的表达式<br> ● 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。<br> ● 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素<br> ● 避免频繁操作DOM，可以创建一个文档片段﻿documentFragment﻿，在它上面应用所有DOM操作，最后再把它添加到文档中<br> ● 将元素先设置﻿display: none﻿，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。<br> ● 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。</p>
<p> 浏览器针对页面的回流与重绘，进行了自身的优化——渲染队列</p>
<p> 浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>
<p> 将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p>
<h4 id="渲染过程中遇到-JS-文件如何处理？"><a href="#渲染过程中遇到-JS-文件如何处理？" class="headerlink" title="渲染过程中遇到 JS 文件如何处理？"></a>渲染过程中遇到 JS 文件如何处理？</h4><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p>
<h4 id="什么是文档的预解析？"><a href="#什么是文档的预解析？" class="headerlink" title="什么是文档的预解析？"></a>什么是文档的预解析？</h4><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p>
<h4 id="CSS-如何阻塞文档解析？"><a href="#CSS-如何阻塞文档解析？" class="headerlink" title="CSS 如何阻塞文档解析？"></a><strong>CSS 如何阻塞文档解析？</strong></h4><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p>
<h4 id="如何优化关键渲染路径？"><a href="#如何优化关键渲染路径？" class="headerlink" title="如何优化关键渲染路径？"></a>如何优化关键渲染路径？</h4><p>  为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：<br>  （1）关键资源的数量。<br>  （2）关键路径长度。<br>  （3）关键字节的数量。</p>
<p> 关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p>
<p> 优化关键渲染路径的常规步骤如下：<br>  （1）对关键路径进行分析和特性描述：资源数、字节数、长度。<br>  （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。<br>  （3）优化关键字节数以缩短下载时间（往返次数）。<br>  （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</p>
<h4 id="什么情况会阻塞渲染？"><a href="#什么情况会阻塞渲染？" class="headerlink" title="什么情况会阻塞渲染？"></a>什么情况会阻塞渲染？</h4><p>首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</p>
<p>当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</p>
<p><strong>（2）JS引擎线程</strong></p>
<p>JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；</p>
<p><img src="/../img/deepseek_mermaid_20250628_8a7e0d.png"></p>
<h4 id="详细步骤说明（以V8引擎为例）"><a href="#详细步骤说明（以V8引擎为例）" class="headerlink" title="详细步骤说明（以V8引擎为例）"></a>详细步骤说明（以V8引擎为例）</h4><ol>
<li><strong>解析（Parsing）阶段</strong></li>
</ol>
<ul>
<li><p><strong>词法分析（Lexical Analysis）</strong>：</p>
<ul>
<li>将源代码分解为<strong>令牌（Tokens）</strong></li>
<li>示例：<code>const sum = (a, b) =&gt; a + b;</code> →<br><code>[const, sum, =, (, a, ,, b, ), =&gt;, a, +, b, ;]</code></li>
</ul>
</li>
<li><p><strong>语法分析（Syntax Analysis）</strong>：</p>
<ul>
<li><p>根据ECMAScript规范构建<strong>抽象语法树（AST）</strong></p>
</li>
<li><p>工具：Esprima、Acorn</p>
</li>
<li><p>示例AST结构：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Program&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VariableDeclaration&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;declarations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;VariableDeclarator&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Identifier&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sum&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;init&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ArrowFunctionExpression&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>...<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;body&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> ... <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>预编译阶段</strong></li>
</ol>
<ul>
<li><strong>关键处理</strong>：<ul>
<li>函数声明和变量提升</li>
<li>创建词法环境（Lexical Environment）</li>
<li>建立作用域链（Scope Chain）</li>
<li>闭包预处理</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>编译阶段</strong></li>
</ol>
<p>a) <strong>解释器路径（Ignition）</strong></p>
<ul>
<li><p>将AST转换为<strong>字节码（Bytecode）</strong></p>
</li>
<li><p>字节码示例：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LdaNamedProperty a0, [0]</span><br><span class="line">Add a1, [1]</span><br><span class="line">Return</span><br></pre></td></tr></table></figure>
</li>
<li><p>优点：快速启动，跨平台</p>
</li>
</ul>
<p>b) <strong>优化编译器路径（TurboFan）</strong></p>
<ul>
<li>监控热点函数（多次执行的代码）</li>
<li>生成高度优化的<strong>机器码</strong></li>
<li>优化技术：<ul>
<li><strong>内联缓存（Inline Caches）</strong></li>
<li><strong>隐藏类（Hidden Classes）</strong></li>
<li><strong>类型反馈（Type Feedback）</strong></li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>执行阶段</strong></li>
</ol>
<ul>
<li><p><strong>执行上下文（Execution Context）</strong>：</p>
<ul>
<li>包含：<ul>
<li>变量环境（VariableEnvironment）</li>
<li>词法环境（LexicalEnvironment）</li>
<li>this绑定</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>调用栈管理</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">first</span>(<span class="params"></span>) &#123; <span class="title function_">second</span>(); &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">second</span>(<span class="params"></span>) &#123; <span class="title function_">third</span>(); &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">third</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">trace</span>(); &#125;</span><br><span class="line"><span class="title function_">first</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用栈：</span></span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// (anonymous)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li><strong>优化与反优化</strong></li>
</ol>
<ul>
<li><p><strong>优化条件</strong>：</p>
<ul>
<li>函数被多次调用（通常 &gt; 10次）</li>
<li>参数类型稳定</li>
</ul>
</li>
<li><p><strong>反优化场景</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化路径（数字）</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 类型：Number</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 仍为Number → 保持优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反优化路径</span></span><br><span class="line"><span class="title function_">add</span>(<span class="string">&quot;5&quot;</span>, <span class="string">&quot;6&quot;</span>); <span class="comment">// 类型变为String → 丢弃机器码</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="6">
<li><strong>内存管理</strong></li>
</ol>
<ul>
<li><strong>垃圾回收策略</strong>：<ul>
<li><strong>新生代（New Space）</strong>：Scavenge算法（复制）</li>
<li><strong>老生代（Old Space）</strong>：标记-清除（Mark-Sweep） + 标记-整理（Mark-Compact）</li>
</ul>
</li>
<li><strong>回收时机</strong>：<ul>
<li>内存分配失败时</li>
<li>定时执行（增量标记）</li>
</ul>
</li>
</ul>
<p>注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<p><strong>（3）事件触发线程</strong></p>
<p>事件触发线程属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；</p>
<p><img src="/../img/deepseek_mermaid_20250628_9843a9.png"></p>
<p>注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；</p>
<p><strong>（4）定时器触发进程</strong></p>
<p><strong>定时器触发进程</strong>即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；</p>
<p>注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</p>
<p><strong>（5）异步http请求线程</strong></p>
<ul>
<li>XMLHttpRequest连接后通过浏览器新开一个线程请求；</li>
<li>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；</li>
</ul>
<h3 id="浏览器输入url后的时序图"><a href="#浏览器输入url后的时序图" class="headerlink" title="浏览器输入url后的时序图"></a><strong>浏览器输入url后的时序图</strong></h3><p><img src="/../img/26826.jpg" alt="img"></p>
<h2 id="浏览器事件机制"><a href="#浏览器事件机制" class="headerlink" title="浏览器事件机制"></a>浏览器事件机制</h2><h3 id="事件是什么？事件模型？"><a href="#事件是什么？事件模型？" class="headerlink" title="事件是什么？事件模型？"></a>事件是什么？事件模型？</h3><p>事件是用户操作网页时发生的交互动作，比如 click&#x2F;move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p>
<p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：</p>
<ul>
<li><strong>DOM0 级事件模型</strong>，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。</li>
<li><strong>IE 事件模型</strong>，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</li>
<li><strong>DOM2 级事件模型</strong>，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</li>
</ul>
<h3 id="如何阻止事件冒泡"><a href="#如何阻止事件冒泡" class="headerlink" title="如何阻止事件冒泡"></a>如何阻止事件冒泡</h3><ul>
<li>普通浏览器使用：event.stopPropagation() </li>
<li>IE浏览器使用：event.cancelBubble &#x3D; true;</li>
</ul>
<h3 id="对事件委托的理解"><a href="#对事件委托的理解" class="headerlink" title="对事件委托的理解"></a>对事件委托的理解</h3><p>（1）事件委托的概念</p>
<p>事件委托本质上是利用了<strong>浏览器事件冒泡</strong>的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。</p>
<p>使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。</p>
<p><strong>（2）事件委托的特点</strong></p>
<ul>
<li><strong>减少内存消耗</strong></li>
</ul>
<p>如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>item n<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。</p>
<ul>
<li><strong>动态绑定事件</strong></li>
</ul>
<p>给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：</span></span><br><span class="line"><span class="comment">// 给父层元素绑定事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 兼容性处理</span></span><br><span class="line">  <span class="keyword">var</span> event = e || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">  <span class="keyword">var</span> target = event.<span class="property">target</span> || event.<span class="property">srcElement</span>;</span><br><span class="line">  <span class="comment">// 判断是否匹配目标元素</span></span><br><span class="line">  <span class="keyword">if</span> (target.<span class="property">nodeName</span>.<span class="property">toLocaleLowerCase</span> === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;the content is: &#x27;</span>, target.<span class="property">innerHTML</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；</p>
<p><strong>（3）局限性</strong></p>
<p>当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。</p>
<p>当然事件委托不是只有优点，它也是有<strong>缺点</strong>的，事件委托会影响页面性能，主要影响因素有：</p>
<ul>
<li>元素中，绑定事件委托的次数；</li>
<li>点击的最底层元素，到绑定事件元素之间的<code>DOM</code>层数；</li>
</ul>
<p>在必须使用事件委托的地方，可以进行如下的处理：</p>
<ul>
<li><p>只在必须的地方，使用事件委托，比如：<code>ajax</code>的局部刷新区域</p>
</li>
<li><p>尽量的减少绑定的层级，不在<code>body</code>元素上，进行绑定</p>
</li>
<li><p>减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。</p>
</li>
</ul>
<h3 id="事件委托的使用场景"><a href="#事件委托的使用场景" class="headerlink" title="事件委托的使用场景"></a>事件委托的使用场景</h3><p>场景：给页面的所有的a标签添加click事件，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (e.<span class="property">target</span>.<span class="property">nodeName</span> == <span class="string">&quot;A&quot;</span>)</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<p>但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。</p>
<p>这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> node = e.<span class="property">target</span>;</span><br><span class="line">	<span class="keyword">while</span> (node.<span class="property">parentNode</span>.<span class="property">nodeName</span> != <span class="string">&quot;BODY&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (node.<span class="property">nodeName</span> == <span class="string">&quot;A&quot;</span>) &#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		node = node.<span class="property">parentNode</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h3><ul>
<li><strong>同步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</li>
<li><strong>异步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理</li>
</ul>
<h3 id="事件触发的过程是怎样的"><a href="#事件触发的过程是怎样的" class="headerlink" title="事件触发的过程是怎样的"></a>事件触发的过程是怎样的</h3><p>事件触发有三个阶段：</p>
<p>●window 往事件触发处传播，遇到注册的捕获事件会触发</p>
<p>●传播到事件触发处时触发注册的事件</p>
<p>●从事件触发处往 window 传播，遇到注册的冒泡事件会触发</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下会先打印冒泡然后是捕获</span></span><br><span class="line">node.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冒泡&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line">node.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获 &#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p>
<p>通常使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false ，useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：</p>
<p>●capture：布尔值，和 useCapture 作用一样</p>
<p>●once：布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听</p>
<p>●passive：布尔值，表示永远不会调用 preventDefault</p>
<p>一般来说，如果只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。</p>
<p>stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">node.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    event.<span class="title function_">stopImmediatePropagation</span>()</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;冒泡&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span><br><span class="line">node.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获 &#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>







<h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><h3 id="对浏览器的缓存机制的理解"><a href="#对浏览器的缓存机制的理解" class="headerlink" title="对浏览器的缓存机制的理解"></a>对浏览器的缓存机制的理解</h3><p><strong>浏览器缓存****的全过程：</strong></p>
<ul>
<li>浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；</li>
<li>下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；</li>
<li>如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；</li>
<li>服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</li>
<li>如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；</li>
</ul>
<p><img src="/../img/%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE1.png" alt="img"></p>
<p>很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。</p>
<h3 id="协商缓存和强缓存的区别"><a href="#协商缓存和强缓存的区别" class="headerlink" title="协商缓存和强缓存的区别"></a>协商缓存和强缓存的区别</h3><h4 id="（1）强缓存"><a href="#（1）强缓存" class="headerlink" title="（1）强缓存"></a>（1）强缓存</h4><p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</p>
<p>强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 <strong>Expires 属性</strong>和 <strong>Cache-Control 属性</strong>。</p>
<p>（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p>
<p>（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，</p>
<p><code>Cache-Control</code>可设置的字段：</p>
<ul>
<li><code>public</code>：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age&#x3D;来精确控制；</li>
<li><code>private</code>：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；</li>
<li><code>no-cache</code>：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；</li>
<li><code>no-store</code>：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；</li>
<li><code>max-age=</code>：设置缓存的最大有效期，单位为秒；</li>
<li><code>s-maxage=</code>：优先级高于max-age&#x3D;，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；</li>
<li><code>max-stale[=]</code>：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。</li>
</ul>
<p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。</p>
<p><strong>no-cache和no-store很容易混淆：</strong></p>
<ul>
<li>no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；</li>
<li>no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。</li>
</ul>
<h4 id="（2）协商缓存"><a href="#（2）协商缓存" class="headerlink" title="（2）协商缓存"></a>（2）协商缓存</h4><p>如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。</p>
<p>上面已经说到了，命中协商缓存的条件有两个：</p>
<ul>
<li><code>max-age=xxx</code> 过期了</li>
<li>值为<code>no-store</code></li>
</ul>
<p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。</p>
<p>协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 <strong>Etag</strong> 和 <strong>Last-Modified</strong> 属性。</p>
<p>（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。</p>
<p>（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</p>
<p>当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p>
<p><strong>总结：</strong></p>
<p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p>
<h3 id="为什么需要浏览器缓存？"><a href="#为什么需要浏览器缓存？" class="headerlink" title="为什么需要浏览器缓存？"></a>为什么需要浏览器缓存？</h3><p>对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。</p>
<p>所谓的<strong>浏览器缓存</strong>指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。</p>
<p>使用浏览器缓存，有以下优点：</p>
<ul>
<li>减少了服务器的负担，提高了网站的性能</li>
<li>加快了客户端网页的加载速度</li>
<li>减少了多余网络数据传输</li>
</ul>
<h3 id="点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？"><a href="#点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？" class="headerlink" title="点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？"></a>点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h3><ul>
<li>**点击刷新按钮或者按 F5：**浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</li>
<li>**用户按 Ctrl+F5（强制刷新）：**浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</li>
<li>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</li>
</ul>
<h2 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a>浏览器安全</h2><h3 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>
<p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p>
<p>攻击者可以通过这种攻击方式可以进行以下操作：</p>
<ul>
<li>获取页面的数据，如DOM、cookie、localStorage；</li>
<li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li>
<li>破坏页面结构；</li>
<li>流量劫持（将链接指向某网站）；</li>
</ul>
<h4 id="（2）攻击类型"><a href="#（2）攻击类型" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>XSS 可以分为存储型、反射型和 DOM 型：</p>
<ul>
<li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</li>
<li>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 </li>
<li>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</li>
</ul>
<p><strong>1）存储型 XSS 的攻击步骤：</strong> </p>
<ol>
<li>攻击者将恶意代码提交到⽬标⽹站的数据库中。 </li>
<li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 </li>
<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 </li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</p>
<p><strong>2）反射型 XSS的攻击步骤：</strong></p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。 </li>
<li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 </li>
<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 </li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。 </p>
<p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。  </p>
<p><strong>3）DOM 型 XSS的攻击步骤：</strong> </p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。 </li>
<li>⽤户打开带有恶意代码的 URL。 </li>
<li>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。 </li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。 </p>
<h3 id="如何防御-XSS-攻击？"><a href="#如何防御-XSS-攻击？" class="headerlink" title="如何防御 XSS 攻击？"></a>如何防御 XSS 攻击？</h3><p>可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：</p>
<ul>
<li>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</li>
<li>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</li>
</ul>
<ol>
<li>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</li>
<li>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 <meta http-equiv="Content-Security-Policy"></li>
</ol>
<ul>
<li>对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</li>
</ul>
<h3 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h3><h4 id="（1）概念-1"><a href="#（1）概念-1" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>CSRF 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p>
<p>CSRF 攻击的<strong>本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p>
<h4 id="（2）攻击类型-1"><a href="#（2）攻击类型-1" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>常见的 CSRF 攻击有三种：</p>
<ul>
<li>GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li>
<li>POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li>
<li>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li>
</ul>
<h3 id="如何防御-CSRF-攻击"><a href="#如何防御-CSRF-攻击" class="headerlink" title="如何防御 CSRF 攻击"></a>如何防御 CSRF 攻击</h3><p><strong>CSRF 攻击可以使用以下方法来防护：</strong></p>
<ul>
<li><strong>进行同源检测</strong>，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</li>
<li><strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</li>
<li><strong>对</strong> <strong>Cookie 进行****双重验证</strong>，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li>
<li><strong>在设置 cookie 属性的时候设置</strong> <strong>Samesite</strong> <strong>，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li>
</ul>
<h3 id="什么是中间人攻击？如何防范中间人攻击"><a href="#什么是中间人攻击？如何防范中间人攻击" class="headerlink" title="什么是中间人攻击？如何防范中间人攻击"></a>什么是中间人攻击？如何防范中间人攻击</h3><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。</p>
<p>攻击过程如下: </p>
<ul>
<li>客户端发送请求到服务端，请求被中间⼈截获 </li>
<li>服务器向客户端发送公钥 </li>
<li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端 </li>
<li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器 </li>
<li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器 </li>
<li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端 </li>
<li></li>
</ul>
<h3 id="有哪些可能引起前端安全的问题"><a href="#有哪些可能引起前端安全的问题" class="headerlink" title="有哪些可能引起前端安全的问题"></a>有哪些可能引起前端安全的问题</h3><ul>
<li>跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript &#x2F; CSS &#x2F; Flash 等； </li>
<li>iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；</li>
<li>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击 </li>
<li>恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</li>
</ul>
<h3 id="网络劫持有哪几种，如何防范？"><a href="#网络劫持有哪几种，如何防范？" class="headerlink" title="网络劫持有哪几种，如何防范？"></a>网络劫持有哪几种，如何防范？</h3><p>⽹络劫持分为两种: </p>
<p>（1）<strong>DNS劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持) </p>
<ul>
<li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li>
<li>302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容</li>
</ul>
<p>（2）<strong>HTTP劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告) </p>
<p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。</p>
<h3 id="DOS（拒绝服务）攻击和DDoS（分布式拒绝服务）攻击"><a href="#DOS（拒绝服务）攻击和DDoS（分布式拒绝服务）攻击" class="headerlink" title="DOS（拒绝服务）攻击和DDoS（分布式拒绝服务）攻击"></a>DOS（拒绝服务）攻击和DDoS（分布式拒绝服务）攻击</h3><p>核心目标都是通过耗尽目标系统的资源（如带宽、CPU、内存），使其无法为合法用户提供服务。它们的<strong>主要区别在于攻击来源的数量和分布方式</strong>：</p>
<ol>
<li><strong>DOS 攻击（Denial-of-Service，拒绝服务攻击）</strong></li>
</ol>
<ul>
<li><strong>攻击来源：</strong> 单台计算机或少量设备（通常由一个攻击者直接控制）。</li>
<li><strong>攻击方式：</strong><ul>
<li>利用目标系统的漏洞（如缓冲区溢出）使其崩溃。</li>
<li>发送大量看似合法的请求（如HTTP请求）耗尽服务器资源（如SYN洪水攻击）。</li>
</ul>
</li>
<li><strong>特点：</strong><ul>
<li>相对容易实施（技术门槛较低）。</li>
<li>相对容易防御和追踪：由于流量来自单一或少数据源，目标管理员可以通过防火墙规则（如屏蔽攻击源IP）或修复漏洞来缓解攻击。</li>
<li>攻击规模有限：单台机器的带宽和处理能力有限。</li>
</ul>
</li>
<li><strong>比喻：</strong> 一个人不停地用力敲打你家的大门，让你无法正常开门接待其他客人。</li>
</ul>
<ol start="2">
<li><strong>DDoS 攻击（Distributed Denial-of-Service，分布式拒绝服务攻击）</strong></li>
</ol>
<ul>
<li><strong>攻击来源：</strong> 数量庞大的受控设备组成的“僵尸网络”（Botnet），分布在全球各地。这些设备通常是感染了恶意软件的普通用户电脑、服务器、IoT设备（如摄像头、路由器）。</li>
<li><strong>攻击方式：</strong><ul>
<li><strong>直接攻击：</strong> 僵尸网络中的所有设备直接向目标发送大量流量（如HTTP请求、UDP数据包）。</li>
<li><strong>反射&#x2F;放大攻击：</strong> 攻击者伪造目标IP地址，向大量第三方服务器（如DNS服务器、NTP服务器）发送请求。这些服务器会将大得多的响应发送回目标地址，放大攻击流量（如DNS放大攻击、NTP放大攻击）。</li>
</ul>
</li>
<li><strong>特点：</strong><ul>
<li><strong>规模巨大：</strong> 成百上千甚至数百万台设备同时发动攻击，产生远超任何单点防御能力的海量流量（可达Tbps级别）。</li>
<li><strong>难以防御：</strong><ul>
<li>攻击源IP数量庞大且分散，难以通过简单IP屏蔽阻止。</li>
<li>流量可能看起来像正常流量，难以精确过滤。</li>
<li>需要部署专业的DDoS防护服务（如云清洗中心）。</li>
</ul>
</li>
<li><strong>难以追踪：</strong> 攻击者隐藏在僵尸网络背后，通过多层代理或控制服务器指挥攻击，溯源困难。</li>
<li><strong>危害巨大：</strong> 可导致大型网站、在线服务、网络基础设施瘫痪，造成严重经济损失和声誉损害。</li>
</ul>
</li>
<li><strong>比喻：</strong> 成千上万个被遥控指挥的人（僵尸网络）从四面八方同时涌向你家的门、窗、烟囱，用各种方式堵塞所有入口，让你完全无法动弹，也无法接待任何正常访客。或者，攻击者遥控一大群人（僵尸网络）冒充你家地址，向邮局订购大量重物（反射服务器），导致邮局把堆积如山的包裹（放大流量）都送到你家门口把你淹没。</li>
</ul>
<p><strong>关键区别总结</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">DOS 攻击</th>
<th align="left">DDoS 攻击</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>攻击源</strong></td>
<td align="left"><strong>单一或少数据源</strong>（1台或几台设备）</td>
<td align="left"><strong>海量分布式来源</strong>（庞大僵尸网络）</td>
</tr>
<tr>
<td align="left"><strong>攻击规模</strong></td>
<td align="left"><strong>相对较小</strong>（受限于单点能力）</td>
<td align="left"><strong>极其巨大</strong>（Tbps级别，远超单点防御能力）</td>
</tr>
<tr>
<td align="left"><strong>复杂性</strong></td>
<td align="left">相对简单</td>
<td align="left">非常复杂（需要构建&#x2F;控制僵尸网络）</td>
</tr>
<tr>
<td align="left"><strong>防御难度</strong></td>
<td align="left"><strong>相对容易</strong>（可屏蔽源头IP）</td>
<td align="left"><strong>极其困难</strong>（需专业防护，源头多且伪装性强）</td>
</tr>
<tr>
<td align="left"><strong>追踪难度</strong></td>
<td align="left">相对容易</td>
<td align="left">非常困难（攻击者隐藏深）</td>
</tr>
<tr>
<td align="left"><strong>危害程度</strong></td>
<td align="left">较小（影响范围有限）</td>
<td align="left">巨大（可瘫痪大型服务、基础设施）</td>
</tr>
<tr>
<td align="left"><strong>主导者</strong></td>
<td align="left">单个攻击者</td>
<td align="left">攻击者控制僵尸网络指挥中心（C&amp;C）</td>
</tr>
</tbody></table>
<p><strong>为什么 DDoS 成为主流？</strong></p>
<ul>
<li><strong>防御技术的进步：</strong> 基本的DOS攻击容易被现代防火墙、入侵检测系统和网络基础设施过滤掉。</li>
<li><strong>僵尸网络的易得性：</strong> 攻击者可以租用现成的庞大僵尸网络（即“攻击即服务”）。</li>
<li><strong>攻击效果显著：</strong> DDoS能产生毁灭性的流量，对大型目标也有效。</li>
<li><strong>匿名性：</strong> 僵尸网络提供了更好的匿名性。</li>
</ul>
<p><strong>如何防御？</strong></p>
<ul>
<li><strong>DOS防御：</strong> 防火墙规则、系统&#x2F;应用漏洞修补、入侵检测&#x2F;防御系统（IDS&#x2F;IPS）、流量限速。</li>
<li><strong>DDoS防御：</strong><ul>
<li><strong>本地设备：</strong> 部署专业的DDoS防护硬件&#x2F;软件（常能力有限）。</li>
<li><strong>云端清洗：</strong> 将流量路由到云服务商（如Cloudflare, Akamai, AWS Shield, 阿里云盾）的清洗中心，过滤恶意流量后再将干净流量传回目标。这是当前最主流有效的方式。</li>
<li><strong>带宽冗余：</strong> 增加带宽以吸收部分攻击（成本高，对超大攻击无效）。</li>
<li><strong>架构设计：</strong> 分布式架构、负载均衡、CDN等可增强韧性。</li>
</ul>
</li>
</ul>
<p><strong>总而言之，DDoS 是 DOS 的升级版和主流形态，利用僵尸网络的分布式特性发动规模更大、更难防御和追踪的拒绝服务攻击。</strong> DOS 在当今环境下已较少见且相对容易防御，而防御大规模 DDoS 攻击是现代网络安全的重要挑战，通常需要借助专业的第三方防护服务。</p>
<h2 id="浏览器本地存储"><a href="#浏览器本地存储" class="headerlink" title="浏览器本地存储"></a>浏览器本地存储</h2><h3 id="1-浏览器本地存储方式及使用场景"><a href="#1-浏览器本地存储方式及使用场景" class="headerlink" title="1. 浏览器本地存储方式及使用场景"></a>1. 浏览器本地存储方式及使用场景</h3><h4 id="（1）Cookie"><a href="#（1）Cookie" class="headerlink" title="（1）Cookie"></a>（1）Cookie</h4><p>Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。</p>
<p><strong>Cookie的特性：</strong></p>
<ul>
<li>Cookie一旦创建成功，名称就无法修改</li>
<li>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li>
<li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li>
<li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li>
<li>Cookie在请求一个新的页面的时候都会被发送过去</li>
</ul>
<p>如果需要域名之间跨域共享Cookie，有两种方法：</p>
<ol>
<li>使用Nginx反向代理</li>
<li>在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId</li>
</ol>
<p><strong>Cookie的使用场景：</strong></p>
<ul>
<li>最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。</li>
<li>可以用来统计页面的点击次数</li>
</ul>
<h4 id="（2）LocalStorage"><a href="#（2）LocalStorage" class="headerlink" title="（2）LocalStorage"></a>（2）LocalStorage</h4><p>LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。</p>
<p><strong>LocalStorage的优点：</strong></p>
<ul>
<li>在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</li>
<li>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li>
<li>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</li>
</ul>
<p><strong>LocalStorage的缺点：</strong></p>
<ul>
<li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li>
<li>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li>
<li>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</li>
</ul>
<p><strong>LocalStorage的****常用API：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 localStorage</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 localStorage 获取数据</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 localStorage 删除保存的数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 localStorage 删除所有保存的数据</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个索引的Key</span></span><br><span class="line"><span class="variable language_">localStorage</span>.<span class="title function_">key</span>(index)</span><br></pre></td></tr></table></figure>

<p><strong>LocalStorage的****使用场景：</strong></p>
<ul>
<li>有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可</li>
<li>在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</li>
</ul>
<h4 id="（3）SessionStorage"><a href="#（3）SessionStorage" class="headerlink" title="（3）SessionStorage"></a>（3）SessionStorage</h4><p>SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p>
<p><strong>SessionStorage****与LocalStorage对比：</strong></p>
<ul>
<li>SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong>；</li>
<li>SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage<strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</li>
<li>LocalStorage和SessionStorage<strong>都不能被爬虫爬取</strong>；</li>
</ul>
<p><strong>SessionStorage的****常用API：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据到 sessionStorage</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 获取数据</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除保存的数据</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">removeItem</span>(<span class="string">&#x27;key&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 sessionStorage 删除所有保存的数据</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取某个索引的Key</span></span><br><span class="line"><span class="variable language_">sessionStorage</span>.<span class="title function_">key</span>(index)</span><br></pre></td></tr></table></figure>

<p><strong>SessionStorage的****使用场景</strong></p>
<ul>
<li>由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。</li>
</ul>
<h3 id="2-Cookie有哪些字段，作用分别是什么"><a href="#2-Cookie有哪些字段，作用分别是什么" class="headerlink" title="2. Cookie有哪些字段，作用分别是什么"></a>2. Cookie有哪些字段，作用分别是什么</h3><p><strong>Cookie由以下字段组成</strong><strong>：</strong></p>
<ul>
<li><strong>Name</strong>：cookie的名称</li>
<li><strong>Value</strong>：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；</li>
<li><strong>Size</strong>： cookie的大小</li>
<li><strong>Path</strong>：可以访问此cookie的页面路径。 比如domain是abc.com，path是<code>/test</code>，那么只有<code>/test</code>路径下的页面可以读取此cookie。</li>
<li><strong>Secure</strong>： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。</li>
<li><strong>Domain</strong>：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。</li>
<li><strong>HTTP</strong>： 该字段包含<code>HTTPOnly</code> 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过<code>document.cookie</code>属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。</li>
<li>**Expires&#x2F;**<strong>Max-size</strong> ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</li>
</ul>
<p><strong>总结：</strong></p>
<p>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。</p>
<h3 id="3-Cookie、LocalStorage、SessionStorage区别"><a href="#3-Cookie、LocalStorage、SessionStorage区别" class="headerlink" title="3. Cookie、LocalStorage、SessionStorage区别"></a>3. Cookie、LocalStorage、SessionStorage区别</h3><p>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</p>
<ul>
<li>**cookie：**其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</li>
<li>**sessionStorage：**html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</li>
<li>**localStorage：**html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</li>
</ul>
<p>上面三种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p>
<p><strong>Web Storage 和 cookie 的区别总结如下：</strong></p>
<ul>
<li>Web Storage是为了更大容量存储设计的。Cookie 的大小是受限的，并且每次你请求一个新的页面的时候 Cookie 都会被发送过去，这样无形中浪费了带宽；</li>
<li>cookie 需要指定作用域，不可以跨域调用；</li>
<li>Web Storage 拥有 setItem,getItem,removeItem,clear 等方法，不像 cookie 需要前端开发者自己封装 setCookie，getCookie；</li>
<li>Cookie 也是不可以或缺的：Cookie 的作用是与服务器进行交互，作为 HTTP 规范的一部分而存在 ，而 Web Storage 仅仅是为了在本地“存储”数据而生。</li>
</ul>
<h3 id="4-前端储存的⽅式有哪些？"><a href="#4-前端储存的⽅式有哪些？" class="headerlink" title="4. 前端储存的⽅式有哪些？"></a>4. 前端储存的⽅式有哪些？</h3><ul>
<li>cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；</li>
<li>localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；</li>
<li>sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式； </li>
<li>Web SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐； </li>
<li>IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。</li>
</ul>
<h3 id="5-IndexedDB有哪些特点？"><a href="#5-IndexedDB有哪些特点？" class="headerlink" title="5. IndexedDB有哪些特点？"></a>5. IndexedDB有哪些特点？</h3><p>IndexedDB 具有以下特点：</p>
<ul>
<li><p><strong>键值对储存</strong>：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
</li>
<li><p><strong>异步</strong>：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
</li>
<li><p><strong>支持事务</strong>：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
</li>
<li><p>**同源限制：**IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
</li>
<li><p><strong>储存空间大</strong>：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>
</li>
<li><p><strong>支持二进制储存</strong>：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/" data-id="cmceux8n1000030ur7pwp6dyp" data-title="前端基础" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" rel="tag">计算机网络，浏览器原理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/27/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-06-27T13:20:55.209Z" itemprop="datePublished">2025-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/27/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/27/hello-world/" data-id="cmceuehus0000acurdhcsc30h" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/html-css-javascript/" rel="tag">html css javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E3%80%81%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E3%80%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" rel="tag">前端页面、错误监控、性能指标</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" rel="tag">计算机网络，浏览器原理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/html-css-javascript/" style="font-size: 10px;">html css javascript</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E3%80%81%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E3%80%81%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/" style="font-size: 10px;">前端页面、错误监控、性能指标</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" style="font-size: 10px;">计算机网络，浏览器原理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/06/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/">前端性能[C</a>
          </li>
        
          <li>
            <a href="/2025/06/28/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/">基础开发</a>
          </li>
        
          <li>
            <a href="/2025/06/27/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/">前端基础</a>
          </li>
        
          <li>
            <a href="/2025/06/27/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>