<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-业务" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/04/%E4%B8%9A%E5%8A%A1/" class="article-date">
  <time class="dt-published" datetime="2025-07-04T02:58:27.000Z" itemprop="datePublished">2025-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/04/%E4%B8%9A%E5%8A%A1/">业务</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p><img src="/../img/31365.jpg"></p>
<h2 id="多个页面跨域，怎么实现共享localstorage"><a href="#多个页面跨域，怎么实现共享localstorage" class="headerlink" title="多个页面跨域，怎么实现共享localstorage"></a>多个页面跨域，怎么实现共享localstorage</h2><p>实现跨域页面共享 <code>localStorage</code> 的核心挑战是浏览器的同源策略限制。以下是几种可行的解决方案，按推荐程度排序：</p>
<hr>
<h3 id="方案-1：使用-postMessage-iframe（推荐）"><a href="#方案-1：使用-postMessage-iframe（推荐）" class="headerlink" title="方案 1：使用 postMessage + iframe（推荐）"></a>方案 1：使用 <code>postMessage</code> + <code>iframe</code>（推荐）</h3><p>通过隐藏的 <code>iframe</code> 作为桥梁，利用 <code>window.postMessage</code> 实现跨域通信。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 主页面 (a.com) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 发送数据到 iframe</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">sendToStorage</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;storage-iframe&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    iframe.<span class="property">contentWindow</span>.<span class="title function_">postMessage</span>(</span></span><br><span class="line"><span class="language-javascript">      &#123; <span class="attr">type</span>: <span class="string">&#x27;SET_LS&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;sharedData&#x27;</span>, <span class="attr">value</span>: data &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="string">&#x27;https://b.com&#x27;</span> <span class="comment">// 目标域</span></span></span><br><span class="line"><span class="language-javascript">    );</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 接收来自 iframe 的数据</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (event.<span class="property">origin</span> !== <span class="string">&#x27;https://b.com&#x27;</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (event.<span class="property">data</span>.<span class="property">type</span> === <span class="string">&#x27;GET_LS_RESULT&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Received data:&#x27;</span>, event.<span class="property">data</span>.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;storage-iframe&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://b.com/storage-proxy.html&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- b.com/storage-proxy.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 监听主页面消息</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (event.<span class="property">origin</span> !== <span class="string">&#x27;https://a.com&#x27;</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (event.<span class="property">data</span>.<span class="property">type</span> === <span class="string">&#x27;SET_LS&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 存储到当前域(b.com)的 localStorage</span></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(event.<span class="property">data</span>.<span class="property">key</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(event.<span class="property">data</span>.<span class="property">value</span>));</span></span><br><span class="line"><span class="language-javascript">      </span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 可选：发送回执</span></span></span><br><span class="line"><span class="language-javascript">      event.<span class="property">source</span>.<span class="title function_">postMessage</span>(</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">type</span>: <span class="string">&#x27;SET_SUCCESS&#x27;</span>, <span class="attr">key</span>: event.<span class="property">data</span>.<span class="property">key</span> &#125;,</span></span><br><span class="line"><span class="language-javascript">        event.<span class="property">origin</span></span></span><br><span class="line"><span class="language-javascript">      );</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">else</span> <span class="keyword">if</span> (event.<span class="property">data</span>.<span class="property">type</span> === <span class="string">&#x27;GET_LS&#x27;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 读取数据并返回</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> data = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(event.<span class="property">data</span>.<span class="property">key</span>);</span></span><br><span class="line"><span class="language-javascript">      event.<span class="property">source</span>.<span class="title function_">postMessage</span>(</span></span><br><span class="line"><span class="language-javascript">        &#123; <span class="attr">type</span>: <span class="string">&#x27;GET_LS_RESULT&#x27;</span>, <span class="attr">value</span>: data &#125;,</span></span><br><span class="line"><span class="language-javascript">        event.<span class="property">origin</span></span></span><br><span class="line"><span class="language-javascript">      );</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="方案-2：共享子域（同主域适用）"><a href="#方案-2：共享子域（同主域适用）" class="headerlink" title="方案 2：共享子域（同主域适用）"></a>方案 2：共享子域（同主域适用）</h3><p>如果页面属于同一主域（如 <code>app1.example.com</code> 和 <code>app2.example.com</code>）：</p>
<ol>
<li><p>在所有页面设置相同的一级域：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&quot;example.com&quot;</span>; <span class="comment">// 需所有页面同步设置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <code>iframe</code> 或 <code>window.open()</code> 直接访问父&#x2F;子窗口的 <code>localStorage</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口访问 iframe</span></span><br><span class="line"><span class="keyword">const</span> iframe = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-iframe&#x27;</span>);</span><br><span class="line">iframe.<span class="property">contentWindow</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="方案-3：服务端代理同步"><a href="#方案-3：服务端代理同步" class="headerlink" title="方案 3：服务端代理同步"></a>方案 3：服务端代理同步</h3><ol>
<li>页面 A 将数据发送到自己的服务器（A.com&#x2F;api&#x2F;save）</li>
<li>服务器将数据同步到页面 B 的服务器（B.com&#x2F;api&#x2F;sync）</li>
<li>页面 B 从自己的服务器获取数据（需轮询或 WebSocket）</li>
</ol>
<hr>
<h3 id="方案-4：第三方库"><a href="#方案-4：第三方库" class="headerlink" title="方案 4：第三方库"></a>方案 4：第三方库</h3><ul>
<li><p><strong>cross-storage</strong>：<br>提供一个中心化的 <code>Hub</code> 管理跨域存储。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> <span class="title class_">CrossStorageClient</span>(<span class="string">&#x27;https://b.com/hub.html&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写数据</span></span><br><span class="line">storage.<span class="title function_">onConnect</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  storage.<span class="title function_">set</span>(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>); <span class="comment">// 写入 b.com</span></span><br><span class="line">  storage.<span class="title function_">get</span>(<span class="string">&#x27;key&#x27;</span>);          <span class="comment">// 读取 b.com</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="关键注意事项"><a href="#关键注意事项" class="headerlink" title="关键注意事项"></a>关键注意事项</h3><ol>
<li><strong>安全性</strong>：<ul>
<li>使用 <code>postMessage</code> 时严格验证 <code>event.origin</code></li>
<li>避免传输敏感数据</li>
</ul>
</li>
<li><strong>性能</strong>：<ul>
<li>跨域通信有延迟，高频操作需优化</li>
</ul>
</li>
<li><strong>兼容性</strong>：<ul>
<li><code>postMessage</code> 兼容 IE8+，但复杂场景需测试</li>
</ul>
</li>
<li><strong>存储限制</strong>：<ul>
<li>每个域的 <code>localStorage</code> 仍受单独配额限制（通常 5MB）</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/04/%E4%B8%9A%E5%8A%A1/" data-id="cmco867p400001wur8vym0fcv" data-title="业务" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/" rel="tag">场景设计</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Vue" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/03/Vue/" class="article-date">
  <time class="dt-published" datetime="2025-07-03T06:56:58.000Z" itemprop="datePublished">2025-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/03/Vue/">Vue</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/03/Vue/" data-id="cmcn193vc0000zcur260df2wz" data-title="Vue" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-AI" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/01/AI/" class="article-date">
  <time class="dt-published" datetime="2025-07-01T09:52:16.000Z" itemprop="datePublished">2025-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/01/AI/">AI</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h1><p><strong>Model context Protocol 模型上下文协议， 出现在2024.11.25</strong></p>
<p><strong>以一致的方式将各种数据源、工具和功能连接到 AI 模型</strong>（一个中间协议层），就像 USB-C 让不同设备能够通过相同的接口连接一样。MCP 的目标是创建一个通用标准，使 AI 应用程序的开发和集成变得更加简单和统一。</p>
<p><img src="/../img/v2-3a242914e1f4958e631dd158e043b7c3_1440w.jpg"></p>
<p><strong>Function call</strong>   函数调用返回结果作为大模型的补充</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/01/AI/" data-id="cmcle30ei0000usur7rsa5c9q" data-title="AI" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/" rel="tag">大模型</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-React补充" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/07/01/React%E8%A1%A5%E5%85%85/" class="article-date">
  <time class="dt-published" datetime="2025-07-01T02:54:22.000Z" itemprop="datePublished">2025-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/07/01/React%E8%A1%A5%E5%85%85/">React补充</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="React-类组件的this"><a href="#React-类组件的this" class="headerlink" title="React 类组件的this"></a>React 类组件的this</h1><h2 id="this丢失"><a href="#this丢失" class="headerlink" title="this丢失"></a>this丢失</h2><p>类的方法在调用时并没有明确的上下文</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="为什么this会丢失？"><a href="#为什么this会丢失？" class="headerlink" title="为什么this会丢失？"></a>为什么this会丢失？</h3><p>当类方法作为回调传递时（如事件处理函数），<strong>this会丢失绑定</strong>，变成<code>undefined</code>。</p>
<p>原因：</p>
<ul>
<li>JavaScript中的函数有自己的<code>this</code>绑定规则</li>
<li>React事件系统调用处理函数时，不会自动绑定组件实例</li>
<li>类方法默认没有绑定到实例</li>
</ul>
<h3 id="哪些地方容易出现this问题？"><a href="#哪些地方容易出现this问题？" class="headerlink" title="哪些地方容易出现this问题？"></a>哪些地方容易出现this问题？</h3><ul>
<li>事件处理函数（onClick, onChange等）</li>
<li>异步回调函数（setTimeout, Promise等）</li>
<li>将方法作为props传递给子组件</li>
</ul>
<h2 id="绑定this的常见方法"><a href="#绑定this的常见方法" class="headerlink" title="绑定this的常见方法"></a><strong>绑定<code>this</code>的常见方法</strong></h2><p><strong>1</strong>. 在构造函数中绑定</p>
<p>在组件的构造函数中使用<code>bind</code>方法绑定<code>this</code>是最常见的方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 指向组件实例</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式的好处是只需在构造函数中绑定一次，所有的事件处理函数都会使用相同的<code>this</code>。</p>
<p><strong>2. 使用箭头函数</strong></p>
<p>箭头函数没有自己的<code>this</code>，它会捕获其定义时所在上下文的<code>this</code>值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 指向组件实例</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式简洁明了，但需要注意的是，箭头函数可能会引起内存泄漏，尤其是在大型应用中。</p>
<p><strong>3. 在调用时绑定</strong></p>
<p>在事件处理函数被调用时，使用箭头函数绑定<code>this</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 指向组件实例</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.handleClick()&#125;&gt;Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式虽然简单，但每次渲染都会创建一个新的函数，可能会导致性能问题。</p>
<h2 id="常见的陷阱及解决方案"><a href="#常见的陷阱及解决方案" class="headerlink" title="常见的陷阱及解决方案"></a><strong>常见的陷阱及解决方案</strong></h2><p><strong>陷阱1：忘记绑定<code>this</code></strong></p>
<p>忘记绑定<code>this</code>会导致方法调用时<code>this</code>为<code>undefined</code>，从而引发错误。解决方案是在构造函数中绑定<code>this</code>，或者使用箭头函数。</p>
<p><strong>陷阱2：在回调函数中使用<code>this</code></strong></p>
<p>在回调函数中，<code>this</code>的指向可能会发生变化：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 指向组件实例</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这种情况下，使用箭头函数可以确保<code>this</code>的正确指向。</p>
<p><strong>陷阱3：在渲染方法中使用箭头函数</strong></p>
<p>在渲染方法中使用箭头函数会导致每次渲染都创建一个新的函数，影响性能：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.handleClick()&#125;&gt;Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方案是在构造函数中绑定<code>this</code>，或者使用类属性定义箭头函数。</p>
<p>在使用箭头函数时，需要注意性能问题。箭头函数可能会导致组件的渲染性能下降，尤其是在大型应用中。为了避免性能问题，建议在构造函数中绑定<code>this</code>，或者使用类属性定义箭头函数</p>
<h2 id="不需要绑定-this-的情况"><a href="#不需要绑定-this-的情况" class="headerlink" title="不需要绑定 this 的情况"></a>不需要绑定 <code>this</code> 的情况</h2><ul>
<li><strong>生命周期方法</strong>（如 <code>componentDidMount</code>）：React 自动绑定</li>
<li><strong>Render 方法</strong>：React 自动绑定</li>
<li><strong>静态方法</strong>（<code>static</code>）：不访问实例，无需绑定</li>
</ul>
<h1 id="React合成事件顺序"><a href="#React合成事件顺序" class="headerlink" title="React合成事件顺序"></a>React合成事件顺序</h1><p><img src="/../img/image-20250701134656066.png" alt="image-20250701134656066"></p>
<p><img src="/../img/image-20250701134806200.png" alt="image-20250701134806200"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/07/01/React%E8%A1%A5%E5%85%85/" data-id="cmck5rqum0000s4ur1tuognbj" data-title="React补充" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-React" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/29/React/" class="article-date">
  <time class="dt-published" datetime="2025-06-29T13:00:45.000Z" itemprop="datePublished">2025-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/29/React/">React</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><p>由Meta公司研发，是一个用于 构建Web和原生交互界面的库</p>
<p><em>React 是一个用于<strong>构建用户界面的、 声明式、组件化</strong>的 JavaScript 库。</em></p>
<p><strong>主要特点：</strong></p>
<ul>
<li>组件（Component）</li>
<li>声明式界面编程（Declarative UI）</li>
<li>响应式 DOM 更新机制（Reactive DOM updates）</li>
</ul>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>React的常规开发方式并不是通过浏览器引入外部js脚本来使用，但在入门阶段我们暂且先使用这种方式来简单体会一下React。</p>
<p>使用React开发Web项目，我们需要引入两个js脚本：<strong>react 18</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react.development.js</span><br></pre></td></tr></table></figure>

<ul>
<li>react 是react核心库，只要使用react就必须要引入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-dom.development.js</span><br></pre></td></tr></table></figure>

<ul>
<li>react-dom 是react的dom包，使用react开发web应用时必须引入</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello React<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;script/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> button = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;button&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">         <span class="attr">onClick</span>: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&#x27;你点了按钮！&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">            e.<span class="title function_">stopPropagation</span>();</span></span><br><span class="line"><span class="language-javascript">         &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="string">&#x27;我是一个按钮&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> box = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">onClick</span>: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="title function_">alert</span>(<span class="string">&#x27;你点了div！&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">           <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span></span><br><span class="line"><span class="language-javascript">       &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;, <span class="string">&#x27;我是一个div&#x27;</span>, button);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> root = <span class="title class_">ReactDOM</span>.<span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#root&#x27;</span>));</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    root.<span class="title function_">render</span>(box);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>三者的区别</strong></p>
<ul>
<li>react：包含react所必须的核心代码</li>
<li>react-dom：react渲染在不同平台所需要的核心代码</li>
<li>babel：将jsx转换成React代码的工具</li>
</ul>
<h2 id="三个API"><a href="#三个API" class="headerlink" title="三个API"></a>三个API</h2><ul>
<li><pre><code>React.createElement()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `React.createElement(type, [props], [...children])`</span><br><span class="line"></span><br><span class="line">- 参数：</span><br><span class="line"></span><br><span class="line">  type：表示要渲染的**元素类型**。这里可以传入一个元素 Tag 名称，也可以传入一个组件（如div span 等，也可以是是函数组件和类组件）</span><br><span class="line"></span><br><span class="line">  props：**创建React元素所需要的props**。</span><br><span class="line"></span><br><span class="line">  childrens（可选参数）：要渲染元素的子元素，这里可以向后传入n个参数。可以为文本字符串，也可以为数组</span><br><span class="line"></span><br><span class="line">  用来创建React元素</span><br><span class="line"></span><br><span class="line">- React元素无法修改   返回的是虚拟dom对象</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">console.log(</span><br><span class="line">  React.createElement(</span><br><span class="line">    &#x27;h1&#x27;,</span><br><span class="line">    &#123;</span><br><span class="line">      className: &#x27;title&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x27;Hello React&#x27;</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

![img](../img/3058803936-1121353711213220_fix732.png)
返回的这个对象就是虚拟 DOM 了。

我们来分析它返回的对象参数，首先第一个是

- **`$$typeof: REACT_ELEMENT_TYPE`**

这个是 React 元素对象的标识属性

REACT_ELEMENT_TYPE 的值是一个 Symbol 类型，代表了一个独一无二的值。如果浏览器不支持 Symbol类型，值就是一个二进制值。

&gt; 为什么是 Symbol？主要防止 XSS 攻击伪造一个假的 React 组件。**因为 JSON 中是不会存在 Symbol 类型的。**

- key：这个比如循环中会用到这个key值
- props：传入的属性值，比如 id, className, style, children 等
- ref： DOM 的引用
</code></pre>
</li>
<li><pre><code class="language-js">ReactDOM.createRoot()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `createRoot(container[, options])`</span><br><span class="line">- 用来创建React的根容器，容器用来放置React元素</span><br><span class="line"></span><br><span class="line">**`createRoot(domNode, options?)`** </span><br><span class="line"></span><br><span class="line">调用 `createRoot` 以在浏览器 DOM 元素中创建根节点显示内容。</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">import &#123; createRoot &#125; from &#x27;react-dom/client&#x27;;</span><br><span class="line">const domNode = document.getElementById(&#x27;root&#x27;);</span><br><span class="line">const root = createRoot(domNode);</span><br></pre></td></tr></table></figure>

React 将会为 `domNode` 创建一个根节点，并控制其中的 DOM。在已经创建根节点之后，需要调用 [`root.render`](https://zh-hans.react.dev/reference/react-dom/client/createRoot#root-render) 来显示 React 组件：

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>

对于一个完全用 React 构建的应用程序，通常会调用一个 `createRoot` 来创建它的根节点。而对于一个使用了“少量” React 来创建部分内容的应用程序，则要按具体需求来确定根节点的数量。

**参数** 

- `domNode`：一个 [DOM 元素](https://developer.mozilla.org/zh-CN/docs/Web/API/Element)。React 将为这个 DOM 元素创建一个根节点然后允许你在这个根节点上调用函数，比如 `render` 来显示渲染的 React 内容。
- **可选** `options`：用于配置这个 React 根节点的对象。
  - **可选** `onRecoverableError`：回调函数，在 React 从异常错误中恢复时自动调用。
  - **可选** `identifierPrefix`：一个 React 用来配合 [`useId`](https://zh-hans.react.dev/reference/react/useId) 生成 id 的字符串前缀。在同一个页面上使用多个根节点的场景下，这将能有效避免冲突。

**返回值** 

`createRoot` 返回一个带有两个方法的的对象，这两个方法是：[`render`](https://zh-hans.react.dev/reference/react-dom/client/createRoot#root-render) 和 [`unmount`](https://zh-hans.react.dev/reference/react-dom/client/createRoot#root-unmount)。

**注意** 

- 如果应用程序是服务端渲染的，那么不能使用 `createRoot()`。请使用 [`hydrateRoot()`](https://zh-hans.react.dev/reference/react-dom/client/hydrateRoot) 替代它。
- 在你的应用程序中，可能只调用了一次 `createRoot`。但如果你使用了框架，它可能已经自动帮你完成了这次调用。
- 当你想要渲染一段 JSX，但是它存在于 DOM 树的其他位置，并非当前组件的子组件  时（比如，一个弹窗或者提示框），使用 [`createPortal`](https://zh-hans.react.dev/reference/react-dom/createPortal) 替代 `createRoot`。
</code></pre>
</li>
<li><pre><code class="language-js">root.render()
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `root.render(element)`</span><br><span class="line">- 当首次调用时，容器节点里的所有 DOM 元素都会被替换，后续的调用则会使用 React 的 DOM 差分算法（DOM diffing algorithm）进行高效的更新。</span><br><span class="line">- 不会修改容器节点（只会修改容器的子节点）。可以在不覆盖现有子节点的情况下，将组件插入已有的 DOM 节点中。</span><br><span class="line"></span><br><span class="line">**`root.render(reactNode)`** </span><br><span class="line"></span><br><span class="line">调用 `root.render` 以将一段 [JSX](https://zh-hans.react.dev/learn/writing-markup-with-jsx)（“React 节点”）在 React 的根节点中渲染为 DOM 节点并显示。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
root.render(&lt;App /&gt;);
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">React 将会在 `根节点` 中显示 `&lt;App /&gt;` 组件，并且控制组件中的 DOM。</span><br><span class="line"></span><br><span class="line">**参数** </span><br><span class="line"></span><br><span class="line">- `reactNode`：一个你想要显示的 **React 节点**。它总是一段 JSX，就像 `&lt;App /&gt;`，但是你也总是可以传递一个 [`createElement()`](https://zh-hans.react.dev/reference/react/createElement) 构造的 React 元素、一个字符串、一个数字、`null` 或者 `undefined`。</span><br><span class="line"></span><br><span class="line">**返回值** </span><br><span class="line"></span><br><span class="line">`root.render` 返回 `undefined`。</span><br><span class="line"></span><br><span class="line">**注意** </span><br><span class="line"></span><br><span class="line">- 首次调用 `root.render` 时，React 会先清空根节点中所有已经存在的 HTML，然后才会渲染 React 组件。</span><br><span class="line">- 如果你的根节点包含了由 React 在构建期间通过服务端渲染生成的 HTML 内容，请使用 [`hydrateRoot()`](https://zh-hans.react.dev/reference/react-dom/client/hydrateRoot) 替代这个方法，这样才能把事件处理程序和现有的 HTML 绑定。</span><br><span class="line"></span><br><span class="line">如果你在一个根节点上多次调用了 `render`，React 仍然会更新 DOM，这样才能保证显示的内容是最新的。React 将会筛选出可复用的部分和需要更新的部分，对于需要更新的部分，是 React 通过与之前渲染的树进行 [“比较”](https://zh-hans.react.dev/learn/preserving-and-resetting-state) 得到的。在同一个根节点上再次调用 `render` 就和在根节点上调用 [`set` 函数](https://zh-hans.react.dev/reference/react/useState#setstate) 类似：React 会避免没必要的 DOM 更新。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">**`root.unmount()`** </span><br><span class="line"></span><br><span class="line">调用 `root.unmount` 以销毁 React 根节点中的一个已经渲染的树。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
root.unmount();
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  通常情况下，一个完全由 React 构建的应用程序不会调用 `root.unmount`。</span><br><span class="line"></span><br><span class="line">  此方法适用的场景是，React 根节点中的 DOM 节点（或者它的任何一个父级节点）被除了这个方法以外的代码移除了。举个例子，试想在一个 jQuery 选项卡面板中，非活跃状态的选项卡的 DOM 结构将被移除。一个标签页被移除时，它内部的所有内容（包括 React 根节点）也将会从 DOM 树移除。在这种情况下，你才需要调用 `root.unmount` 来通知 React “停止”控制已经被移除的根节点的内容。否则，被移除的根节点的内部组件就不能及时释放消息订阅等资源。</span><br><span class="line"></span><br><span class="line">  调用 `root.unmout` 将卸载根节点内的所有组件，该根节点上的 React 将被剥离，即所有事件处理程序以及组件树上的状态将被移除。</span><br><span class="line"></span><br><span class="line">  **参数** </span><br><span class="line"></span><br><span class="line">  `root.unmount` 不接收任何参数。</span><br><span class="line"></span><br><span class="line">  **返回值** </span><br><span class="line"></span><br><span class="line">  `root.unmount` 返回 `undefined`。</span><br><span class="line"></span><br><span class="line">  **注意事项** </span><br><span class="line"></span><br><span class="line">  - 调用 `root.unmout` 将卸载根节点内的所有组件，该根节点上的 React 将被剥离，即所有事件处理程序以及组件树上的状态将被移除。</span><br><span class="line">  - 一旦调用 `root.unmout`，就不能在该根节点上调用 `root.render`。在一个已经卸载的根节点上尝试调用 `root.render` 将会抛出异常错误信息“无法更新一个未挂载的根节点（Cannot update an unmouted root）”。不过，你可以在卸载一个根节点后又重新创建它</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#  React 、 Vue 异同</span><br><span class="line"></span><br><span class="line">**相似之处：**</span><br><span class="line"></span><br><span class="line">- 都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库</span><br><span class="line">- 都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板。</span><br><span class="line">- 都使用了Virtual DOM（虚拟DOM）提高重绘性能</span><br><span class="line">- 都有props的概念，允许组件间的数据传递</span><br><span class="line">- 都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**不同之处：** </span><br><span class="line"></span><br><span class="line">**1）数据流**</span><br><span class="line"></span><br><span class="line">Vue默认支持数据双向绑定，而React一直提倡单向数据流 </span><br><span class="line"></span><br><span class="line">**2）虚拟DOM**</span><br><span class="line"></span><br><span class="line">Vue2.x开始引入&quot;Virtual DOM&quot;，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。 </span><br><span class="line"></span><br><span class="line">- Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</span><br><span class="line">- 对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent/shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</span><br><span class="line"></span><br><span class="line">**3）组件化**</span><br><span class="line"></span><br><span class="line">React与Vue最大的不同是模板的编写。</span><br><span class="line"></span><br><span class="line">- Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</span><br><span class="line">- React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">具体来讲：React中render函数是支持闭包特性的，所以我们import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 完组件之后，还需要在 components 中再声明下。</span><br><span class="line"></span><br><span class="line">**4）监听数据变化的实现原理不同**</span><br><span class="line"></span><br><span class="line">- Vue 通过 getter/setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</span><br><span class="line">- React 默认是通过比较引用的方式进行的，如果不优化（PureComponent/shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</span><br><span class="line"></span><br><span class="line">**5）高阶组件**</span><br><span class="line"></span><br><span class="line">react可以通过高阶组件（Higher Order Components-- HOC）来扩展，而vue需要通过mixins来扩展。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">原因高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不采用HOC来实现。</span><br><span class="line"></span><br><span class="line">**6）构建工具**</span><br><span class="line"></span><br><span class="line">两者都有自己的构建工具</span><br><span class="line"></span><br><span class="line">- React ==&gt; Create React APP</span><br><span class="line">- Vue ==&gt; vue-cli</span><br><span class="line"></span><br><span class="line">**7）跨平台**</span><br><span class="line"></span><br><span class="line">- React ==&gt; React Native</span><br><span class="line">- Vue ==&gt; Weex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># React 渲染</span><br><span class="line"></span><br><span class="line">##  哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？</span><br><span class="line"></span><br><span class="line">**（1）哪些方法会触发 react 重新渲染?** </span><br><span class="line"></span><br><span class="line">- **setState（）方法被调用**</span><br><span class="line"></span><br><span class="line">setState 是 React 中最常用的命令，通常情况下，执行 setState 会触发 render。但是这里有个点值得关注，执行 setState 的时候不一定会重新渲染。当 setState 传入 null 时，并不会触发 render。</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    a: 1</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&quot;render&quot;);</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragement&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.state.a&#125;&lt;/p&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;() =&gt; &#123;</span><br><span class="line">            this.setState(&#123; a: 1 &#125;); // 这里并没有改变 a 的值</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          Click me</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; this.setState(null)&#125;&gt;setState null&lt;/button&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">      &lt;/React.Fragement&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><strong>父组件重新渲染</strong></p>
</li>
</ul>
<p>只要父组件重新渲染了，即使传入子组件的 props 未发生变化，那么子组件也会重新渲染，进而触发 render</p>
<p><strong>（2）重新渲染 render 会做些什么?</strong></p>
<ul>
<li>会对新旧 VNode 进行对比，也就是我们所说的Diff算法。</li>
<li>对新旧两棵树进行一个深度优先遍历，这样每一个节点都会一个标记，在到深度遍历的时候，每遍历到一和个节点，就把该节点和新的节点树进行对比，如果有差异就放到一个对象里面</li>
<li>遍历差异对象，根据差异的类型，根据对应对规则更新VNode</li>
</ul>
<p>React 的处理 render 的基本思维模式是每次一有变动就会去重新渲染整个应用。在 Virtual DOM 没有出现之前，最简单的方法就是直接调用 innerHTML。Virtual DOM厉害的地方并不是说它比直接操作 DOM 快，而是说不管数据怎么变，都会尽量以最小的代价去更新 DOM。React 将 render 函数返回的虚拟 DOM 树与老的进行比较，从而确定 DOM 要不要更新、怎么更新。当 DOM 树很大时，遍历两棵树进行各种比对还是相当耗性能的，特别是在顶层 setState 一个微小的修改，默认会去遍历整棵树。尽管 React 使用高度优化的 Diff 算法，但是这个过程仍然会损耗性能.</p>
<h2 id="React如何判断什么时候重新渲染组件？"><a href="#React如何判断什么时候重新渲染组件？" class="headerlink" title="React如何判断什么时候重新渲染组件？"></a>React如何判断什么时候重新渲染组件？</h2><p>组件状态的改变可以因为<code>props</code>的改变，或者直接通过<code>setState</code>方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的<code>shouldComponentUpdate</code>方法默认返回<code>true</code>，这就是导致每次更新都重新渲染的原因。</p>
<p>当React将要渲染组件时会执行<code>shouldComponentUpdate</code>方法来看它是否返回<code>true</code>（组件应该更新，也就是重新渲染）。所以需要重写<code>shouldComponentUpdate</code>方法让它根据情况返回<code>true</code>或者<code>false</code>来告诉React什么时候重新渲染什么时候跳过重新渲染。</p>
<h2 id="React-setState-调用的原理"><a href="#React-setState-调用的原理" class="headerlink" title="React setState 调用的原理"></a>React setState 调用的原理</h2><p><img src="/../img/image.png" alt="img"></p>
<p>具体的执行过程如下（源码级解析）：</p>
<ul>
<li>首先调用了<code>setState</code> 入口函数，入口函数在这里就是充当一个分发器的角色，根据入参的不同，将其分发到不同的功能函数中去；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactComponent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setState</span> = <span class="keyword">function</span> (<span class="params">partialState, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueSetState</span>(<span class="variable language_">this</span>, partialState);</span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">updater</span>.<span class="title function_">enqueueCallback</span>(<span class="variable language_">this</span>, callback, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>enqueueSetState</code> 方法将新的 <code>state</code> 放进组件的状态队列里，并调用 <code>enqueueUpdate</code> 来处理将要更新的实例对象；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">enqueueSetState</span>: <span class="keyword">function</span> (<span class="params">publicInstance, partialState</span>) &#123;</span><br><span class="line">  <span class="comment">// 根据 this 拿到对应的组件实例</span></span><br><span class="line">  <span class="keyword">var</span> internalInstance = <span class="title function_">getInternalInstanceReadyForUpdate</span>(publicInstance, <span class="string">&#x27;setState&#x27;</span>);</span><br><span class="line">  <span class="comment">// 这个 queue 对应的就是一个组件实例的 state 数组</span></span><br><span class="line">  <span class="keyword">var</span> queue = internalInstance.<span class="property">_pendingStateQueue</span> || (internalInstance.<span class="property">_pendingStateQueue</span> = []);</span><br><span class="line">  queue.<span class="title function_">push</span>(partialState);</span><br><span class="line">  <span class="comment">//  enqueueUpdate 用来处理当前的组件实例</span></span><br><span class="line">  <span class="title function_">enqueueUpdate</span>(internalInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 <code>enqueueUpdate</code> 方法中引出了一个关键的对象——<code>batchingStrategy</code>，该对象所具备的<code>isBatchingUpdates</code> 属性直接决定了当下是要走更新流程，还是应该排队等待；如果轮到执行，就调用 <code>batchedUpdates</code> 方法来直接发起更新流程。由此可以推测，<code>batchingStrategy</code> 或许正是 React 内部专门用于管控批量更新的对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">enqueueUpdate</span>(<span class="params">component</span>) &#123;</span><br><span class="line">  <span class="title function_">ensureInjected</span>();</span><br><span class="line">  <span class="comment">// 注意这一句是问题的关键，isBatchingUpdates标识着当前是否处于批量创建/更新组件的阶段</span></span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.<span class="property">isBatchingUpdates</span>) &#123;</span><br><span class="line">    <span class="comment">// 若当前没有处于批量创建/更新组件的阶段，则立即更新组件</span></span><br><span class="line">    batchingStrategy.<span class="title function_">batchedUpdates</span>(enqueueUpdate, component);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则，先把组件塞入 dirtyComponents 队列里，让它“再等等”</span></span><br><span class="line">  dirtyComponents.<span class="title function_">push</span>(component);</span><br><span class="line">  <span class="keyword">if</span> (component.<span class="property">_updateBatchNumber</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    component.<span class="property">_updateBatchNumber</span> = updateBatchNumber + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong><code>batchingStrategy</code> 对象可以理解为“锁管理器”。这里的“锁”，是指 React 全局唯一的 <code>isBatchingUpdates</code> 变量，<code>isBatchingUpdates</code> 的初始值是 <code>false</code>，意味着“当前并未进行任何批量更新操作”。每当 React 调用 <code>batchedUpdate</code> 去执行更新动作时，会先把这个锁给“锁上”（置为 <code>true</code>），表明“现在正处于批量更新过程中”。当锁被“锁上”的时候，任何需要更新的组件都只能暂时进入 <code>dirtyComponents</code> 里排队等候下一次的批量更新，而不能随意“插队”。此处体现的“任务锁”的思想，是 React 面对大量状态仍然能够实现有序分批处理的基石。</p>
<p><img src="/../img/v2-9fcf2cfa698301ce7bc78bc3857904ed_1440w.png"></p>
<h2 id="requestIdleCallback、requestAnimationFrame"><a href="#requestIdleCallback、requestAnimationFrame" class="headerlink" title="requestIdleCallback、requestAnimationFrame"></a>requestIdleCallback、requestAnimationFrame</h2><p>浏览器用于优化任务调度的两个关键API，其核心区别在于<strong>执行时机、优先级和适用场景</strong>。以下是详细对比：</p>
<hr>
<h3 id="1-执行时机"><a href="#1-执行时机" class="headerlink" title="1. 执行时机"></a><strong>1. 执行时机</strong></h3><ul>
<li><strong><code>requestAnimationFrame</code>（rAF）</strong><ul>
<li><strong>触发时机</strong>：在浏览器每一帧渲染前执行（约16.6ms&#x2F;次，与屏幕刷新率同步）356。</li>
<li><strong>设计目标</strong>：处理与渲染相关的任务（如动画、UI更新），确保任务在布局和绘制前完成。</li>
<li><strong>特点</strong>：<ul>
<li>高优先级，每帧必定执行；</li>
<li>页面隐藏时自动暂停，节省资源27。</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>requestIdleCallback</code>（rIC）</strong><ul>
<li><strong>触发时机</strong>：在浏览器空闲时段执行（即一帧内主线程任务完成后，剩余时间超过16ms时）158。</li>
<li><strong>设计目标</strong>：处理低优先级、非紧急任务（如日志上报、数据预加载）。</li>
<li><strong>特点</strong>：<ul>
<li>低优先级，可能因浏览器繁忙而跳过执行；</li>
<li>需通过<code>timeout</code>参数强制超时执行（可能引起卡顿）12。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-优先级与性能影响"><a href="#2-优先级与性能影响" class="headerlink" title="2. 优先级与性能影响"></a><strong>2. 优先级与性能影响</strong></h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>rAF</strong></th>
<th align="left"><strong>rIC</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>优先级</strong></td>
<td align="left">高（渲染关键路径）</td>
<td align="left">低（空闲时段）</td>
</tr>
<tr>
<td align="left"><strong>阻塞主线程风险</strong></td>
<td align="left">可能（若任务过重）</td>
<td align="left">极低（任务可拆分）</td>
</tr>
<tr>
<td align="left"><strong>影响FPS</strong></td>
<td align="left">是（若超时导致丢帧）</td>
<td align="left">否（除非强制超时）2</td>
</tr>
<tr>
<td align="left"><strong>执行可靠性</strong></td>
<td align="left">高（每帧必执行）</td>
<td align="left">低（依赖空闲状态）8</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-适用场景"><a href="#3-适用场景" class="headerlink" title="3. 适用场景"></a>3. 适用场景</h3><h5 id="requestAnimationFrame（rAF）"><a href="#requestAnimationFrame（rAF）" class="headerlink" title="requestAnimationFrame（rAF）"></a><strong><code>requestAnimationFrame</code>（rAF）</strong></h5><ul>
<li><strong>动画</strong>：CSS变换、Canvas动画36。</li>
<li><strong>实时UI更新</strong>：滚动效果、WebSocket数据实时渲染38。</li>
<li><strong>高频交互</strong>：确保流畅性，避免<code>setTimeout</code>丢帧56。</li>
</ul>
<h5 id="requestIdleCallback（rIC）"><a href="#requestIdleCallback（rIC）" class="headerlink" title="requestIdleCallback（rIC）"></a><strong><code>requestIdleCallback</code>（rIC）</strong></h5><ul>
<li><strong>非关键任务</strong>：日志上报、性能监控数据批量发送27。</li>
<li><strong>后台计算</strong>：AI推理、大数据处理38。</li>
<li><strong>资源预加载</strong>：非首屏图片或数据35。</li>
</ul>
<blockquote>
<p>💡 <strong>关键区别</strong>：</p>
<ul>
<li>rAF 用于<strong>视觉相关</strong>任务，确保流畅渲染；</li>
<li>rIC 用于<strong>非视觉相关</strong>任务，避免抢占主线程36。</li>
</ul>
</blockquote>
<hr>
<h3 id="4-使用注意事项"><a href="#4-使用注意事项" class="headerlink" title="4. 使用注意事项"></a><strong>4. 使用注意事项</strong></h3><h5 id="rAF-的陷阱"><a href="#rAF-的陷阱" class="headerlink" title="rAF 的陷阱"></a><strong>rAF 的陷阱</strong></h5><ul>
<li><strong>避免重任务</strong>：复杂计算会阻塞渲染，导致卡顿（需拆分任务）8。</li>
<li><strong>隐藏页面暂停</strong>：后台标签页中动画自动停止27。</li>
</ul>
<h5 id="rIC-的陷阱"><a href="#rIC-的陷阱" class="headerlink" title="rIC 的陷阱"></a><strong>rIC 的陷阱</strong></h5><ul>
<li><strong>禁止DOM操作</strong>：<br>空闲时段布局已确定，修改DOM会触发强制重排，严重损害性能15。</li>
<li><strong>慎用Promise</strong>：<br>Promise回调可能在空闲结束后立即执行，拉长帧耗时1。</li>
<li><strong>超时风险</strong>：<br>设置<code>timeout</code>可能强制执行，引发卡顿（超时任务需极轻量）18。</li>
</ul>
<hr>
<h4 id="5-最佳实践"><a href="#5-最佳实践" class="headerlink" title="5. 最佳实践"></a><strong>5. 最佳实践</strong></h4><ol>
<li><strong>混合使用</strong>：<ul>
<li>视觉动画用 <strong>rAF</strong>（如元素移动）6；</li>
<li>非紧急任务用 <strong>rIC</strong>（如埋点上报）27。</li>
</ul>
</li>
<li><strong>任务拆分</strong>：<ul>
<li>在rIC回调中用<code>deadline.timeRemaining()</code>检查剩余时间，分段执行任务58。</li>
</ul>
</li>
<li><strong>兼容性处理</strong>：<ul>
<li>rIC兼容性较差（不支持IE），可用<code>setTimeout(fn, 0)</code>降级8。</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：rIC 分段任务</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">processTasks</span>(<span class="params">deadline</span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (deadline.<span class="title function_">timeRemaining</span>() &gt; <span class="number">0</span> &amp;&amp; tasks.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">executeTask</span>(tasks.<span class="title function_">shift</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (tasks.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="title function_">requestIdleCallback</span>(processTasks, &#123; <span class="attr">timeout</span>: <span class="number">1000</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">requestIdleCallback</span>(processTasks);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="总结：核心区别"><a href="#总结：核心区别" class="headerlink" title="总结：核心区别"></a><strong>总结：核心区别</strong></h3><table>
<thead>
<tr>
<th align="left"><strong>维度</strong></th>
<th align="left"><strong>requestAnimationFrame</strong></th>
<th align="left"><strong>requestIdleCallback</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left">渲染流水线的一部分</td>
<td align="left">空闲时段的任务调度</td>
</tr>
<tr>
<td align="left"><strong>优先级</strong></td>
<td align="left">高（影响用户体验）</td>
<td align="left">低（可被跳过）</td>
</tr>
<tr>
<td align="left"><strong>执行保证</strong></td>
<td align="left">每帧必执行</td>
<td align="left">依赖空闲时间</td>
</tr>
<tr>
<td align="left"><strong>典型场景</strong></td>
<td align="left">动画、实时UI</td>
<td align="left">日志、预加载、后台计算</td>
</tr>
<tr>
<td align="left"><strong>风险操作</strong></td>
<td align="left">避免重计算</td>
<td align="left">禁止DOM修改&#x2F;Promise回调</td>
</tr>
</tbody></table>
<h2 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 跟当前Fiber相关本地状态（比如浏览器环境就是DOM节点）</span></span><br><span class="line">  <span class="attr">stateNode</span>: any,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 单链表树结构</span></span><br><span class="line">  <span class="attr">return</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,<span class="comment">// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回</span></span><br><span class="line">  <span class="attr">child</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,<span class="comment">// 指向自己的第一个子节点</span></span><br><span class="line">  <span class="attr">sibling</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,  <span class="comment">// 指向自己的兄弟结构，兄弟节点的return指向同一个父节点</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新相关</span></span><br><span class="line">  <span class="attr">pendingProps</span>: any,  <span class="comment">// 新的变动带来的新的props</span></span><br><span class="line">  <span class="attr">memoizedProps</span>: any,  <span class="comment">// 上一次渲染完成之后的props</span></span><br><span class="line">  <span class="attr">updateQueue</span>: <span class="title class_">UpdateQueue</span>&lt;any&gt; | <span class="literal">null</span>,  <span class="comment">// 该Fiber对应的组件产生的Update会存放在这个队列里面</span></span><br><span class="line">  <span class="attr">memoizedState</span>: any, <span class="comment">// 上一次渲染的时候的state</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Scheduler 相关</span></span><br><span class="line">  <span class="attr">expirationTime</span>: <span class="title class_">ExpirationTime</span>,  <span class="comment">// 代表任务在未来的哪个时间点应该被完成，不包括他的子树产生的任务</span></span><br><span class="line">  <span class="comment">// 快速确定子树中是否有不在等待的变化</span></span><br><span class="line">  <span class="attr">childExpirationTime</span>: <span class="title class_">ExpirationTime</span>,</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 在Fiber树更新的过程中，每个Fiber都会有一个跟其对应的Fiber</span></span><br><span class="line">  <span class="comment">// 我们称他为`current &lt;==&gt; workInProgress`</span></span><br><span class="line">  <span class="comment">// 在渲染完成之后他们会交换位置</span></span><br><span class="line">  <span class="attr">alternate</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Effect 相关的</span></span><br><span class="line">  <span class="attr">effectTag</span>: <span class="title class_">SideEffectTag</span>, <span class="comment">// 用来记录Side Effect</span></span><br><span class="line">  <span class="attr">nextEffect</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>, <span class="comment">// 单链表用来快速查找下一个side effect</span></span><br><span class="line">  <span class="attr">firstEffect</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>,  <span class="comment">// 子树中第一个side effect</span></span><br><span class="line">  <span class="attr">lastEffect</span>: <span class="title class_">Fiber</span> | <span class="literal">null</span>, <span class="comment">// 子树中最后一个side effect</span></span><br><span class="line">  ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p><img src="/../img/v2-cfaea6c0e9362b3701b1cf342ed4588b_1440w.png"></p>
<h3 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a><strong>构建流程</strong></h3><ol>
<li><p><strong>根节点启动</strong>：</p>
<ul>
<li>从根 Fiber 节点开始</li>
<li>创建对应的 WIP 节点（<code>workInProgressRoot</code>）</li>
</ul>
</li>
<li><p><strong>节点克隆&#x2F;创建</strong>：</p>
<ul>
<li>检查当前节点是否有对应的 <code>alternate</code>（上次渲染的 Fiber）</li>
<li>有则克隆，无则创建全新 Fiber 节点</li>
</ul>
</li>
<li><p><strong>属性继承</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复用状态和属性</span></span><br><span class="line">workInProgress.<span class="property">memoizedState</span> = current.<span class="property">memoizedState</span>;</span><br><span class="line">workInProgress.<span class="property">memoizedProps</span> = current.<span class="property">memoizedProps</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>子节点处理</strong>：</p>
<ul>
<li>递归处理每个子节点</li>
<li>创建子 Fiber 节点并建立父子关系</li>
<li>设置 <code>child</code>、<code>sibling</code>、<code>return</code> 指针</li>
</ul>
</li>
<li><p><strong>深度优先遍历</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">workLoopSync</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress = <span class="title function_">performUnitOfWork</span>(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>完成节点</strong>：</p>
<ul>
<li>当节点没有子节点时，调用 <code>completeUnitOfWork</code></li>
<li>处理兄弟节点或回溯到父节点</li>
</ul>
</li>
<li><p>指针关系示例</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父节点</span></span><br><span class="line"><span class="keyword">const</span> parentFiber = &#123;</span><br><span class="line">  <span class="attr">child</span>: child1, <span class="comment">// 第一个子节点</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子节点1</span></span><br><span class="line"><span class="keyword">const</span> child1 = &#123;</span><br><span class="line">  <span class="attr">sibling</span>: child2, <span class="comment">// 下一个兄弟节点</span></span><br><span class="line">  <span class="attr">return</span>: parentFiber, <span class="comment">// 指向父节点</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子节点2</span></span><br><span class="line"><span class="keyword">const</span> child2 = &#123;</span><br><span class="line">  <span class="attr">sibling</span>: <span class="literal">null</span>, <span class="comment">// 最后一个节点</span></span><br><span class="line">  <span class="attr">return</span>: parentFiber,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Diff-算法核心原则"><a href="#Diff-算法核心原则" class="headerlink" title="Diff 算法核心原则"></a>Diff 算法核心原则</h3><table>
<thead>
<tr>
<th align="left">原则</th>
<th align="left">描述</th>
<th align="left">优势</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>同级比较</strong></td>
<td align="left">只比较同一层级节点</td>
<td align="left">O(n) 复杂度</td>
</tr>
<tr>
<td align="left"><strong>Key 优化</strong></td>
<td align="left">使用 key 匹配相同节点</td>
<td align="left">减少不必要的重建</td>
</tr>
<tr>
<td align="left"><strong>类型优先</strong></td>
<td align="left">不同类型组件直接替换</td>
<td align="left">避免无效比较</td>
</tr>
<tr>
<td align="left"><strong>组件稳定</strong></td>
<td align="left">相同类型组件复用</td>
<td align="left">保留状态和 DOM</td>
</tr>
</tbody></table>
<p><img src="/../img/v2-8c3b88ee7471ba1303c4460967da36fa_1440w.png"></p>
<h1 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a><strong>React 组件</strong></h1><h2 id="React-高阶组件是什么，和普通组件有什么区别，适用什么场景"><a href="#React-高阶组件是什么，和普通组件有什么区别，适用什么场景" class="headerlink" title="React 高阶组件是什么，和普通组件有什么区别，适用什么场景"></a>React 高阶组件是什么，和普通组件有什么区别，适用什么场景</h2><p>官方解释∶ </p>
<p>高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。</p>
<p>高阶组件（HOC）就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件，它只是一种组件的设计模式，这种设计模式是由react自身的组合性质必然产生的。我们将它们称为纯组件，因为它们可以接受任何动态提供的子组件，但它们不会修改或复制其输入组件中的任何行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hoc的定义</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withSubscription</span>(<span class="params">WrappedComponent, selectData</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>(props);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">        <span class="attr">data</span>: <span class="title function_">selectData</span>(<span class="title class_">DataSource</span>, props)</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一些通用的逻辑处理</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// ... 并使用新数据渲染被包装的组件!</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BlogPostWithSubscription</span> = <span class="title function_">withSubscription</span>(<span class="title class_">BlogPost</span>,</span><br><span class="line">  <span class="function">(<span class="params">DataSource, props</span>) =&gt;</span> <span class="title class_">DataSource</span>.<span class="title function_">getBlogPost</span>(props.<span class="property">id</span>));</span><br></pre></td></tr></table></figure>

<p><strong>1）HOC的优缺点</strong></p>
<ul>
<li>优点∶ 逻辑服用、不影响被包裹组件的内部逻辑。</li>
<li>缺点∶hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖</li>
</ul>
<p><strong>2）适用场景</strong></p>
<ul>
<li>代码复用，逻辑抽象 </li>
<li>渲染劫持 </li>
<li>State 抽象和更改 </li>
<li>Props 更改</li>
</ul>
<p><strong>3）具体应用例子</strong> </p>
<ul>
<li>**权限控制：**利用高阶组件的 <strong>条件渲染</strong> 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别和 页面元素级别</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HOC.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withAdminAuth</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">        state = &#123;</span><br><span class="line">            <span class="attr">isAdmin</span>: <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">UNSAFE_componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> currentRole = <span class="keyword">await</span> <span class="title function_">getCurrentUserRole</span>();</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">                <span class="attr">isAdmin</span>: currentRole === <span class="string">&#x27;Admin&#x27;</span>,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isAdmin</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>您没有权限查看该页面，请联系管理员！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/page-a.js</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PageA</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="comment">// something here...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">UNSAFE_componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// fetching data</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// render page with data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">withAdminAuth</span>(<span class="title class_">PageA</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/page-b.js</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PageB</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="comment">// something here...</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="title function_">UNSAFE_componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// fetching data</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// render page with data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">withAdminAuth</span>(<span class="title class_">PageB</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>**组件渲染性能追踪：**借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录∶</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Home</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">withTiming</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">WrappedComponent</span> &#123;</span><br><span class="line">            <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">                <span class="variable language_">super</span>(props);</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">start</span> = <span class="number">0</span>;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">end</span> = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">UNSAFE_componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">super</span>.<span class="property">componentWillMount</span> &amp;&amp; <span class="variable language_">super</span>.<span class="title function_">componentWillMount</span>();</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">start</span> = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="variable language_">super</span>.<span class="property">componentDidMount</span> &amp;&amp; <span class="variable language_">super</span>.<span class="title function_">componentDidMount</span>();</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">end</span> = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">                <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;WrappedComponent.name&#125;</span> 组件渲染时间为 <span class="subst">$&#123;<span class="variable language_">this</span>.end - <span class="variable language_">this</span>.start&#125;</span> ms`</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable language_">super</span>.<span class="title function_">render</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">withTiming</span>(<span class="title class_">Home</span>);   </span><br></pre></td></tr></table></figure>

<p>注意：withTiming 是利用 反向继承 实现的一个高阶组件，功能是计算被包裹组件（这里是 Home 组件）的渲染时间。</p>
<ul>
<li><strong>页面复用</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">withFetching</span> = fetching =&gt; <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">        state = &#123;</span><br><span class="line">            <span class="attr">data</span>: [],</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">async</span> <span class="title function_">UNSAFE_componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">fetching</span>();</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">                data,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> <span class="attr">data</span>=<span class="string">&#123;this.state.data&#125;</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pages/page-a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">withFetching</span>(<span class="title function_">fetching</span>(<span class="string">&#x27;science-fiction&#x27;</span>))(<span class="title class_">MovieList</span>);</span><br><span class="line"><span class="comment">// pages/page-b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">withFetching</span>(<span class="title function_">fetching</span>(<span class="string">&#x27;action&#x27;</span>))(<span class="title class_">MovieList</span>);</span><br><span class="line"><span class="comment">// pages/page-other.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">withFetching</span>(<span class="title function_">fetching</span>(<span class="string">&#x27;some-other-type&#x27;</span>))(<span class="title class_">MovieList</span>);</span><br></pre></td></tr></table></figure>





<h2 id="类组件与函数组件有什么异同"><a href="#类组件与函数组件有什么异同" class="headerlink" title="类组件与函数组件有什么异同"></a>类组件与函数组件有什么异同</h2><p><strong>相同点：</strong></p>
<p><strong>组件是 React 可复用的最小代码片段</strong>，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。</p>
<p>我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。</p>
<p><strong>不同点：</strong></p>
<ul>
<li>它们在开发时的心智模型上却存在巨大的差异。<strong>类组件是基于面向对象编程的</strong>，它主打的是继承、生命周期等核心概念；而<strong>函数组件内核是函数式编程</strong>，主打的是 immutable、没有副作用、引用透明等特点。</li>
<li>之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。</li>
<li>性能优化上，<strong>类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能</strong>，<br>                而<strong>函数组件依靠 React.memo 缓存渲染结果来提升性能</strong>。</li>
<li>从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。</li>
<li>类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且<strong>在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用</strong>，更能适应 React 的未来发展。</li>
</ul>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ul>
<li><strong>⽗组件向⼦组件通讯</strong>: ⽗组件可以向⼦组件通过传 props 的⽅式，向⼦组件进⾏通讯 </li>
<li><strong>⼦组件向⽗组件通讯</strong>: props+回调的⽅式，⽗组件向⼦组件传递props进⾏通讯，此props为作⽤域为⽗组件⾃身的函 数，⼦组件调⽤该函数，将⼦组件想要传递的信息，作为参数，传递到⽗组件的作⽤域中 </li>
<li><strong>兄弟组件通信</strong>: 找到这两个兄弟节点共同的⽗节点,结合上⾯两种⽅式由⽗节点转发信息进⾏通信 </li>
<li><strong>跨层级通信</strong>: Context 设计⽬的是为了共享那些对于⼀个组件树⽽⾔是“全局”的数据，例如当前认证的⽤户、主题或⾸选语⾔，对于跨越多层的全局数据通过 Context 通信再适合不过 </li>
<li><strong>发布订阅模式</strong>: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引⼊event模块进⾏通信 </li>
<li><strong>全局状态管理⼯具</strong>: 借助Redux或者Mobx等全局状态管理⼯具进⾏通信,这种⼯具会维护⼀个全局状态中⼼Store,并根据不同的事件产⽣新的状态</li>
</ul>
<h1 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h1><p>一个事件触发后，会在子元素和父元素之间传播（propagation）。这种传播分成三个阶段</p>
<p><img src="/../img/2019011111581623.jpg" alt="img"></p>
<p>如上图所示，事件传播分成三个阶段：</p>
<p>捕获阶段：从window对象传导到目标节点（上层传到底层）称为“捕获阶段”（capture phase），捕获阶段不会响应任何事件；<br>目标阶段：在目标节点上触发，称为“目标阶段”<br>冒泡阶段：从目标节点传导回window对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；<br><strong>事件代理</strong></p>
<p>事件代理（Event Delegation），又称之为事件委托。是JavaScript中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown……）委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡在React中事件需要通过元素的属性来设置，</p>
<h3 id="React-事件机制"><a href="#React-事件机制" class="headerlink" title="React 事件机制"></a>React 事件机制</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)&#125;&gt;点我&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>React并不是将click事件绑定到了div的真实DOM上，而是<strong>在document处监听了所有的事件，当事件发生并且<font color="red">冒泡</font>到document处的时候，React将事件内容封装并交由真正的处理函数运行</strong>。这样的方式不仅仅减少了内存的消耗，还能在组件挂在销毁时统一订阅和移除事件。</p>
<p>React <strong>基于 Virtual DOM 实现了一个SyntheticEvent（合成事件）层，我们所定义的事件处理器会接收到一个SyntheticEvent对象的实例</strong>。与原生事件直接在元素上注册的方式不同的是，react的合成事件不会直接绑定到目标dom节点上，用事件委托机制，以队列的方式，从触发事件的组件向父组件回溯直到document节点，因此<strong>React组件上声明的事件最终绑定到了document 上</strong>。用一个统一的监听器去监听，这个监听器上保存着目标节点与事件对象的映射，当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用</p>
<p>除此之外，冒泡到document上的事件也不是原生的浏览器事件，而是由react自己实现的合成事件（SyntheticEvent）。因此如果不想要是事件冒泡的话应该调用<strong>event.preventDefault()方法</strong>，而不是调用event.stopProppagation()方法。</p>
<p><img src="/../img/77fa6b2a59c92e160bc171f9c80783e7.jpg" alt="img"></p>
<p><strong>JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 <code>document</code> 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</strong></p>
<p>另外冒泡到 <code>document</code> 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 <code>event.stopPropagation</code> 是无效的，而应该调用 <code>event.preventDefault</code>。</p>
<p>实现合成事件的目的如下：</p>
<ul>
<li>合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力；</li>
<li>对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。</li>
</ul>
<h3 id="React的事件和普通的HTML事件有什么不同？"><a href="#React的事件和普通的HTML事件有什么不同？" class="headerlink" title="React的事件和普通的HTML事件有什么不同？"></a>React的事件和普通的HTML事件有什么不同？</h3><p>区别：</p>
<ul>
<li><p>对于事件名称命名方式，原生事件为全小写，<strong>react 事件采用小驼峰</strong>；</p>
</li>
<li><p>对于事件函数处理语法，原生事件为字符串，<strong>react 事件为函数</strong>； </p>
<p>和原生JS不同，在React中事件的属性需要使用驼峰命名法：</p>
<p>onclick -&gt; onClick</p>
<p>onchange -&gt; onChange</p>
<p>属性值不能直接执行代码，而是需要一个回调函数：</p>
<p>onclick&#x3D;”alert(123)”<br>onClick&#x3D;{()&#x3D;&gt;{alert(123)}}<br>onClick&#x3D;{handler}</p>
</li>
<li><p>react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用<code>preventDefault()</code>来阻止默认行为。</p>
</li>
</ul>
<p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：</p>
<ul>
<li>兼容所有浏览器，更好的跨平台；</li>
<li>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</li>
<li>方便 react 统一管理和事务机制。</li>
</ul>
<p>事件的执行顺序为<strong>原生事件先执行，合成事件后执行</strong>，<strong>合成事件会冒泡绑定到 document 上</strong>，所以尽量避免原生事件与合成事件混用，如果<strong>原生事件阻止冒泡，可能会导致合成事件不执行</strong>，因为需要冒泡到document 上合成事件才会执行。</p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p><img src="/../img/image-20240225161622185.png" alt="image-20240225161622185"></p>
<p><strong>新的生命周期</strong></p>
<p><img src="/../img/image-20240225160610933.png" alt="image-20240225160610933"></p>
<h2 id="React的生命周期有哪些？"><a href="#React的生命周期有哪些？" class="headerlink" title="React的生命周期有哪些？"></a>React的生命周期有哪些？</h2><p> React 通常将组件生命周期分为三个阶段：</p>
<ul>
<li>装载阶段（Mount），组件第一次在DOM树中被渲染的过程；</li>
<li>更新过程（Update），组件状态发生变化，重新更新渲染的过程；</li>
<li>卸载过程（Unmount），组件从DOM树中被移除的过程；</li>
</ul>
<p><img src="/../img/image1111111.png" alt="img"></p>
<h3 id="1）组件挂载阶段"><a href="#1）组件挂载阶段" class="headerlink" title="1）组件挂载阶段"></a>1）组件挂载阶段</h3><p>挂载阶段组件被创建，然后组件实例插入到 DOM 中，完成组件的第一次渲染，该过程只会发生一次，在此阶段会依次调用以下这些方法：</p>
<ul>
<li>constructor</li>
<li>getDerivedStateFromProps</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<h4 id="（1）constructor"><a href="#（1）constructor" class="headerlink" title="（1）constructor"></a>（1）constructor</h4><p>组件的构造函数，第一个被执行，若没有显式定义它，会有一个默认的构造函数，但是若显式定义了构造函数，我们必须在构造函数中执行 <code>super(props)</code>，否则无法在构造函数中拿到this。</p>
<p>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数<strong>Constructor</strong>。</p>
<p>constructor中通常只做两件事： </p>
<ul>
<li>初始化组件的 state</li>
<li>给事件处理方法绑定 this</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="variable language_">super</span>(props);</span><br><span class="line">  <span class="comment">// 不要在构造函数中调用 setState，可以直接给 state 设置初始值</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">counter</span>: <span class="number">0</span> &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（2）getDerivedStateFromProps"><a href="#（2）getDerivedStateFromProps" class="headerlink" title="（2）getDerivedStateFromProps"></a>（2）getDerivedStateFromProps</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(props, state)</span><br></pre></td></tr></table></figure>

<p>这是个静态方法，所以不能在这个函数里使用 <code>this</code>，有两个参数 <code>props</code> 和 <code>state</code>，分别指接收到的新参数和当前组件的 <code>state</code> 对象，这个函数会返回一个对象用来更新当前的 <code>state</code> 对象，如果不需要更新可以返回 <code>null</code>。</p>
<p>该函数会在装载时，接收到新的 <code>props</code> 或者调用了 <code>setState</code> 和 <code>forceUpdate</code> 时被调用。如当接收到新的属性想修改 <code>state</code> ，就可以使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当 props.counter 变化时，赋值给 state </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">props, state</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">counter</span> !== state.<span class="property">counter</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">counter</span>: props.<span class="property">counter</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Hello, world!&#123;this.state.counter&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以显式传入 <code>counter</code> ，但是这里有个问题，如果想要通过点击实现 <code>state.counter</code> 的增加，但这时会发现值不会发生任何变化，一直保持 <code>props</code> 传进来的值。这是由于在 React 16.4^ 的版本中 <code>setState</code> 和 <code>forceUpdate</code> 也会触发这个生命周期，所以当组件内部 <code>state</code> 变化后，就会重新走这个方法，同时会把 <code>state</code> 值赋值为 <code>props</code> 的值。因此需要多加一个字段来记录之前的 <code>props</code> 值，这样就会解决上述问题。具体如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里只列出需要变化的地方</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="comment">// 增加一个 preCounter 来记录之前的 props 传来的值</span></span><br><span class="line">      <span class="attr">preCounter</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">props, state</span>) &#123;</span><br><span class="line">    <span class="comment">// 跟 state.preCounter 进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">counter</span> !== state.<span class="property">preCounter</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">counter</span>: props.<span class="property">counter</span>,</span><br><span class="line">        <span class="attr">preCounter</span>: props.<span class="property">counter</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Hello, world!&#123;this.state.counter&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（3）render"><a href="#（3）render" class="headerlink" title="（3）render"></a>（3）render</h4><p>render是React 中最核心的方法，一个组件中必须要有这个方法，它会根据状态 <code>state</code> 和属性 <code>props</code> 渲染组件。这个函数只做一件事，就是返回需要渲染的内容，所以不要在这个函数内做其他业务逻辑，通常调用该方法会返回以下类型中一个：</p>
<ul>
<li><strong>React 元素</strong>：这里包括原生的 DOM 以及 React 组件；</li>
<li><strong>数组和 Fragment（片段）</strong>：可以返回多个元素；</li>
<li><strong>Portals（插槽）</strong>：可以将子元素渲染到不同的 DOM 子树种；</li>
<li><strong>字符串和数字</strong>：被渲染成 DOM 中的 text 节点；</li>
<li><strong>布尔值或 null</strong>：不渲染任何内容。</li>
</ul>
<h4 id="（4）componentDidMount"><a href="#（4）componentDidMount" class="headerlink" title="（4）componentDidMount()"></a>（4）componentDidMount()</h4><p>componentDidMount()会在组件挂载后（插入 DOM 树中）立即调。该阶段通常进行以下操作：</p>
<ul>
<li>执行依赖于DOM的操作；</li>
<li>发送网络请求；（官方建议）</li>
<li>添加订阅消息（会在componentWillUnmount取消订阅）；</li>
</ul>
<p>如果在 <code>componentDidMount</code> 中调用 <code>setState</code> ，就会触发一次额外的渲染，多调用了一次 <code>render</code> 函数，由于它是在浏览器刷新屏幕前执行的，所以用户对此是没有感知的，但是我应当避免这样使用，这样会带来一定的性能问题，尽量是在 <code>constructor</code> 中初始化 <code>state</code> 对象。</p>
<p>在组件装载之后，将计数数字变为1：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>  &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span> () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">counter</span>: <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span> ()  &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;counter&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        counter值: &#123; this.state.counter &#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2）组件更新阶段"><a href="#2）组件更新阶段" class="headerlink" title="2）组件更新阶段"></a>2）组件更新阶段</h3><p>当组件的 <code>props</code> 改变了，或组件内部调用了 <code>setState/forceUpdate</code>，会触发更新重新渲染，这个过程可能会发生多次。这个阶段会依次调用下面这些方法：</p>
<ul>
<li>getDerivedStateFromProps</li>
<li>shouldComponentUpdate</li>
<li>render</li>
<li>getSnapshotBeforeUpdate</li>
<li>componentDidUpdate</li>
</ul>
<h4 id="（1）shouldComponentUpdate"><a href="#（1）shouldComponentUpdate" class="headerlink" title="（1）shouldComponentUpdate"></a>（1）shouldComponentUpdate</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(nextProps, nextState)</span><br></pre></td></tr></table></figure>

<p>在说这个生命周期函数之前，来看两个问题：</p>
<ul>
<li><strong>setState 函数在任何情况下都会导致组件重新渲染吗？例如下面这种情况：</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">number</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">number</span>&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>如果没有调用 setState，props 值也没有变化，是不是组件就不会重新渲染？</strong></li>
</ul>
<p>第一个问题答案是 <strong>会</strong> ，第二个问题如果是父组件重新渲染时，不管传入的 props 有没有变化，都会引起子组件的重新渲染。</p>
<p>那么有没有什么方法解决在这两个场景下不让组件重新渲染进而提升性能呢？这个时候 <code>shouldComponentUpdate</code> 登场了，这个生命周期函数是用来提升速度的，它是在重新渲染组件开始前触发的，默认返回 <code>true</code>，可以比较 <code>this.props</code> 和 <code>nextProps</code> ，<code>this.state</code> 和 <code>nextState</code> 值是否变化，来确认返回 true 或者 <code>false</code>。当返回 <code>false</code> 时，组件的更新过程停止，后续的 <code>render</code>、<code>componentDidUpdate</code> 也不会被调用。</p>
<p>**注意：**添加 <code>shouldComponentUpdate</code> 方法时，不建议使用深度相等检查（如使用 <code>JSON.stringify()</code>），因为深比较效率很低，可能会比重新渲染组件效率还低。而且该方法维护比较困难，建议使用该方法会产生明显的性能提升时使用。</p>
<h4 id="（2）getSnapshotBeforeUpdate"><a href="#（2）getSnapshotBeforeUpdate" class="headerlink" title="（2）getSnapshotBeforeUpdate"></a>（2）getSnapshotBeforeUpdate</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getSnapshotBeforeUpdate</span>(prevProps, prevState)</span><br></pre></td></tr></table></figure>

<p>这个方法在 <code>render</code> 之后，<code>componentDidUpdate</code> 之前调用，有两个参数 <code>prevProps</code> 和 <code>prevState</code>，表示更新之前的 <code>props</code> 和 <code>state</code>，这个函数必须要和 <code>componentDidUpdate</code> 一起使用，并且要有一个返回值，默认是 <code>null</code>，这个返回值作为第三个参数传给 <code>componentDidUpdate</code>。</p>
<h4 id="（3）componentDidUpdate"><a href="#（3）componentDidUpdate" class="headerlink" title="（3）componentDidUpdate"></a>（3）componentDidUpdate</h4><p>componentDidUpdate() 会在更新后会被立即调用，首次渲染不会执行此方法。 该阶段通常进行以下操作：</p>
<ul>
<li>当组件更新后，对 DOM 进行操作； </li>
<li>如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求；（例如，当 props 未发生变化时，则不会执行网络请求）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshot</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>该方法有三个参数：</p>
<ul>
<li>prevProps: 更新前的props</li>
<li>prevState: 更新前的state</li>
<li>snapshot: getSnapshotBeforeUpdate()生命周期的返回值</li>
</ul>
<h3 id="3）组件卸载阶段"><a href="#3）组件卸载阶段" class="headerlink" title="3）组件卸载阶段"></a>3）组件卸载阶段</h3><p>卸载阶段只有一个生命周期函数，componentWillUnmount() 会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作：</p>
<ul>
<li>清除 timer，取消网络请求或清除</li>
<li>取消在 componentDidMount() 中创建的订阅等；</li>
</ul>
<p>这个生命周期在一个组件被卸载和销毁之前被调用，因此你不应该再这个方法中使用 <code>setState</code>，因为组件一旦被卸载，就不会再装载，也就不会重新渲染。</p>
<h3 id="4）错误处理阶段"><a href="#4）错误处理阶段" class="headerlink" title="4）错误处理阶段"></a>4）错误处理阶段</h3><p>componentDidCatch(error, info)，此生命周期在后代组件抛出错误后被调用。 它接收两个参数∶</p>
<ul>
<li>error：抛出的错误。</li>
<li>info：带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息</li>
</ul>
<p>React常见的生命周期如下：</p>
<p><img src="/../img/image222222.png" alt="img"></p>
<p><strong>React常见生命周期的过程大致如下：</strong></p>
<ul>
<li>挂载阶段，首先执行constructor构造方法，来创建组件</li>
<li>创建完成之后，就会执行render方法，该方法会返回需要渲染的内容</li>
<li>随后，React会将需要渲染的内容挂载到DOM树上</li>
<li><strong>挂载完成之后就会执行****componentDidMount生命周期函数</strong></li>
<li>如果我们给组件创建一个props（用于组件通信）、调用setState（更改state中的数据）、调用forceUpdate（强制更新组件）时，都会重新调用render函数</li>
<li>render函数重新执行之后，就会重新进行DOM树的挂载</li>
<li><strong>挂载完成之后就会执行****componentDidUpdate生命周期函数</strong></li>
<li><strong>当移除组件时，就会执行****componentWillUnmount生命周期函数</strong></li>
</ul>
<p><strong>React主要生命周期总结：</strong></p>
<ol>
<li><strong>getDefaultProps</strong>：这个函数会在组件创建之前被调用一次（有且仅有一次），它被用来初始化组件的 Props；</li>
<li><strong>getInitialState</strong>：用于初始化组件的 state 值；</li>
<li><strong>componentWillMount</strong>：在组件创建后、render 之前，会走到 componentWillMount 阶段。这个阶段我个人一直没用过、非常鸡肋。后来React 官方已经不推荐大家在 componentWillMount 里做任何事情、到现在 <strong>React16 直接废弃了这个生命周期</strong>，足见其鸡肋程度了；</li>
<li><strong>render</strong>：这是所有生命周期中唯一一个你必须要实现的方法。一般来说需要返回一个 jsx 元素，这时 React 会根据 props 和 state 来把组件渲染到界面上；不过有时，你可能不想渲染任何东西，这种情况下让它返回 null 或者 false 即可；</li>
<li><strong>componentDidMount</strong>：会在组件挂载后（插入 DOM 树中后）立即调用，标志着组件挂载完成。一些操作如果依赖获取到 DOM 节点信息，我们就会放在这个阶段来做。此外，这还是 React 官方推荐的发起 ajax 请求的时机。该方法和 componentWillMount 一样，有且仅有一次调用。</li>
</ol>
<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p><img src="/../img/image-20240225215635333.png" alt="image-20240225215635333"></p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><h3 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h3><p><code>createStore</code> 函数通常是用于创建 Redux store 的函数。Redux 是一个用于管理 JavaScript 应用程序状态的流行库。让我们来解析 <code>createStore</code> 函数的一般结构和作用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) &#123;</span><br><span class="line">  <span class="comment">// 内部状态 state</span></span><br><span class="line">  <span class="keyword">let</span> currentState = preloadedState;</span><br><span class="line">  <span class="comment">// 内部订阅者列表</span></span><br><span class="line">  <span class="keyword">let</span> currentListeners = [];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取当前状态</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> currentState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改状态的唯一方式，通过派发 action</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">dispatch</span>(<span class="params">action</span>) &#123;</span><br><span class="line">    <span class="comment">// 调用 reducer 来获取新的状态</span></span><br><span class="line">    currentState = <span class="title function_">reducer</span>(currentState, action);</span><br><span class="line">    <span class="comment">// 触发所有订阅者</span></span><br><span class="line">    currentListeners.<span class="title function_">forEach</span>(<span class="function"><span class="params">listener</span> =&gt;</span> <span class="title function_">listener</span>());</span><br><span class="line">    <span class="keyword">return</span> action;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅状态的变化，每当状态变化时执行回调函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">subscribe</span>(<span class="params">listener</span>) &#123;</span><br><span class="line">    <span class="comment">// 将传入的回调函数加入到订阅者列表中</span></span><br><span class="line">    currentListeners.<span class="title function_">push</span>(listener);</span><br><span class="line">    <span class="comment">// 返回一个取消订阅的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">unsubscribe</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 将该回调函数从订阅者列表中移除</span></span><br><span class="line">      <span class="keyword">const</span> index = currentListeners.<span class="title function_">indexOf</span>(listener);</span><br><span class="line">      currentListeners.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 替换 reducer 的函数，用于动态地改变 reducer</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">replaceReducer</span>(<span class="params">nextReducer</span>) &#123;</span><br><span class="line">    reducer = nextReducer;</span><br><span class="line">    <span class="comment">// 调用 dispatch 一个内置的动作，以便更新状态</span></span><br><span class="line">    <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;@@redux/INIT&#x27;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 store，调用 reducer 以获取初始状态，并返回一个 store 对象</span></span><br><span class="line">  <span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;@@redux/INIT&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回 store 对象，包含 getState、dispatch、subscribe 和 replaceReducer 方法</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    dispatch,</span><br><span class="line">    subscribe,</span><br><span class="line">    getState,</span><br><span class="line">    replaceReducer</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在让我来解释一下 <code>createStore</code> 函数的各个部分：</p>
<ol>
<li><p><strong>参数</strong>：</p>
<p>​    在 <code>createStore</code> 函数中涉及到的核心数据类型主要有以下几种：</p>
<ol>
<li><strong>reducer</strong>：<code>reducer</code> 是一个函数，接收当前状态 (<code>state</code>) 和一个动作 (<code>action</code>)，并返回一个新的状态。它是一个纯函数，通常是通过 <code>switch</code> 语句来根据不同的动作类型进行状态更新的。动作类型通常是一个字符串，表示对状态进行何种操作，例如 <code>&#39;INCREMENT&#39;</code>、<code>&#39;DECREMENT&#39;</code> 等。</li>
<li><strong>preloadedState</strong>：<code>preloadedState</code> 是一个 JavaScript 对象，表示应用程序的初始状态。它是可选的，如果不提供则状态将被初始化为 <code>undefined</code>，然后在调用 <code>reducer</code> 时被设置为 <code>reducer</code> 函数的默认值。</li>
<li><strong>currentState</strong>：<code>currentState</code> 是一个变量，用于存储当前的应用程序状态。它会随着动作的派发而改变，通过调用 <code>reducer</code> 函数计算出新的状态。</li>
<li><strong>currentListeners</strong>：<code>currentListeners</code> 是一个数组，用于存储所有订阅状态变化的回调函数。每当状态发生变化时，这些回调函数将会被依次调用。</li>
<li><strong>action</strong>：<code>action</code> 是一个普通的 JavaScript 对象，必须包含一个 <code>type</code> 字段，表示动作的类型。除了 <code>type</code> 字段之外，<code>action</code> 对象可以包含其他字段，用于传递数据给 <code>reducer</code> 函数。</li>
<li><strong>store</strong>：<code>store</code> 是一个对象，包含了 <code>dispatch</code>、<code>subscribe</code>、<code>getState</code> 和 <code>replaceReducer</code> 方法。它是整个 Redux 应用程序的核心，用于管理状态的变化和订阅状态变化。</li>
</ol>
<p>​    7.<code>enhancer</code> (可选): 一个函数，用于增强 <code>store</code> 的功能，例如中间件等。</p>
</li>
<li><p><strong>内部变量</strong>：</p>
<ul>
<li><code>currentState</code>: 存储当前状态的变量。</li>
<li><code>currentListeners</code>: 一个数组，包含当前订阅状态变化的所有回调函数。</li>
</ul>
</li>
<li><p><strong>方法</strong>：</p>
<ul>
<li><code>getState()</code>: 返回当前存储的状态。</li>
<li><code>dispatch(action)</code>: 接收一个动作并触发状态变化。它通过调用 reducer 函数来计算新的状态，并通知所有的订阅者。</li>
<li><code>subscribe(listener)</code>: 接收一个回调函数作为参数，每当状态发生变化时就会调用该回调函数。</li>
<li><code>replaceReducer(nextReducer)</code>: 用于动态替换 reducer 函数。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>在初始化过程中，会调用 <code>dispatch(&#123; type: &#39;@@redux/INIT&#39; &#125;)</code> 来获取初始状态。</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>返回一个包含 <code>dispatch</code>、<code>subscribe</code>、<code>getState</code> 和 <code>replaceReducer</code> 方法的对象，也就是 Redux 的 <code>store</code>。</li>
</ul>
</li>
</ol>
<p>PS:<code>redux</code> 发布 <code>4.2.0</code> 版本，该版本将原始 <code>createStore API</code> 标记为 <code>@deprecated</code>(废弃)，并且添加了一个全新的 <code>legacy_createStore API</code>，但是并没有添加弃用警告。</p>
<h3 id="对-Redux-的理解，主要解决什么问题"><a href="#对-Redux-的理解，主要解决什么问题" class="headerlink" title="对 Redux 的理解，主要解决什么问题"></a>对 Redux 的理解，主要解决什么问题</h3><p>React是视图层框架。Redux是一个用来管理数据状态和UI状态的JavaScript应用工具。随着JavaScript单页应用（SPA）开发日趋复杂， JavaScript需要管理比任何时候都要多的state（状态）， Redux就是降低管理难度的。（Redux支持React、Angular、jQuery甚至纯JavaScript）。</p>
<p>在 React 中，UI 以组件的形式来搭建，组件之间可以嵌套组合。但 React 中组件间通信的数据流是单向的，顶层组件可以通过 props 属性向下层组件传递数据，而下层组件不能向上层组件传递数据，兄弟组件之间同样不能。这样简单的单向数据流支撑起了 React 中的数据可控性。</p>
<p>当项目越来越大的时候，管理数据的事件或回调函数将越来越多，也将越来越不好管理。管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个 model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等。state 的管理在大项目中相当复杂。</p>
<p>Redux 提供了一个叫 store 的统一仓储库，组件通过 dispatch 将 state 直接传入store，不用通过其他的组件。并且组件通过 subscribe 从 store获取到 state 的改变。使用了 Redux，所有的组件都可以从 store 中获取到所需的 state，他们也能从store 获取到 state 的改变。这比组件之间互相传递数据清晰明朗的多。</p>
<p><strong>主要解决的问题：</strong></p>
<p>单纯的Redux只是一个状态机，是没有UI呈现的，react- redux作用是将Redux的状态机和React的UI呈现绑定在一起，当你dispatch action改变state的时候，会自动更新页面。</p>
<h3 id="2-Redux-原理及工作流程"><a href="#2-Redux-原理及工作流程" class="headerlink" title="2. Redux 原理及工作流程"></a>2. Redux 原理及工作流程</h3><p><strong>（1）原理</strong></p>
<p>Redux源码主要分为以下几个模块文件</p>
<ul>
<li>compose.js 提供从右到左进行函数式编程</li>
<li>createStore.js 提供作为生成唯一store的函数</li>
<li>combineReducers.js 提供合并多个reducer的函数，保证store的唯一性</li>
<li>bindActionCreators.js 可以让开发者在不直接接触dispacth的前提下进行更改state的操作</li>
<li>applyMiddleware.js 这个方法通过中间件来增强dispatch的功能</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actionTypes = &#123;</span><br><span class="line">    <span class="attr">ADD</span>: <span class="string">&#x27;ADD&#x27;</span>,</span><br><span class="line">    <span class="attr">CHANGEINFO</span>: <span class="string">&#x27;CHANGEINFO&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initState = &#123;</span><br><span class="line">    <span class="attr">info</span>: <span class="string">&#x27;初始化&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">initReducer</span>(<span class="params">state=initState, action</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> actionTypes.<span class="property">CHANGEINFO</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">info</span>: action.<span class="property">preload</span>.<span class="property">info</span> || <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123; ...state &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">createStore</span>(<span class="params">reducer, initialState, middleFunc</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialState &amp;&amp; <span class="keyword">typeof</span> initialState === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        middleFunc = initialState;</span><br><span class="line">        initialState = <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentState = initialState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> listeners = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (middleFunc &amp;&amp; <span class="keyword">typeof</span> middleFunc === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 封装dispatch </span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">middleFunc</span>(createStore)(reducer, initialState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getState</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dispatch</span> = (<span class="params">action</span>) =&gt; &#123;</span><br><span class="line">        currentState = <span class="title function_">reducer</span>(currentState, action);</span><br><span class="line"></span><br><span class="line">        listeners.<span class="title function_">forEach</span>(<span class="function"><span class="params">listener</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">listener</span>();</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">subscribe</span> = (<span class="params">listener</span>) =&gt; &#123;</span><br><span class="line">        listeners.<span class="title function_">push</span>(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getState,</span><br><span class="line">        dispatch,</span><br><span class="line">        subscribe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）工作流程</strong></p>
<ul>
<li>const store&#x3D; createStore（fn）生成数据; </li>
<li>action: {type: Symble(‘action01), payload:’payload’ }定义行为; </li>
<li>dispatch发起action：store.dispatch(doSomething(‘action001’)); </li>
<li>reducer：处理action，返回新的state;</li>
</ul>
<p>通俗点解释：</p>
<ul>
<li>首先，用户（通过View）发出Action，发出方式就用到了dispatch方法</li>
<li>然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State</li>
<li>State—旦有变化，Store就会调用监听函数，来更新View</li>
</ul>
<p>以 store 为核心，可以把它看成数据存储中心，但是他要更改数据的时候不能直接修改，数据修改更新的角色由Reducers来担任，store只做存储，中间人，当Reducers的更新完成以后会通过store的订阅来通知react component，组件把新的状态重新获取渲染，组件中也能主动发送action，创建action后这个动作是不会执行的，所以要dispatch这个action，让store通过reducers去做更新React Component 就是react的每个组件。</p>
<h3 id="3-Redux-中异步的请求怎么处理"><a href="#3-Redux-中异步的请求怎么处理" class="headerlink" title="3. Redux 中异步的请求怎么处理"></a>3. Redux 中异步的请求怎么处理</h3><p>可以在 componentDidmount 中直接进⾏请求⽆须借助redux。但是在⼀定规模的项⽬中,上述⽅法很难进⾏异步流的管理,通常情况下我们会借助redux的异步中间件进⾏异步处理。redux异步流中间件其实有很多，当下主流的异步中间件有两种redux-thunk、redux-saga。</p>
<p><strong>（1）使用react-thunk中间件</strong></p>
<p><strong>redux-thunk</strong>优点**:** </p>
<ul>
<li>体积⼩: redux-thunk的实现⽅式很简单,只有不到20⾏代码 </li>
<li>使⽤简单: redux-thunk没有引⼊像redux-saga或者redux-observable额外的范式,上⼿简单</li>
</ul>
<p><strong>redux-thunk</strong>缺陷**:** </p>
<ul>
<li>样板代码过多: 与redux本身⼀样,通常⼀个请求需要⼤量的代码,⽽且很多都是重复性质的 </li>
<li>耦合严重: 异步操作与redux的action偶合在⼀起,不⽅便管理 </li>
<li>功能孱弱: 有⼀些实际开发中常⽤的功能需要⾃⼰进⾏封装</li>
</ul>
<p>使用步骤：</p>
<ul>
<li>配置中间件，在store的创建中配置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore, applyMiddleware, compose&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置调试工具</span></span><br><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="variable language_">window</span>.<span class="property">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span> ? <span class="variable language_">window</span>.<span class="title function_">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span>(&#123;&#125;) : compose;</span><br><span class="line"><span class="comment">// 设置中间件</span></span><br><span class="line"><span class="keyword">const</span> enhancer = <span class="title function_">composeEnhancers</span>(</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(thunk)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer, enhancer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<ul>
<li>添加一个返回函数的actionCreator，将异步请求逻辑放在里面</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  发送get请求，并生成相应action，更新store的函数</span></span><br><span class="line"><span class="comment">  <span class="doctag">@param</span> url &#123;string&#125; 请求地址</span></span><br><span class="line"><span class="comment">  <span class="doctag">@param</span> func &#123;function&#125; 真正需要生成的action对应的actionCreator</span></span><br><span class="line"><span class="comment">  <span class="doctag">@return</span> &#123;<span class="type">function</span>&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// dispatch为自动接收的store.dispatch函数 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getHttpAction</span> = (<span class="params">url, func</span>) =&gt; <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    axios.<span class="title function_">get</span>(url).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> action = <span class="title function_">func</span>(res.<span class="property">data</span>)</span><br><span class="line">        <span class="title function_">dispatch</span>(action)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成action，并发送action</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> action = <span class="title function_">getHttpAction</span>(<span class="string">&#x27;/getData&#x27;</span>, getInitTodoItemAction)</span><br><span class="line">    <span class="comment">// 发送函数类型的action时，该action的函数体会自动执行</span></span><br><span class="line">    store.<span class="title function_">dispatch</span>(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）使用redux-saga中间件</strong></p>
<p><strong>redux-saga</strong>优点**:** </p>
<ul>
<li>异步解耦: 异步操作被被转移到单独 saga.js 中，不再是掺杂在 action.js 或 component.js 中 </li>
<li>action摆脱thunk function: dispatch 的参数依然是⼀个纯粹的 action (FSA)，⽽不是充满 “⿊魔法” thunk function </li>
<li>异常处理: 受益于 generator function 的 saga 实现，代码异常&#x2F;请求失败 都可以直接通过 try&#x2F;catch 语法直接捕获处理</li>
<li>功能强⼤: redux-saga提供了⼤量的Saga 辅助函数和Effect 创建器供开发者使⽤,开发者⽆须封装或者简单封装即可使⽤ </li>
<li>灵活: redux-saga可以将多个Saga可以串⾏&#x2F;并⾏组合起来,形成⼀个⾮常实⽤的异步flow </li>
<li>易测试，提供了各种case的测试⽅案，包括mock task，分⽀覆盖等等</li>
</ul>
<p><strong>redux-saga</strong>缺陷**:** </p>
<ul>
<li>额外的学习成本: redux-saga不仅在使⽤难以理解的 generator function,⽽且有数⼗个API,学习成本远超redux-thunk,最重要的是你的额外学习成本是只服务于这个库的,与redux-observable不同,redux-observable虽然也有额外学习成本但是背后是rxjs和⼀整套思想 </li>
<li>体积庞⼤: 体积略⼤,代码近2000⾏，min版25KB左右 </li>
<li>功能过剩: 实际上并发控制等功能很难⽤到,但是我们依然需要引⼊这些代码 </li>
<li>ts⽀持不友好: yield⽆法返回TS类型</li>
</ul>
<p>redux-saga可以捕获action，然后执行一个函数，那么可以把异步代码放在这个函数中，使用步骤如下：</p>
<ul>
<li>配置中间件</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore, applyMiddleware, compose&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-saga&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TodoListSaga</span> <span class="keyword">from</span> <span class="string">&#x27;./sagas&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="variable language_">window</span>.<span class="property">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span> ? <span class="variable language_">window</span>.<span class="title function_">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span>(&#123;&#125;) : compose;</span><br><span class="line"><span class="keyword">const</span> sagaMiddleware = <span class="title function_">createSagaMiddleware</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enhancer = <span class="title function_">composeEnhancers</span>(</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(sagaMiddleware)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer, enhancer);</span><br><span class="line">sagaMiddleware.<span class="title function_">run</span>(<span class="title class_">TodoListSaga</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>

<ul>
<li>将异步请求放在sagas.js中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;takeEvery, put&#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;initTodoList&#125; <span class="keyword">from</span> <span class="string">&#x27;./actionCreator&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="variable constant_">GET_INIT_ITEM</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;./actionTypes&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">func</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 可以获取异步返回数据</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">yield</span> axios.<span class="title function_">get</span>(<span class="string">&#x27;/getData&#x27;</span>)</span><br><span class="line">        <span class="keyword">const</span> action = <span class="title function_">initTodoList</span>(res.<span class="property">data</span>)</span><br><span class="line">        <span class="comment">// 将action发送到reducer</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="title function_">put</span>(action)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;网络请求失败&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">mySaga</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">// 自动捕获GET_INIT_ITEM类型的action，并执行func</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="title function_">takeEvery</span>(<span class="variable constant_">GET_INIT_ITEM</span>, func)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> mySaga</span><br></pre></td></tr></table></figure>

<ul>
<li>发送action</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> action = <span class="title function_">getInitTodoItemAction</span>()</span><br><span class="line">  store.<span class="title function_">dispatch</span>(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Redux-怎么实现属性传递，介绍下原理"><a href="#4-Redux-怎么实现属性传递，介绍下原理" class="headerlink" title="4. Redux 怎么实现属性传递，介绍下原理"></a>4. Redux 怎么实现属性传递，介绍下原理</h3><p>react-redux 数据传输∶ view–&gt;action–&gt;reducer–&gt;store–&gt;view。看下点击事件的数据是如何通过redux传到view上：</p>
<ul>
<li>view 上的AddClick 事件通过mapDispatchToProps 把数据传到action —&gt; click:()&#x3D;&gt;dispatch(ADD)</li>
<li>action 的ADD 传到reducer上</li>
<li>reducer传到store上 const store &#x3D; createStore(reducer);</li>
<li>store再通过 mapStateToProps 映射穿到view上text:State.text</li>
</ul>
<p>代码示例∶</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span>, connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; text, click, clickR &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span>&gt;</span>数据:已有人&#123;text&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;click&#125;</span>&gt;</span>加人<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;clickR&#125;</span>&gt;</span>减人<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">    <span class="attr">text</span>:<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="keyword">function</span>(<span class="params">state,action</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.<span class="property">type</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;ADD&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">text</span>:state.<span class="property">text</span>+<span class="number">1</span>&#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;REMOVE&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">text</span>:state.<span class="property">text</span>-<span class="number">1</span>&#125;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> initialState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable constant_">ADD</span> = &#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&#x27;ADD&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title class_">Remove</span> = &#123;</span><br><span class="line">    <span class="attr">type</span>:<span class="string">&#x27;REMOVE&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapStateToProps = <span class="keyword">function</span> (<span class="params">state</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">text</span>:state.<span class="property">text</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapDispatchToProps = <span class="keyword">function</span>(<span class="params">dispatch</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        <span class="attr">click</span>:<span class="function">()=&gt;</span><span class="title function_">dispatch</span>(<span class="variable constant_">ADD</span>),</span><br><span class="line">        <span class="attr">clickR</span>:<span class="function">()=&gt;</span><span class="title function_">dispatch</span>(<span class="title class_">Remove</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">App1</span> = <span class="title function_">connect</span>(mapStateToProps,mapDispatchToProps)(<span class="title class_">App</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span> = <span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">App1</span>&gt;</span><span class="tag">&lt;/<span class="name">App1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="5-Redux-中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？"><a href="#5-Redux-中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？" class="headerlink" title="5. Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？"></a>5. Redux 中间件是什么？接受几个参数？柯里化函数两端的参数具体是什么？</h3><p>Redux 的中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点，换而言之，原本 view -→&gt; action -&gt; reducer -&gt; store 的数据流加上中间件后变成了 view -&gt; action -&gt; middleware -&gt; reducer -&gt; store ，在这一环节可以做一些”副作用”的操作，如异步请求、打印日志等。</p>
<p>applyMiddleware源码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">applyMiddleware</span>(<span class="params">...middlewares</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 利用传入的createStore和reducer和创建一个store</span></span><br><span class="line">        <span class="keyword">const</span> store = <span class="title function_">createStore</span>(...args)</span><br><span class="line">        <span class="keyword">let</span> <span class="title function_">dispatch</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">            <span class="attr">getState</span>: store.<span class="property">getState</span>,</span><br><span class="line">            <span class="attr">dispatch</span>: <span class="function">(<span class="params">...args</span>) =&gt;</span> <span class="title function_">dispatch</span>(...args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 让每个 middleware 带着 middlewareAPI 这个参数分别执行一遍</span></span><br><span class="line">        <span class="keyword">const</span> chain = middlewares.<span class="title function_">map</span>(<span class="function"><span class="params">middleware</span> =&gt;</span> <span class="title function_">middleware</span>(middlewareAPI))</span><br><span class="line">        <span class="comment">// 接着 compose 将 chain 中的所有匿名函数，组装成一个新的函数，即新的 dispatch</span></span><br><span class="line">        dispatch = <span class="title function_">compose</span>(...chain)(store.<span class="property">dispatch</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...store,</span><br><span class="line">            dispatch</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从applyMiddleware中可以看出∶</p>
<ul>
<li>redux中间件接受一个对象作为参数，对象的参数上有两个字段 dispatch 和 getState，分别代表着 Redux Store 上的两个同名函数。</li>
<li>柯里化函数两端一个是 middewares，一个是store.dispatch</li>
</ul>
<h3 id="6-Redux-请求中间件如何处理并发"><a href="#6-Redux-请求中间件如何处理并发" class="headerlink" title="6. Redux 请求中间件如何处理并发"></a>6. Redux 请求中间件如何处理并发</h3><p><strong>使用redux-Saga</strong></p>
<p>redux-saga是一个管理redux应用异步操作的中间件，用于代替 redux-thunk 的。它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。 redux-saga如何处理并发：</p>
<ul>
<li><strong>takeEvery</strong></li>
</ul>
<p>可以让多个 saga 任务并行被 fork 执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    fork,</span><br><span class="line">    take</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;redux-saga/effects&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">takeEvery</span> = (<span class="params">pattern, saga, ...args</span>) =&gt; <span class="title function_">fork</span>(<span class="keyword">function</span>*() &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> action = <span class="keyword">yield</span> <span class="title function_">take</span>(pattern)</span><br><span class="line">        <span class="keyword">yield</span> <span class="title function_">fork</span>(saga, ...args.<span class="title function_">concat</span>(action))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>takeLatest</strong></li>
</ul>
<p>takeLatest 不允许多个 saga 任务并行地执行。一旦接收到新的发起的 action，它就会取消前面所有 fork 过的任务（如果这些任务还在执行的话）。</p>
<p>在处理 AJAX 请求的时候，如果只希望获取最后那个请求的响应， takeLatest 就会非常有用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    cancel,</span><br><span class="line">    fork,</span><br><span class="line">    take</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;redux-saga/effects&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">takeLatest</span> = (<span class="params">pattern, saga, ...args</span>) =&gt; <span class="title function_">fork</span>(<span class="keyword">function</span>*() &#123;</span><br><span class="line">    <span class="keyword">let</span> lastTask</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> action = <span class="keyword">yield</span> <span class="title function_">take</span>(pattern)</span><br><span class="line">        <span class="keyword">if</span> (lastTask) &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="title function_">cancel</span>(lastTask) <span class="comment">// 如果任务已经结束，则 cancel 为空操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        lastTask = <span class="keyword">yield</span> <span class="title function_">fork</span>(saga, ...args.<span class="title function_">concat</span>(action))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="7-Redux-状态管理器和变量挂载到-window-中有什么区别"><a href="#7-Redux-状态管理器和变量挂载到-window-中有什么区别" class="headerlink" title="7. Redux 状态管理器和变量挂载到 window 中有什么区别"></a>7. Redux 状态管理器和变量挂载到 window 中有什么区别</h3><p>两者都是存储数据以供后期使用。但是Redux状态更改可回溯——Time travel，数据多了的时候可以很清晰的知道改动在哪里发生，完整的提供了一套状态管理模式。</p>
<p>随着 JavaScript 单页应用开发日趋复杂，JavaScript 需要管理比任何时候都要多的 state （状态）。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。</p>
<p>管理不断变化的 state 非常困难。如果一个 model 的变化会引起另一个 model 变化，那么当 view 变化时，就可能引起对应 model 以及另一个model 的变化，依次地，可能会引起另一个 view 的变化。直至你搞不清楚到底发生了什么。state 在什么时候，由于什么原因，如何变化已然不受控制。 当系统变得错综复杂的时候，想重现问题或者添加新功能就会变得举步维艰。</p>
<p>如果这还不够糟糕，考虑一些来自前端开发领域的新需求，如更新调优、服务端渲染、路由跳转前请求数据等等。前端开发者正在经受前所未有的复杂性，难道就这么放弃了吗?当然不是。</p>
<p>这里的复杂性很大程度上来自于：我们总是将两个难以理清的概念混淆在一起：变化和异步。 可以称它们为曼妥思和可乐。如果把二者分开，能做的很好，但混到一起，就变得一团糟。一些库如 React 视图在视图层禁止异步和直接操作 DOM来解决这个问题。美中不足的是，React 依旧把处理 state 中数据的问题留给了你。Redux就是为了帮你解决这个问题。</p>
<h3 id="8-mobox-和-redux-有什么区别？"><a href="#8-mobox-和-redux-有什么区别？" class="headerlink" title="8. mobox 和 redux 有什么区别？"></a>8. mobox 和 redux 有什么区别？</h3><p><strong>（1）共同点</strong></p>
<ul>
<li>为了解决状态管理混乱，无法有效同步的问题统一维护管理应用状态;</li>
<li>某一状态只有一个可信数据来源（通常命名为store，指状态容器）;</li>
<li>操作更新状态方式统一，并且可控（通常以action方式提供更新状态的途径）;</li>
<li>支持将store与React组件连接，如react-redux，mobx- react;</li>
</ul>
<p><strong>（2）区别</strong></p>
<p>Redux更多的是遵循Flux模式的一种实现，是一个 JavaScript库，它关注点主要是以下几方面∶ </p>
<ul>
<li>Action∶ 一个JavaScript对象，描述动作相关信息，主要包含type属性和payload属性∶</li>
</ul>
<p>​         o type∶ action 类型; </p>
<p>​         o payload∶ 负载数据;</p>
<ul>
<li>Reducer∶ 定义应用状态如何响应不同动作（action），如何更新状态;</li>
<li>Store∶ 管理action和reducer及其关系的对象，主要提供以下功能∶</li>
</ul>
<p>​         o 维护应用状态并支持访问状态(getState());</p>
<p>​         o 支持监听action的分发，更新状态(dispatch(action)); </p>
<p>​         o 支持订阅store的变更(subscribe(listener));</p>
<ul>
<li>异步流∶ 由于Redux所有对store状态的变更，都应该通过action触发，异步任务（通常都是业务或获取数据任务）也不例外，而为了不将业务或数据相关的任务混入React组件中，就需要使用其他框架配合管理异步任务流程，如redux-thunk，redux-saga等;</li>
</ul>
<p>Mobx是一个透明函数响应式编程的状态管理库，它使得状态管理简单可伸缩∶</p>
<ul>
<li>Action∶定义改变状态的动作函数，包括如何变更状态;</li>
<li>Store∶ 集中管理模块状态（State）和动作(action)</li>
<li>Derivation（衍生）∶ 从应用状态中派生而出，且没有任何其他影响的数据</li>
</ul>
<p><strong>对比总结：</strong></p>
<ul>
<li>redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中</li>
<li>redux使用plain object保存数据，需要手动处理变化后的操作;mobx适用observable保存数据，数据变化后自动处理响应的操作</li>
<li>redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数;mobx中的状态是可变的，可以直接对其进行修改</li>
<li>mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维;redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用</li>
<li>mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测;而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易</li>
</ul>
<h3 id="9-Redux-和-Vuex-有什么区别，它们的共同思想"><a href="#9-Redux-和-Vuex-有什么区别，它们的共同思想" class="headerlink" title="9. Redux 和 Vuex 有什么区别，它们的共同思想"></a>9. Redux 和 Vuex 有什么区别，它们的共同思想</h3><p><strong>（1）Redux 和 Vuex区别</strong></p>
<ul>
<li>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可</li>
<li>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</li>
<li>Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）</li>
</ul>
<p>通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变；取消了action概念，不必传入特定的 action形式进行指定变更；弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易; </p>
<p><strong>（2）共同思想</strong></p>
<ul>
<li>单—的数据源 </li>
<li>变化可以预测</li>
</ul>
<p>本质上∶ redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案。</p>
<h3 id="10-Redux-中间件是怎么拿到store-和-action-然后怎么处理"><a href="#10-Redux-中间件是怎么拿到store-和-action-然后怎么处理" class="headerlink" title="10. Redux 中间件是怎么拿到store 和 action? 然后怎么处理?"></a>10. Redux 中间件是怎么拿到store 和 action? 然后怎么处理?</h3><p>redux中间件本质就是一个函数柯里化。redux applyMiddleware Api 源码中每个middleware 接受2个参数， Store 的getState 函数和dispatch 函数，分别获得store和action，最终返回一个函数。该函数会被传入 next 的下一个 middleware 的 dispatch 方法，并返回一个接收 action 的新函数，这个函数可以直接调用 next（action），或者在其他需要的时刻调用，甚至根本不去调用它。调用链中最后一个 middleware 会接受真实的 store的 dispatch 方法作为 next 参数，并借此结束调用链。所以，middleware 的函数签名是（{ getState，dispatch })&#x3D;&gt; next &#x3D;&gt; action。</p>
<h3 id="11-Redux中的connect有什么作用"><a href="#11-Redux中的connect有什么作用" class="headerlink" title="11. Redux中的connect有什么作用"></a>11. Redux中的connect有什么作用</h3><p>connect负责连接React和Redux</p>
<p><strong>（1）获取state</strong></p>
<p>connect 通过 context获取 Provider 中的 store，通过<code> store.getState()</code> 获取整个store tree 上所有state </p>
<p><strong>（2）包装原组件</strong></p>
<p>将state和action通过props的方式传入到原组件内部 wrapWithConnect 返回—个 ReactComponent 对 象 Connect，Connect 重 新 render 外部传入的原组件 WrappedComponent ，并把 connect 中传入的 mapStateToProps，mapDispatchToProps与组件上原有的 props合并后，通过属性的方式传给WrappedComponent </p>
<p><strong>（3）监听store tree变化</strong></p>
<p>connect缓存了store tree中state的状态，通过当前state状态 和变更前 state 状态进行比较，从而确定是否调用 <code>this.setState()</code>方法触发Connect及其子组件的重新渲染</p>
<h1 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h1><p>React Hooks 主要解决了以下问题：</p>
<p><strong>（1）在组件之间复用状态逻辑很难</strong></p>
<p>React 没有提供将可复用性行为“附加”到组件的途径（例如，把组件连接到 store）解决此类问题可以使用 render props 和 高阶组件。但是这类方案需要重新组织组件结构，这可能会很麻烦，并且会使代码难以理解。由 providers，consumers，高阶组件，render props 等其他抽象层组成的组件会形成“嵌套地狱”。尽管可以在 DevTools 过滤掉它们，但这说明了一个更深层次的问题：React 需要为共享状态逻辑提供更好的原生途径。</p>
<p>可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使我们在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。</p>
<p><strong>（2）复杂组件变得难以理解</strong></p>
<p>在组件中，每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。</p>
<p>在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。</p>
<p>为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。</p>
<p><strong>（3）难以理解的 class</strong></p>
<p>除了代码复用和代码管理会遇到困难外，class 是学习 React 的一大屏障。我们必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。没有稳定的语法提案，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 React 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。</p>
<p>为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术</p>
<h2 id="React-Hook-的使用限制"><a href="#React-Hook-的使用限制" class="headerlink" title="React Hook 的使用限制"></a>React Hook 的使用限制</h2><p>React Hooks 的限制主要有两条：</p>
<ul>
<li>不要在循环、条件或嵌套函数中调用 Hook；</li>
<li>在 React 的函数组件中调用 Hook。</li>
</ul>
<p>那为什么会有这样的限制呢？Hooks 的设计初衷是为了改进 React 组件的开发模式。在旧有的开发模式下遇到了三个问题。</p>
<ul>
<li>组件之间难以复用状态逻辑。过去常见的解决方案是高阶组件、render props 及状态管理框架。</li>
<li>复杂的组件变得难以理解。生命周期函数与业务逻辑耦合太深，导致关联部分难以拆分。</li>
<li>人和机器都很容易混淆类。常见的有 this 的问题，但在 React 团队中还有类难以优化的问题，希望在编译优化层面做出一些改进。</li>
</ul>
<p>这三个问题在一定程度上阻碍了 React 的后续发展，所以为了解决这三个问题，Hooks <strong>基于函数组件</strong>开始设计。然而第三个问题决定了 Hooks 只支持函数组件。</p>
<p>那为什么不要在循环、条件或嵌套函数中调用 Hook 呢？因为 Hooks 的设计是基于数组实现。在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致数组取值错位，执行错误的 Hook。当然，实质上 React 的源码里不是数组，是链表。</p>
<p>这些限制会在编码上造成一定程度的心智负担，新手可能会写错，为了避免这样的情况，可以引入 ESLint 的 Hooks 检查插件进行预防。</p>
<h2 id="useEffect-与-useLayoutEffect-的区别"><a href="#useEffect-与-useLayoutEffect-的区别" class="headerlink" title="useEffect 与 useLayoutEffect 的区别"></a>useEffect 与 useLayoutEffect 的区别</h2><p><strong>（1）共同点</strong></p>
<ul>
<li>**运用效果：**useEffect 与 useLayoutEffect 两者都是用于处理副作用，这些副作用包括改变 DOM、设置订阅、操作定时器等。在函数组件内部操作副作用是不被允许的，所以需要使用这两个函数去处理。</li>
<li>**使用方式：**useEffect 与 useLayoutEffect 两者底层的函数签名是完全一致的，都是调用的 mountEffectImpl方法，在使用上也没什么差异，基本可以直接替换。</li>
</ul>
<p><strong>（2）不同点</strong></p>
<ul>
<li><strong>使用场景</strong>**：**useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景；而 useLayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 useLayoutEffect 做计算量较大的耗时任务从而造成阻塞。</li>
<li>**使用效果：**useEffect是按照顺序执行代码的，改变屏幕像素之后执行（先渲染，后改变DOM），当改变屏幕内容时可能会产生闪烁；useLayoutEffect是改变屏幕像素之前就执行了（会推迟页面显示的事件，先改变DOM后渲染），不会产生闪烁。<strong>useLayoutEffect总是比useEffect先执行。</strong></li>
</ul>
<p>在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可。</p>
<h2 id="React-Hooks在平时开发中需要注意的问题和原因"><a href="#React-Hooks在平时开发中需要注意的问题和原因" class="headerlink" title="React Hooks在平时开发中需要注意的问题和原因"></a>React Hooks在平时开发中需要注意的问题和原因</h2><p>（1）<strong>不要在循环，条件或嵌套函数中调用Hook，必须始终在 React函数的顶层使用Hook</strong></p>
<p>这是因为React需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。</p>
<p>**（2）<strong><strong>使用useState时候，使用push，pop，splice等直接更改数组</strong></strong>对象的坑**</p>
<p>使用push直接更改数组无法获取到新值，应该采用析构方式，但是在class里面不会有这个问题。代码示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Indicatorfilter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> [num,setNums] = <span class="title function_">useState</span>([<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">test</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里坑是直接采用push去更新num</span></span><br><span class="line">    <span class="comment">// setNums(num)是无法更新num的</span></span><br><span class="line">    <span class="comment">// 必须使用num = [...num ,1]</span></span><br><span class="line">    num.<span class="title function_">push</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// num = [...num ,1]</span></span><br><span class="line">    <span class="title function_">setNums</span>(num)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#x27;filter&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;test&#125;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;num.map((item,index) =&gt; (</span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Indicatorfilter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;any,any&gt;&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props:any</span>)&#123;</span><br><span class="line">      <span class="variable language_">super</span>(props)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">          <span class="attr">nums</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">test</span> = <span class="variable language_">this</span>.<span class="property">test</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="comment">// class采用同样的方式是没有问题的</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">nums</span>.<span class="title function_">push</span>(<span class="number">1</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">          <span class="attr">nums</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">nums</span></span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">let</span> &#123;nums&#125; = <span class="variable language_">this</span>.<span class="property">state</span></span><br><span class="line">      <span class="keyword">return</span>(</span><br><span class="line">          <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.test&#125;</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                      &#123;nums.map((item:any,index:number) =&gt; (</span></span><br><span class="line"><span class="language-xml">                          <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                      ))&#125;</span></span><br><span class="line"><span class="language-xml">                  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">      )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）<strong>useState设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useEffect</strong></p>
<p>TableDeail是一个公共组件，在调用它的父组件里面，我们通过set改变columns的值，以为传递给TableDeail 的 columns是最新的值，所以tabColumn每次也是最新的值，但是实际tabColumn是最开始的值，不会随着columns的更新而更新：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">TableDeail</span> = (<span class="params">&#123;</span></span><br><span class="line"><span class="params">    columns,</span></span><br><span class="line"><span class="params">&#125;:TableData</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [tabColumn, setTabColumn] = <span class="title function_">useState</span>(columns) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的做法是通过useEffect改变这个值</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TableDeail</span> = (<span class="params">&#123;</span></span><br><span class="line"><span class="params">    columns,</span></span><br><span class="line"><span class="params">&#125;:TableData</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [tabColumn, setTabColumn] = <span class="title function_">useState</span>(columns) </span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span>&#123;<span class="title function_">setTabColumn</span>(columns)&#125;,[columns])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）善用useCallback</strong></p>
<p>父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用useMemo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。 </p>
<p><strong>（5）不要滥用useContext</strong></p>
<p>可以使用基于 useContext 封装的状态管理工具。</p>
<h1 id="React-Router"><a href="#React-Router" class="headerlink" title="React-Router"></a>React-Router</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>客户端路由实现的思想：</p>
<ul>
<li><p>基于 hash 的路由：通过监听<code>hashchange</code>事件，感知 hash 的变化</p>
</li>
<li><ul>
<li>改变 hash 可以直接通过 location.hash&#x3D;xxx</li>
</ul>
</li>
<li><p>基于 H5 history 路由：</p>
</li>
<li><ul>
<li>改变 url 可以通过 history.pushState 和 resplaceState 等，会将URL压入堆栈，同时能够应用 <code>history.go()</code> 等 API</li>
<li>监听 url 的变化可以通过自定义事件触发实现</li>
</ul>
</li>
</ul>
<p><strong>react-router 实现的思想：</strong></p>
<ul>
<li>基于 <code>history</code> 库来实现上述不同的客户端路由实现思想，并且能够保存历史记录等，磨平浏览器差异，上层无感知</li>
<li>通过维护的列表，在每次 URL 发生变化的回收，通过配置的 路由路径，匹配到对应的 Component，并且 render</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/29/React/" data-id="cmchpakn00000rsur6ygt46ds" data-title="React" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React/" rel="tag">React</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-TS" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/29/TS/" class="article-date">
  <time class="dt-published" datetime="2025-06-29T10:37:18.000Z" itemprop="datePublished">2025-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/29/TS/">TS</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><p>一、核心区别对比</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JavaScript (JS)</th>
<th align="left">TypeScript (TS)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型系统</strong></td>
<td align="left">动态类型，运行时类型检查</td>
<td align="left">静态类型，编译时类型检查</td>
</tr>
<tr>
<td align="left"><strong>编译过程</strong></td>
<td align="left">直接由浏览器&#x2F;Node.js 执行</td>
<td align="left">需要编译为 JS 才能执行</td>
</tr>
<tr>
<td align="left"><strong>语法扩展</strong></td>
<td align="left">标准 ECMAScript 语法</td>
<td align="left">ES6+ 超集，添加类型注解和接口等</td>
</tr>
<tr>
<td align="left"><strong>错误发现</strong></td>
<td align="left">运行时才能发现错误</td>
<td align="left">编码和编译阶段即可发现大多数错误</td>
</tr>
<tr>
<td align="left"><strong>工具支持</strong></td>
<td align="left">基础代码补全</td>
<td align="left">强大的智能提示、重构和导航功能</td>
</tr>
<tr>
<td align="left"><strong>项目规模适应性</strong></td>
<td align="left">更适合小型项目</td>
<td align="left">更适合中大型复杂项目</td>
</tr>
<tr>
<td align="left"><strong>学习曲线</strong></td>
<td align="left">相对简单</td>
<td align="left">需要学习类型系统和额外语法</td>
</tr>
<tr>
<td align="left"><strong>执行环境</strong></td>
<td align="left">所有浏览器和 Node.js 原生支持</td>
<td align="left">需要编译为 JS 后运行</td>
</tr>
</tbody></table>
<p>二、TypeScript 编译原理</p>
<p>TypeScript 编译器 (tsc) 的工作流程：</p>
<ol>
<li>源代码解析阶段</li>
</ol>
<ul>
<li><strong>词法分析</strong>：将源代码分解为 token 流</li>
<li><strong>语法分析</strong>：根据 token 生成抽象语法树 (AST)</li>
<li><strong>生成符号表</strong>：记录所有变量、函数等的类型信息</li>
</ul>
<ol start="2">
<li>类型检查阶段</li>
</ol>
<ul>
<li><strong>类型解析</strong>：解析类型注解和推断隐式类型</li>
<li><strong>类型检查</strong>：验证类型兼容性，发现类型错误</li>
<li><strong>类型擦除</strong>：准备移除类型信息（最终JS不需要类型）</li>
</ul>
<ol start="3">
<li>代码转换阶段</li>
</ol>
<ul>
<li><strong>降级编译</strong>：将新语法转换为目标ES版本的等效代码</li>
<li><strong>接口擦除</strong>：移除纯类型声明的接口和类型别名</li>
<li><strong>装饰器转换</strong>：处理装饰器语法（如果启用）</li>
</ul>
<ol start="4">
<li>代码生成阶段</li>
</ol>
<ul>
<li><strong>生成目标代码</strong>：输出纯 JavaScript 代码</li>
<li><strong>SourceMap 生成</strong>：创建调试映射文件</li>
<li><strong>声明文件生成</strong>：生成 .d.ts 类型声明文件（如果配置）</li>
</ul>
<h2 id="TypeScript基本类型："><a href="#TypeScript基本类型：" class="headerlink" title="TypeScript基本类型："></a>TypeScript基本类型：</h2><ol>
<li><strong>基础类型</strong>：<ul>
<li><code>number</code>：数字</li>
<li><code>string</code>：字符串</li>
<li><code>boolean</code>：布尔值</li>
<li><code>null</code>和<code>undefined</code></li>
<li><code>void</code>：通常用于函数返回值</li>
<li><code>any</code>：任意类型</li>
<li><code>never</code>：永不存在的值的类型</li>
</ul>
</li>
<li><strong>对象类型</strong>：<ul>
<li><code>object</code>：对象类型</li>
<li><code>array</code>：数组类型</li>
<li><code>tuple</code>：元组类型</li>
</ul>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">typescript 体验<span class="variable constant_">AI</span>代码助手 代码解读复制代码<span class="comment">// 基础类型示例</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">isDone</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">decimal</span>: <span class="built_in">number</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">color</span>: <span class="built_in">string</span> = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">list</span>: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="attr">tuple</span>: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">&quot;hello&quot;</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span> &#123;<span class="title class_">Red</span>, <span class="title class_">Green</span>, <span class="title class_">Blue</span>&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: <span class="title class_">Color</span> = <span class="title class_">Color</span>.<span class="property">Green</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">warnUser</span>(<span class="params"></span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is a warning message&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// any类型</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">notSure</span>: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&quot;maybe a string&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="什么是类型断言？如何使用？"><a href="#什么是类型断言？如何使用？" class="headerlink" title="什么是类型断言？如何使用？"></a>什么是类型断言？如何使用？</h2><p>类型断言用于告诉编译器”相信我，我知道自己在做什么”。它有两种形式：</p>
<ol>
<li>尖括号语法</li>
<li>as语法（推荐，特别是在JSX中）</li>
</ol>
<p>示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typescript 体验<span class="variable constant_">AI</span>代码助手 代码解读复制代码<span class="comment">// 尖括号语法</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">someValue</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength</span>: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// as语法</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">someValue2</span>: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">strLength2</span>: <span class="built_in">number</span> = (someValue2 <span class="keyword">as</span> <span class="built_in">string</span>).<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际应用场景</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">data</span>: <span class="built_in">any</span> = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> person = data <span class="keyword">as</span> <span class="title class_">Person</span>;</span><br></pre></td></tr></table></figure>

<h2 id="进阶特性篇"><a href="#进阶特性篇" class="headerlink" title="进阶特性篇"></a>进阶特性篇</h2><h3 id="什么是泛型？为什么要使用泛型？"><a href="#什么是泛型？为什么要使用泛型？" class="headerlink" title="什么是泛型？为什么要使用泛型？"></a>什么是泛型？为什么要使用泛型？</h3><p>泛型是一种在定义函数、接口或类时不预先指定具体类型，而在使用时再指定类型的特性。</p>
<p>优点：</p>
<ul>
<li>代码复用</li>
<li>类型安全</li>
<li>减少冗余代码</li>
</ul>
<p>示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型函数</span></span><br><span class="line"><span class="keyword">function</span> identity&lt;T&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型函数</span></span><br><span class="line"><span class="keyword">let</span> output1 = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;myString&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> output2 = <span class="title function_">identity</span>(<span class="number">42</span>); <span class="comment">// 类型推断为number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericIdentityFn</span>&lt;T&gt; &#123;</span><br><span class="line">    (<span class="attr">arg</span>: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericNumber</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">zeroValue</span>: T;</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params"><span class="attr">x</span>: T, <span class="attr">y</span>: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型约束</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Lengthwise</span> &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> loggingIdentity&lt;T <span class="keyword">extends</span> <span class="title class_">Lengthwise</span>&gt;(<span class="attr">arg</span>: T): T &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arg.<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="装饰器是什么？如何使用？"><a href="#装饰器是什么？如何使用？" class="headerlink" title="装饰器是什么？如何使用？"></a>装饰器是什么？如何使用？</h3><p>装饰器是一种特殊类型的声明，可以附加到类、方法、访问符、属性或参数上。</p>
<p>示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类装饰器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sealed</span>(<span class="params"><span class="attr">constructor</span>: <span class="title class_">Function</span></span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">seal</span>(constructor);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">seal</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@sealed</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greeter</span> &#123;</span><br><span class="line">    <span class="attr">greeting</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="attr">message</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">greeting</span> = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + <span class="variable language_">this</span>.<span class="property">greeting</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法装饰器</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log</span>(<span class="params"><span class="attr">target</span>: <span class="built_in">any</span>, <span class="attr">propertyKey</span>: <span class="built_in">string</span>, <span class="attr">descriptor</span>: <span class="title class_">PropertyDescriptor</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> originalMethod = descriptor.<span class="property">value</span>;</span><br><span class="line">    descriptor.<span class="property">value</span> = <span class="keyword">function</span>(<span class="params">...<span class="attr">args</span>: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Calling <span class="subst">$&#123;propertyKey&#125;</span> with`</span>, args);</span><br><span class="line">        <span class="keyword">return</span> originalMethod.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="meta">@log</span></span><br><span class="line">    <span class="title function_">add</span>(<span class="params"><span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实战应用篇"><a href="#实战应用篇" class="headerlink" title="实战应用篇"></a>实战应用篇</h2><h3 id="TypeScript中如何实现接口继承？"><a href="#TypeScript中如何实现接口继承？" class="headerlink" title="TypeScript中如何实现接口继承？"></a>TypeScript中如何实现接口继承？</h3><p>接口继承允许我们从一个接口复制成员到另一个接口，实现代码重用。</p>
<p>示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Pet</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="attr">breed</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Pet</span> &#123;</span><br><span class="line">    <span class="title function_">bark</span>(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">dog</span>: <span class="title class_">Dog</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;Max&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">breed</span>: <span class="string">&quot;Labrador&quot;</span>,</span><br><span class="line">    <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GoldenRetriever</span> <span class="keyword">implements</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">breed</span>: <span class="built_in">string</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"><span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">breed</span> = <span class="string">&quot;Golden Retriever&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-如何在TypeScript中处理异步操作？"><a href="#7-如何在TypeScript中处理异步操作？" class="headerlink" title="7. 如何在TypeScript中处理异步操作？"></a>7. 如何在TypeScript中处理异步操作？</h3><p>TypeScript完全支持现代JavaScript的异步特性，包括Promise、async&#x2F;await等。</p>
<p>示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise示例</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fetchUser</span>(<span class="params"><span class="attr">id</span>: <span class="built_in">number</span></span>): <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(&#123;</span><br><span class="line">                <span class="attr">id</span>: id,</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&quot;John Doe&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async/await示例</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUser</span>(<span class="params"><span class="attr">id</span>: <span class="built_in">number</span></span>): <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="title function_">fetchUser</span>(id);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;Error fetching user:&quot;</span>, error);</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际应用</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">processUser</span>(<span class="params"><span class="attr">id</span>: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="title function_">getUser</span>(id);</span><br><span class="line">    <span class="comment">// 处理用户数据</span></span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高级特性篇"><a href="#高级特性篇" class="headerlink" title="高级特性篇"></a>高级特性篇</h2><h3 id="什么是条件类型？如何使用？"><a href="#什么是条件类型？如何使用？" class="headerlink" title="什么是条件类型？如何使用？"></a>什么是条件类型？如何使用？</h3><p>条件类型是TypeScript中的高级类型特性，允许我们基于类型关系进行类型选择。</p>
<p>示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">TypeName</span>&lt;T&gt; = </span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="string">&quot;string&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="string">&quot;number&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="built_in">boolean</span> ? <span class="string">&quot;boolean&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="literal">undefined</span> ? <span class="string">&quot;undefined&quot;</span> :</span><br><span class="line">    T <span class="keyword">extends</span> <span class="title class_">Function</span> ? <span class="string">&quot;function&quot;</span> :</span><br><span class="line">    <span class="string">&quot;object&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T0</span> = <span class="title class_">TypeName</span>&lt;<span class="built_in">string</span>&gt;;  <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T1</span> = <span class="title class_">TypeName</span>&lt;<span class="string">&quot;hello&quot;</span>&gt;; <span class="comment">// &quot;string&quot;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">T2</span> = <span class="title class_">TypeName</span>&lt;<span class="function">() =&gt;</span> <span class="built_in">void</span>&gt;; <span class="comment">// &quot;function&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际应用</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">NonNullable</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="literal">null</span> | <span class="literal">undefined</span> ? <span class="built_in">never</span> : T;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Flatten</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;infer U&gt; ? U : T;</span><br></pre></td></tr></table></figure>

<h3 id="如何使用映射类型？"><a href="#如何使用映射类型？" class="headerlink" title="如何使用映射类型？"></a>如何使用映射类型？</h3><p>映射类型允许我们从现有类型创建新类型，通过映射现有类型的每个属性。</p>
<p>示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有属性变为可选</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Partial</span>&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有属性变为只读</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Readonly</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际应用</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialPerson</span> = <span class="title class_">Partial</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     name?: string;</span></span><br><span class="line"><span class="comment">//     age?: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyPerson</span> = <span class="title class_">Readonly</span>&lt;<span class="title class_">Person</span>&gt;;</span><br><span class="line"><span class="comment">// 等价于：</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     readonly name: string;</span></span><br><span class="line"><span class="comment">//     readonly age: number;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="工程实践篇"><a href="#工程实践篇" class="headerlink" title="工程实践篇"></a>工程实践篇</h2><h3 id="TypeScript项目中如何处理模块化？"><a href="#TypeScript项目中如何处理模块化？" class="headerlink" title="TypeScript项目中如何处理模块化？"></a>TypeScript项目中如何处理模块化？</h3><p>TypeScript支持现代JavaScript的模块化语法，同时提供了额外的类型系统支持。</p>
<p>示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">MathOperations</span> &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">    <span class="title function_">subtract</span>(<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> <span class="keyword">implements</span> <span class="title class_">MathOperations</span> &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="title function_">subtract</span>(<span class="attr">x</span>: <span class="built_in">number</span>, <span class="attr">y</span>: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Calculator</span>, <span class="title class_">MathOperations</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calc = <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(calc.<span class="title function_">add</span>(<span class="number">5</span>, <span class="number">3</span>)); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h2 id="补充重点篇"><a href="#补充重点篇" class="headerlink" title="补充重点篇"></a>补充重点篇</h2><p>什么是类型收窄（Type Narrowing）？</p>
<p>类型收窄是TypeScript中缩小类型范围的过程，有多种方式可以实现类型收窄。</p>
<p>示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用类型守卫</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padLeft</span>(<span class="params"><span class="attr">padding</span>: <span class="built_in">number</span> | <span class="built_in">string</span>, <span class="attr">input</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里padding的类型被收窄为number</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.<span class="title function_">repeat</span>(padding) + input;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里padding的类型被收窄为string</span></span><br><span class="line">    <span class="keyword">return</span> padding + input;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用instanceof</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> &#123;</span><br><span class="line">    <span class="title function_">fly</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;flying...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> &#123;</span><br><span class="line">    <span class="title function_">swim</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;swimming...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">move</span>(<span class="params"><span class="attr">animal</span>: <span class="title class_">Bird</span> | <span class="title class_">Fish</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> <span class="title class_">Bird</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里animal的类型被收窄为Bird</span></span><br><span class="line">        animal.<span class="title function_">fly</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里animal的类型被收窄为Fish</span></span><br><span class="line">        animal.<span class="title function_">swim</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用in操作符</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Admin</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">privileges</span>: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">startDate</span>: <span class="title class_">Date</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printEmployeeInformation</span>(<span class="params"><span class="attr">emp</span>: <span class="title class_">Admin</span> | <span class="title class_">Employee</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;privileges&quot;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">        <span class="comment">// 这里emp的类型被收窄为Admin</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Privileges: &quot;</span> + emp.<span class="property">privileges</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;startDate&quot;</span> <span class="keyword">in</span> emp) &#123;</span><br><span class="line">        <span class="comment">// 这里emp的类型被收窄为Employee</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Start Date: &quot;</span> + emp.<span class="property">startDate</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-TypeScript中的tsconfig-json重要配置有哪些？"><a href="#12-TypeScript中的tsconfig-json重要配置有哪些？" class="headerlink" title="12. TypeScript中的tsconfig.json重要配置有哪些？"></a>12. TypeScript中的tsconfig.json重要配置有哪些？</h3><p>tsconfig.json是TypeScript项目的配置文件，包含许多重要选项。</p>
<p>示例代码：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">// 目标JavaScript版本</span></span><br><span class="line">        <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ES2020&quot;</span><span class="punctuation">,</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 模块系统</span></span><br><span class="line">        <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CommonJS&quot;</span><span class="punctuation">,</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 严格类型检查</span></span><br><span class="line">        <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 允许从没有默认导出的模块中默认导入</span></span><br><span class="line">        <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成声明文件</span></span><br><span class="line">        <span class="attr">&quot;declaration&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 允许装饰器</span></span><br><span class="line">        <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 模块解析策略</span></span><br><span class="line">        <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 基础目录</span></span><br><span class="line">        <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./src&quot;</span><span class="punctuation">,</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 路径别名</span></span><br><span class="line">        <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;@/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;*&quot;</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/**/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;node_modules&quot;</span><span class="punctuation">,</span> <span class="string">&quot;**/*.spec.ts&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="13-联合类型和交叉类型的区别是什么？"><a href="#13-联合类型和交叉类型的区别是什么？" class="headerlink" title="13. 联合类型和交叉类型的区别是什么？"></a>13. 联合类型和交叉类型的区别是什么？</h3><p>联合类型和交叉类型是TypeScript中两种重要的类型组合方式。</p>
<p>示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联合类型（Union Types）</span></span><br><span class="line"><span class="comment">// 表示可以是多种类型中的一种</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringOrNumber</span> = <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">printId</span>(<span class="params"><span class="attr">id</span>: <span class="title class_">StringOrNumber</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> id === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toUpperCase</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交叉类型（Intersection Types）</span></span><br><span class="line"><span class="comment">// 表示同时具有多种类型的特性</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ErrorHandling</span> &#123;</span><br><span class="line">    <span class="attr">success</span>: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="attr">error</span>?: &#123; <span class="attr">message</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ArtworksData</span> &#123;</span><br><span class="line">    <span class="attr">artworks</span>: &#123; <span class="attr">title</span>: <span class="built_in">string</span> &#125;[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时具有两个接口的所有属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ArtworksResponse</span> = <span class="title class_">ArtworksData</span> &amp; <span class="title class_">ErrorHandling</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">response</span>: <span class="title class_">ArtworksResponse</span> = &#123;</span><br><span class="line">    <span class="attr">artworks</span>: [&#123; <span class="attr">title</span>: <span class="string">&quot;Mona Lisa&quot;</span> &#125;],</span><br><span class="line">    <span class="attr">success</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="14-TypeScript-4-x和5-x有哪些重要新特性？"><a href="#14-TypeScript-4-x和5-x有哪些重要新特性？" class="headerlink" title="14. TypeScript 4.x和5.x有哪些重要新特性？"></a>14. TypeScript 4.x和5.x有哪些重要新特性？</h3><p>TypeScript的新版本带来了许多有用的特性。</p>
<p>示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript 4.0+: 可变元组类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Strings</span> = [<span class="built_in">string</span>, <span class="built_in">string</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Numbers</span> = [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringsAndNumbers</span> = [...<span class="title class_">Strings</span>, ...<span class="title class_">Numbers</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeScript 4.3+: override关键字</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Base</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeScript 4.4+: 控制流分析的改进</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">example</span>(<span class="params"><span class="attr">value</span>: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Math</span>.<span class="title function_">random</span>()) &#123;</span><br><span class="line">        value = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// TypeScript知道这里value一定是string</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(value.<span class="title function_">toUpperCase</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeScript 4.5+: Awaited类型</span></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Awaited</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;&gt;; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">Awaited</span>&lt;<span class="title class_">Promise</span>&lt;<span class="title class_">Promise</span>&lt;<span class="built_in">number</span>&gt;&gt;&gt;; <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeScript 4.9+: satisfies操作符</span></span><br><span class="line"><span class="keyword">const</span> palette = &#123;</span><br><span class="line">    <span class="attr">red</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="attr">green</span>: <span class="string">&quot;#00ff00&quot;</span>,</span><br><span class="line">&#125; <span class="keyword">satisfies</span> <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span> | <span class="built_in">number</span>[]&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeScript 5.0+: const类型参数</span></span><br><span class="line"><span class="keyword">function</span> first&lt;<span class="keyword">const</span> T <span class="keyword">extends</span> <span class="keyword">readonly</span> <span class="built_in">unknown</span>[]&gt;(<span class="attr">arr</span>: T) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeScript 5.2+: using关键字和显式资源管理</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileHandle</span> <span class="keyword">implements</span> <span class="title class_">Disposable</span> &#123;</span><br><span class="line">    <span class="title function_">dispose</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 清理资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> handle = <span class="keyword">new</span> <span class="title class_">FileHandle</span>();</span><br><span class="line">    <span class="comment">// 使用handle</span></span><br><span class="line">    <span class="comment">// 作用域结束时自动调用dispose</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-TypeScript中的类型体操实战有哪些？"><a href="#15-TypeScript中的类型体操实战有哪些？" class="headerlink" title="15. TypeScript中的类型体操实战有哪些？"></a>15. TypeScript中的类型体操实战有哪些？</h3><p>类型体操是TypeScript中高级类型的实际应用，经常出现在面试中。</p>
<p>示例代码：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现Pick类型  Pick</span></span><br><span class="line"><span class="comment">// Pick 从对象类型中仅保留指定的键，移除其他所有键</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyPick</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Readonly类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyReadonly</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现深度Readonly</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">DeepReadonly</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: T[P] <span class="keyword">extends</span> <span class="built_in">object</span> </span><br><span class="line">        ? <span class="title class_">DeepReadonly</span>&lt;T[P]&gt; </span><br><span class="line">        : T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Partial类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyPartial</span>&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Required类型 //移除可选符</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyRequired</span>&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]-?: T[P];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Record类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyRecord</span>&lt;K <span class="keyword">extends</span> keyof <span class="built_in">any</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Exclude类型 Exclude 从联合类型中移除类型。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyExclude</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? <span class="built_in">never</span> : T;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Extract类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyExtract</span>&lt;T, U&gt; = T <span class="keyword">extends</span> U ? T : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ReturnType类型 ReturnType 提取函数类型的返回类型。</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyReturnType</span>&lt;T <span class="title function_">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>&gt; = </span><br><span class="line">    T <span class="title function_">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; infer R ? R : <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际应用示例</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Todo</span> &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">description</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">completed</span>: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只读的Todo类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">ReadonlyTodo</span> = <span class="title class_">MyReadonly</span>&lt;<span class="title class_">Todo</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可选的Todo类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">PartialTodo</span> = <span class="title class_">MyPartial</span>&lt;<span class="title class_">Todo</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取Todo中的字符串类型属性</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">StringProps</span> = <span class="title class_">MyExtract</span>&lt;keyof <span class="title class_">Todo</span>, <span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/29/TS/" data-id="cmchpakn90001rsur0zqig9tx" data-title="TS" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Node" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/29/Node/" class="article-date">
  <time class="dt-published" datetime="2025-06-29T10:36:35.000Z" itemprop="datePublished">2025-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/29/Node/">Node</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时环境，它让开发者能够使用 JavaScript 编写服务器端代码。与传统的服务器端技术不同，Node.js 采用了<strong>事件驱动</strong>和<strong>非阻塞 I&#x2F;O</strong>模型，这使得它特别适合处理高并发的网络应用。</p>
<p><strong>核心特点</strong></p>
<ol>
<li><strong>单线程</strong>：Node.js 使用单线程处理请求</li>
<li><strong>事件循环</strong>：通过事件驱动机制处理并发</li>
<li><strong>非阻塞 I&#x2F;O</strong>：I&#x2F;O 操作不会阻塞主线程</li>
<li><strong>跨平台</strong>：可以在 Windows、Linux、macOS 等系统上运行</li>
</ol>
<p>Node.js 通过 V8 引擎执行 JavaScript 代码，使用 Node.js API 与操作系统交互，并通过 Libuv 处理异步 I&#x2F;O 操作。事件循环和工作线程确保了 Node.js 的高效和非阻塞特性。</p>
<h2 id="通讯方法"><a href="#通讯方法" class="headerlink" title="通讯方法"></a>通讯方法</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">XHR</th>
<th align="left">Fetch</th>
<th align="center">Axios</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>基本架构</strong></td>
<td align="left">事件回调机制</td>
<td align="left">Promise API</td>
<td align="center">Promise API</td>
</tr>
<tr>
<td align="left"><strong>浏览器支持</strong></td>
<td align="left">所有浏览器</td>
<td align="left">现代浏览器(不兼容IE)</td>
<td align="center">所有浏览器(通过polyfill)</td>
</tr>
<tr>
<td align="left"><strong>请求取消</strong></td>
<td align="left">支持</td>
<td align="left">需要AbortController</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="left"><strong>超时设置</strong></td>
<td align="left">支持</td>
<td align="left">不支持(需手动实现)</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="left"><strong>进度监控</strong></td>
<td align="left">支持(upload&#x2F;download)</td>
<td align="left">仅支持下载进度</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="left"><strong>拦截器</strong></td>
<td align="left">不支持</td>
<td align="left">不支持</td>
<td align="center">支持</td>
</tr>
<tr>
<td align="left"><strong>自动JSON转换</strong></td>
<td align="left">需要手动处理</td>
<td align="left">需要手动调用.json()</td>
<td align="center">自动转换</td>
</tr>
<tr>
<td align="left"><strong>CSRF防护</strong></td>
<td align="left">需要手动设置</td>
<td align="left">需要手动设置</td>
<td align="center">内置支持</td>
</tr>
<tr>
<td align="left"><strong>HTTP方法</strong></td>
<td align="left">需要.open()设置</td>
<td align="left">通过options.method设置</td>
<td align="center">提供对应方法别名</td>
</tr>
<tr>
<td align="left"><strong>请求&#x2F;响应拦截</strong></td>
<td align="left">不支持</td>
<td align="left">不支持</td>
<td align="center">支持</td>
</tr>
</tbody></table>
<h1 id="Node-js-事件循环"><a href="#Node-js-事件循环" class="headerlink" title="Node.js 事件循环"></a>Node.js 事件循环</h1><p>事件循环是 Node.js 处理非阻塞 I&#x2F;O 操作的核心机制，使得单线程能够高效处理多个并发请求。</p>
<p>Node.js 是基于单线程的 JavaScript 运行时，利用事件循环来处理异步操作，如文件读取、网络请求和数据库查询。</p>
<p>事件循环使得 Node.js 能够非阻塞地运行代码、处理多个连接、以及执行异步 I&#x2F;O 操作。</p>
<p>事件循环使得 Node.js 能够处理大量并发的 I&#x2F;O 操作而不会导致线程阻塞，这是 Node.js 高效处理并发请求的关键。</p>
<p><img src="/../img/1_SvTxMIEudVv8YRW_ELRamw.png" alt="img"></p>
<h3 id="事件循环的阶段"><a href="#事件循环的阶段" class="headerlink" title="事件循环的阶段"></a>事件循环的阶段</h3><p>事件循环分为多个阶段，每个阶段处理特定的任务。关键阶段如下：</p>
<ul>
<li><strong>Timers</strong>：执行 <code>setTimeout()</code> 和 <code>setInterval()</code> 的回调。</li>
<li><strong>I&#x2F;O Callbacks</strong>：处理一些延迟的 I&#x2F;O 回调。</li>
<li><strong>Idle, prepare</strong>：内部使用，不常见。</li>
<li><strong>Poll</strong>：检索新的 I&#x2F;O 事件，执行与 I&#x2F;O 相关的回调。</li>
<li><strong>Check</strong>：执行 <code>setImmediate()</code> 回调。</li>
<li><strong>Close Callbacks</strong>：处理关闭的回调，如 <code>socket.on(&#39;close&#39;, ...)</code>。</li>
</ul>
<h3 id="事件循环的流程"><a href="#事件循环的流程" class="headerlink" title="事件循环的流程"></a>事件循环的流程</h3><ul>
<li><strong>任务进入事件循环队列</strong>。</li>
<li>事件循环按照阶段顺序进行处理，每个阶段有自己的回调队列。</li>
<li>事件循环会在 <code>poll</code> 阶段等待新的事件到达，如果没有事件，会检查其他阶段的回调。</li>
<li>如果 <code>setImmediate()</code> 和 <code>setTimeout()</code> 都存在，<code>setImmediate()</code> 在 <code>check</code> 阶段先执行，而 <code>setTimeout()</code> 在 <code>timers</code> 阶段执行。</li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"> console.log(&#x27;Timeout callback&#x27;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line"> console.log(&#x27;Immediate callback&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;Main thread execution&#x27;);</span><br></pre></td></tr></table></figure>

<p>输出顺序：</p>
<ul>
<li><code>Main thread execution</code> 先打印。</li>
<li><code>setImmediate()</code> 和 <code>setTimeout()</code> 的执行顺序取决于当前事件循环的状态，一般 <code>setImmediate()</code> 会先执行。</li>
</ul>
<h3 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h3><ul>
<li><strong>宏任务</strong>：<code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code>、I&#x2F;O 操作等。</li>
<li><strong>微任务</strong>：<code>process.nextTick</code>、<code>Promise.then</code>。</li>
</ul>
<p>**执行顺序：**微任务优先级高于宏任务，会在当前阶段的回调结束后立即执行。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line"> console.log(&#x27;Timeout callback&#x27;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">Promise.resolve().then(() =&gt; &#123;</span><br><span class="line"> console.log(&#x27;Promise callback&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;Main thread execution&#x27;);</span><br></pre></td></tr></table></figure>

<p>执行输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Main thread execution</span><br><span class="line">Promise callback</span><br><span class="line">Timeout callback</span><br></pre></td></tr></table></figure>

<h3 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h3><p>process.nextTick() 会在当前操作结束后、下一个阶段开始前执行微任务，优先级高于 Promise。</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(() =&gt; &#123;</span><br><span class="line"> console.log(&#x27;Next tick callback&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#x27;Main thread execution&#x27;);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main thread execution</span><br><span class="line">Next tick callback</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="事件驱动程序"><a href="#事件驱动程序" class="headerlink" title="事件驱动程序"></a>事件驱动程序</h2><p>在 Node.js 中，事件驱动编程主要通过 EventEmitter 类来实现。</p>
<p>EventEmitter 是一个内置类，位于 events 模块中，通过继承 EventEmitter，你可以创建自己的事件发射器，并注册和触发事件。</p>
<p>通过这种机制，Node.js 可以高效地处理异步任务，即使在单线程的环境下也能实现并发处理。</p>
<p><img src="/../img/event_loop.jpg" alt="img"></p>
<p>整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。</p>
<p><strong>基本概念：</strong></p>
<ul>
<li><strong>事件</strong>：在程序中发生的动作或状态改变，例如一个文件读取完成或一个 HTTP 请求到达。</li>
<li><strong>事件触发器</strong>：<code>EventEmitter</code> 是 Node.js 的内置模块，用来发出和监听事件。</li>
<li><strong>事件处理器</strong>：与事件关联的回调函数，事件发生时被调用。</li>
</ul>
<p><strong>事件驱动的流程：</strong></p>
<ul>
<li><strong>注册事件</strong>：在程序中通过 <code>EventEmitter</code> 实例注册事件和对应的处理器。</li>
<li><strong>触发事件</strong>：当指定的事件发生时，<code>EventEmitter</code> 会触发该事件。</li>
<li><strong>处理事件</strong>：事件循环会调度相应的回调函数来执行任务。</li>
</ul>
<p>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 引入 events 模块</span><br><span class="line">var events = require(&#x27;events&#x27;);</span><br><span class="line">// 创建 eventEmitter 对象</span><br><span class="line">var eventEmitter = new events.EventEmitter();</span><br></pre></td></tr></table></figure>

<p>以下程序绑定事件处理程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 绑定事件及事件的处理程序</span><br><span class="line">eventEmitter.on(&#x27;eventName&#x27;, eventHandler);</span><br></pre></td></tr></table></figure>

<p>我们可以通过程序触发事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 触发事件</span><br><span class="line">eventEmitter.emit(&#x27;eventName&#x27;);</span><br></pre></td></tr></table></figure>

<h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>创建 hello.js 文件，代码如下所示：</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例 1"></a>实例 1</h2><p><strong>const</strong> EventEmitter &#x3D; require(‘events’);<br><strong>const</strong> myEmitter &#x3D; <strong>new</strong> EventEmitter();</p>
<p><em>&#x2F;&#x2F; 注册事件处理器</em><br>myEmitter.on(‘greet’, () &#x3D;&gt; {<br> console.log(‘Hello, world!’);<br>});</p>
<p><em>&#x2F;&#x2F; 触发事件</em><br>myEmitter.emit(‘greet’);</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p>创建 main.js 文件，代码如下所示：</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例 2"></a>实例 2</h2><p>&#x2F;&#x2F; 引入 events 模块 var events &#x3D; require(‘events’); &#x2F;&#x2F; 创建 eventEmitter 对象 var eventEmitter &#x3D; new events.EventEmitter();  &#x2F;&#x2F; 创建事件处理程序 var connectHandler &#x3D; function connected() {   console.log(‘连接成功。’);     &#x2F;&#x2F; 触发 data_received 事件    eventEmitter.emit(‘data_received’); }  &#x2F;&#x2F; 绑定 connection 事件处理程序 eventEmitter.on(‘connection’, connectHandler);  &#x2F;&#x2F; 使用匿名函数绑定 data_received 事件 eventEmitter.on(‘data_received’, function(){   console.log(‘数据接收成功。’); });  &#x2F;&#x2F; 触发 connection 事件  eventEmitter.emit(‘connection’);  console.log(“程序执行完毕。”);</p>
<p>接下来让我们执行以上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">连接成功。</span><br><span class="line">数据接收成功。</span><br><span class="line">程序执行完毕。</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Node-应用程序是如何工作的？"><a href="#Node-应用程序是如何工作的？" class="headerlink" title="Node 应用程序是如何工作的？"></a>Node 应用程序是如何工作的？</h2><p>在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。</p>
<p>接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure>

<p>创建 main.js 文件，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&#x27;input.txt&#x27;, function (err, data) &#123;</span><br><span class="line">   if (err)&#123;</span><br><span class="line">      console.log(err.stack);</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;程序执行完毕&quot;);</span><br></pre></td></tr></table></figure>

<p>以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。</p>
<p>如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。</p>
<p>执行以上代码，执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">程序执行完毕</span><br><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure>

<p>接下来我们删除 input.txt 文件，执行结果如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">程序执行完毕</span><br><span class="line">Error: ENOENT, open &#x27;input.txt&#x27;</span><br></pre></td></tr></table></figure>

<p>因为文件 input.txt 不存在，所以输出了错误信息。</p>
<h1 id="Node-js-中的流-Stream-、缓冲区-Buffer-与浏览器中的Blob对比"><a href="#Node-js-中的流-Stream-、缓冲区-Buffer-与浏览器中的Blob对比" class="headerlink" title="Node.js 中的流(Stream)、缓冲区(Buffer)与浏览器中的Blob对比"></a>Node.js 中的流(Stream)、缓冲区(Buffer)与浏览器中的Blob对比</h1><h2 id="一、核心概念对比"><a href="#一、核心概念对比" class="headerlink" title="一、核心概念对比"></a>一、核心概念对比</h2><table>
<thead>
<tr>
<th align="left">概念</th>
<th align="left">环境</th>
<th align="left">本质</th>
<th align="left">主要用途</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Stream</strong></td>
<td align="left">Node.js</td>
<td align="left">数据处理的抽象接口</td>
<td align="left">处理大量数据或I&#x2F;O操作</td>
<td align="left">分块处理、内存高效</td>
</tr>
<tr>
<td align="left"><strong>Buffer</strong></td>
<td align="left">Node.js</td>
<td align="left">固定大小的二进制数据块</td>
<td align="left">临时存储原始二进制数据</td>
<td align="left">内存操作、快速访问</td>
</tr>
<tr>
<td align="left"><strong>Blob</strong></td>
<td align="left">浏览器</td>
<td align="left">不可变的类文件对象</td>
<td align="left">表示二进制数据(如图片、文件)</td>
<td align="left">浏览器环境专用、支持切片操作</td>
</tr>
</tbody></table>
<h2 id="二、Node-js-中的流-Stream-详解"><a href="#二、Node-js-中的流-Stream-详解" class="headerlink" title="二、Node.js 中的流(Stream)详解"></a>二、Node.js 中的流(Stream)详解</h2><h3 id="1-四种流类型"><a href="#1-四种流类型" class="headerlink" title="1. 四种流类型"></a>1. 四种流类型</h3><table>
<thead>
<tr>
<th align="left">流类型</th>
<th align="left">描述</th>
<th align="left">示例场景</th>
<th align="left">关键方法&#x2F;事件</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Readable</strong></td>
<td align="left">可读数据源</td>
<td align="left">文件读取、HTTP请求</td>
<td align="left"><code>read()</code>, <code>data</code>, <code>end</code></td>
</tr>
<tr>
<td align="left"><strong>Writable</strong></td>
<td align="left">可写数据目标</td>
<td align="left">文件写入、HTTP响应</td>
<td align="left"><code>write()</code>, <code>end</code>, <code>drain</code></td>
</tr>
<tr>
<td align="left"><strong>Duplex</strong></td>
<td align="left">双向流(可读可写)</td>
<td align="left">TCP套接字、WebSocket</td>
<td align="left">兼具读写方法</td>
</tr>
<tr>
<td align="left"><strong>Transform</strong></td>
<td align="left">转换流(读写+数据处理)</td>
<td align="left">压缩&#x2F;加密流</td>
<td align="left"><code>_transform()</code>, <code>_flush</code></td>
</tr>
</tbody></table>
<h3 id="2-流的工作模式"><a href="#2-流的工作模式" class="headerlink" title="2. 流的工作模式"></a>2. 流的工作模式</h3><p>javascript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&#x27;fs&#x27;);</span><br><span class="line"></span><br><span class="line">// 创建可读流</span><br><span class="line">const readable = fs.createReadStream(&#x27;input.txt&#x27;);</span><br><span class="line"></span><br><span class="line">// 创建可写流</span><br><span class="line">const writable = fs.createWriteStream(&#x27;output.txt&#x27;);</span><br><span class="line"></span><br><span class="line">// 管道连接（自动处理背压）</span><br><span class="line">readable.pipe(writable);</span><br><span class="line"></span><br><span class="line">// 手动处理数据块</span><br><span class="line">readable.on(&#x27;data&#x27;, (chunk) =&gt; &#123;</span><br><span class="line">  console.log(`Received $&#123;chunk.length&#125; bytes`);</span><br><span class="line">  writable.write(chunk);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readable.on(&#x27;end&#x27;, () =&gt; &#123;</span><br><span class="line">  writable.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="三、Node-js-中的缓冲区-Buffer"><a href="#三、Node-js-中的缓冲区-Buffer" class="headerlink" title="三、Node.js 中的缓冲区(Buffer)"></a>三、Node.js 中的缓冲区(Buffer)</h2><h3 id="1-Buffer-核心特性"><a href="#1-Buffer-核心特性" class="headerlink" title="1. Buffer 核心特性"></a>1. Buffer 核心特性</h3><ul>
<li><strong>二进制容器</strong>：存储原始二进制数据</li>
<li><strong>固定大小</strong>：创建时分配固定内存</li>
<li><strong>高效操作</strong>：提供多种数据操作API</li>
</ul>
<h3 id="2-常见使用场景"><a href="#2-常见使用场景" class="headerlink" title="2. 常见使用场景"></a>2. 常见使用场景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 创建Buffer</span><br><span class="line">const buf1 = Buffer.alloc(10); // 10字节缓冲区</span><br><span class="line">const buf2 = Buffer.from(&#x27;Hello&#x27;); // 从字符串创建</span><br><span class="line"></span><br><span class="line">// 写入数据</span><br><span class="line">buf1.write(&#x27;Node.js&#x27;);</span><br><span class="line"></span><br><span class="line">// 读取数据</span><br><span class="line">console.log(buf1.toString(&#x27;utf8&#x27;, 0, 6)); // &quot;Node.j&quot;</span><br><span class="line"></span><br><span class="line">// 与流交互</span><br><span class="line">readable.on(&#x27;data&#x27;, (chunk) =&gt; &#123;</span><br><span class="line">  // chunk是Buffer实例</span><br><span class="line">  console.log(chunk.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="3-Buffer-与-Stream-的关系"><a href="#3-Buffer-与-Stream-的关系" class="headerlink" title="3. Buffer 与 Stream 的关系"></a>3. Buffer 与 Stream 的关系</h3><ul>
<li><p>流处理的数据块默认是Buffer类型</p>
</li>
<li><p>可设置流编码直接处理字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readable.setEncoding(&#x27;utf8&#x27;);</span><br><span class="line">readable.on(&#x27;data&#x27;, (str) =&gt; &#123;</span><br><span class="line">  // 现在chunk是字符串</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="四、浏览器中的-Blob"><a href="#四、浏览器中的-Blob" class="headerlink" title="四、浏览器中的 Blob"></a>四、浏览器中的 Blob</h2><h3 id="1-Blob-核心特性"><a href="#1-Blob-核心特性" class="headerlink" title="1. Blob 核心特性"></a>1. Blob 核心特性</h3><ul>
<li><strong>类文件对象</strong>：表示原始数据</li>
<li><strong>不可变性</strong>：创建后内容不可更改</li>
<li><strong>浏览器专用</strong>：Node.js 中不可用</li>
</ul>
<h3 id="2-常见使用场景-1"><a href="#2-常见使用场景-1" class="headerlink" title="2. 常见使用场景"></a>2. 常见使用场景</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 创建Blob</span><br><span class="line">const blob = new Blob([&#x27;Hello, world!&#x27;], &#123; type: &#x27;text/plain&#x27; &#125;);</span><br><span class="line"></span><br><span class="line">// 读取Blob内容</span><br><span class="line">const reader = new FileReader();</span><br><span class="line">reader.onload = () =&gt; &#123;</span><br><span class="line">  console.log(reader.result); // &quot;Hello, world!&quot;</span><br><span class="line">&#125;;</span><br><span class="line">reader.readAsText(blob);</span><br><span class="line"></span><br><span class="line">// 创建URL</span><br><span class="line">const url = URL.createObjectURL(blob);</span><br><span class="line">const a = document.createElement(&#x27;a&#x27;);</span><br><span class="line">a.href = url;</span><br><span class="line">a.download = &#x27;example.txt&#x27;;</span><br><span class="line">a.click();</span><br><span class="line"></span><br><span class="line">// 切片处理大文件</span><br><span class="line">const slice = blob.slice(0, 1024); // 前1KB</span><br></pre></td></tr></table></figure>

<h2 id="五、三者对比与转换"><a href="#五、三者对比与转换" class="headerlink" title="五、三者对比与转换"></a>五、三者对比与转换</h2><h3 id="1-Node-js-环境中的转换"><a href="#1-Node-js-环境中的转换" class="headerlink" title="1. Node.js 环境中的转换"></a>1. Node.js 环境中的转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Buffer 转 Blob (Node.js v15+)</span><br><span class="line">const &#123; Blob &#125; = require(&#x27;buffer&#x27;);</span><br><span class="line">const buffer = Buffer.from(&#x27;Hello&#x27;);</span><br><span class="line">const blob = new Blob([buffer]);</span><br><span class="line"></span><br><span class="line">// Stream 转 Buffer</span><br><span class="line">async function streamToBuffer(stream) &#123;</span><br><span class="line">  const chunks = [];</span><br><span class="line">  for await (const chunk of stream) &#123;</span><br><span class="line">    chunks.push(chunk);</span><br><span class="line">  &#125;</span><br><span class="line">  return Buffer.concat(chunks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-浏览器环境中的转换"><a href="#2-浏览器环境中的转换" class="headerlink" title="2. 浏览器环境中的转换"></a>2. 浏览器环境中的转换</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Blob 转 ReadableStream</span><br><span class="line">const readableStream = blob.stream();</span><br><span class="line"></span><br><span class="line">// Fetch 响应转 Blob</span><br><span class="line">fetch(&#x27;image.png&#x27;)</span><br><span class="line">  .then(response =&gt; response.blob())</span><br><span class="line">  .then(blob =&gt; &#123;</span><br><span class="line">    // 使用Blob</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h1 id="Express、Koa-和-Egg-js"><a href="#Express、Koa-和-Egg-js" class="headerlink" title="Express、Koa 和 Egg.js"></a>Express、Koa 和 Egg.js</h1><p>是 Node.js 生态中三个重要的 Web 框架，它们在设计理念、底层原理和适用场景上有显著差异。以下从核心原理、异步处理、中间件机制、架构设计和适用场景等维度进行综合对比：</p>
<hr>
<h3 id="⚙️-一、核心原理与异步处理"><a href="#⚙️-一、核心原理与异步处理" class="headerlink" title="⚙️ 一、核心原理与异步处理"></a>⚙️ 一、<strong>核心原理与异步处理</strong></h3><ol>
<li><strong>Express</strong><ul>
<li><strong>回调驱动</strong>：基于回调函数处理异步，易导致“回调地狱”（Callback Hell）17。</li>
<li><strong>线性模型</strong>：中间件顺序执行，<code>next()</code> 仅触发下一个中间件，但无法等待后续中间件完成再回溯78。</li>
<li><strong>响应时机</strong>：调用 <code>res.send()</code> 立即结束响应，后续中间件无法修改响应38。</li>
</ul>
</li>
<li><strong>Koa（Koa2）</strong><ul>
<li><strong>Async&#x2F;Await 驱动</strong>：基于 Promise 和 Async&#x2F;Await，支持同步化书写异步代码16。</li>
<li><strong>洋葱模型</strong>：通过 <code>await next()</code> 控制流程，中间件执行两次（请求 → 响应），支持后置处理（如日志记录）18。</li>
<li><strong>延迟响应</strong>：<code>ctx.body</code> 设置响应数据，但实际响应在所有中间件完成后由 Koa 触发38。</li>
</ul>
</li>
<li><strong>Egg.js</strong><ul>
<li><strong>基于 Koa 封装</strong>：继承 Koa 的洋葱模型，但扩展了企业级特性（如插件化、约定式配置）4。</li>
<li><strong>异步处理</strong>：沿用 Async&#x2F;Await，但通过 <code>app/extend</code> 扩展上下文（Context），提供更多工具方法4。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="🔄-二、中间件机制"><a href="#🔄-二、中间件机制" class="headerlink" title="🔄 二、中间件机制"></a>🔄 二、<strong>中间件机制</strong></h3><table>
<thead>
<tr>
<th align="left"><strong>框架</strong></th>
<th align="left"><strong>执行模型</strong></th>
<th align="left"><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Express</strong></td>
<td align="left">线性模型</td>
<td align="left">中间件顺序执行，无回溯机制；依赖 <code>next()</code> 手动传递控制权78。</td>
</tr>
<tr>
<td align="left"><strong>Koa</strong></td>
<td align="left">洋葱模型</td>
<td align="left">中间件双向执行（请求向下 → 响应向上），支持异步等待回溯18。</td>
</tr>
<tr>
<td align="left"><strong>Egg</strong></td>
<td align="left">洋葱模型（增强版）</td>
<td align="left">继承 Koa 模型，但通过中间件加载顺序和插件机制提供更精细控制4。</td>
</tr>
</tbody></table>
<p><strong>示例对比</strong>：</p>
<p>javascript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// Express：next() 后无法再次操作响应</span><br><span class="line">app.use((req, res, next) =&gt; &#123;</span><br><span class="line">  console.log(&quot;Start&quot;);</span><br><span class="line">  next();  // 移交控制权</span><br><span class="line">  console.log(&quot;End&quot;);  // 在响应发送后执行</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Koa：await next() 可等待后续中间件完成</span><br><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  console.log(&quot;Start&quot;);</span><br><span class="line">  await next();  // 等待下游中间件执行完毕</span><br><span class="line">  console.log(&quot;End&quot;);  // 响应前可再次修改 ctx</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🏗️-三、架构设计与扩展性"><a href="#🏗️-三、架构设计与扩展性" class="headerlink" title="🏗️ 三、架构设计与扩展性"></a>🏗️ 三、<strong>架构设计与扩展性</strong></h3><ol>
<li><strong>Express</strong><ul>
<li><strong>大而全</strong>：内置路由、模板引擎、静态文件服务等，开箱即用26。</li>
<li><strong>弱扩展性</strong>：缺少统一的扩展机制，依赖第三方中间件组合6。</li>
</ul>
</li>
<li><strong>Koa</strong><ul>
<li><strong>极简内核</strong>：仅封装 HTTP 上下文（Context），不内置任何中间件（路由需通过 <code>koa-router</code> 添加）26。</li>
<li><strong>高扩展性</strong>：通过 <code>app.context</code> 可灵活扩展全局属性6。</li>
</ul>
</li>
<li><strong>Egg.js</strong><ul>
<li><strong>企业级框架</strong>：基于 Koa 封装，提供插件化架构、约定式目录结构和配置管理4。</li>
<li><strong>扩展点丰富</strong>：支持 <code>app/extend/&#123;application, context, request, response&#125;</code> 扩展原型4。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="🛡️-四、错误处理"><a href="#🛡️-四、错误处理" class="headerlink" title="🛡️ 四、错误处理"></a>🛡️ 四、<strong>错误处理</strong></h3><ul>
<li><p><strong>Express</strong>：需手动捕获异步错误，或在中间件末尾添加错误处理函数7。</p>
</li>
<li><p><strong>Koa</strong>：可通过顶层 <code>try/catch</code> 捕获整个洋葱模型的同步&#x2F;异步错误18：</p>
<p>javascript</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  try &#123; await next(); &#125;</span><br><span class="line">  catch (err) &#123; ctx.status = 500; &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Egg.js</strong>：内置统一错误处理，支持配置错误页面和日志上报4。</p>
</li>
</ul>
<hr>
<h3 id="🎯-五、适用场景总结"><a href="#🎯-五、适用场景总结" class="headerlink" title="🎯 五、适用场景总结"></a>🎯 五、<strong>适用场景总结</strong></h3><table>
<thead>
<tr>
<th align="left"><strong>框架</strong></th>
<th align="left"><strong>场景</strong></th>
<th align="left"><strong>代表用户</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Express</strong></td>
<td align="left">中小项目快速开发；需兼容旧版 Node.js 或回调风格</td>
<td align="left">传统企业、遗留系统</td>
</tr>
<tr>
<td align="left"><strong>Koa</strong></td>
<td align="left">追求现代异步编程；高自由度定制中间件栈</td>
<td align="left">技术前沿团队、开源项目</td>
</tr>
<tr>
<td align="left"><strong>Egg.js</strong></td>
<td align="left">大型企业应用；需插件化管理、团队协作规范</td>
<td align="left">阿里系产品（如蚂蚁金服）</td>
</tr>
</tbody></table>
<hr>
<h3 id="💎-三框架核心区别总结"><a href="#💎-三框架核心区别总结" class="headerlink" title="💎 三框架核心区别总结"></a>💎 <strong>三框架核心区别总结</strong></h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>Express</strong></th>
<th align="left"><strong>Koa</strong></th>
<th align="left"><strong>Egg.js</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>异步模型</strong></td>
<td align="left">回调函数</td>
<td align="left">Async&#x2F;Await</td>
<td align="left">Async&#x2F;Await</td>
</tr>
<tr>
<td align="left"><strong>中间件机制</strong></td>
<td align="left">线性执行</td>
<td align="left">洋葱模型</td>
<td align="left">洋葱模型（增强）</td>
</tr>
<tr>
<td align="left"><strong>路由&#x2F;视图</strong></td>
<td align="left">内置支持</td>
<td align="left">需插件</td>
<td align="left">内置 + 插件扩展</td>
</tr>
<tr>
<td align="left"><strong>扩展性</strong></td>
<td align="left">低（依赖中间件）</td>
<td align="left">高（自由组合）</td>
<td align="left">极高（插件化）</td>
</tr>
<tr>
<td align="left"><strong>适用规模</strong></td>
<td align="left">中小项目</td>
<td align="left">中小到大型</td>
<td align="left">中大型企业级</td>
</tr>
<tr>
<td align="left"><strong>学习曲线</strong></td>
<td align="left">低</td>
<td align="left">中</td>
<td align="left">中高</td>
</tr>
</tbody></table>
<h1 id="Node-js-全局对象与全局变量详解"><a href="#Node-js-全局对象与全局变量详解" class="headerlink" title="Node.js 全局对象与全局变量详解"></a>Node.js 全局对象与全局变量详解</h1><h2 id="Node-js-全局对象概览"><a href="#Node-js-全局对象概览" class="headerlink" title="Node.js 全局对象概览"></a>Node.js 全局对象概览</h2><p>Node.js 中的全局对象 <code>global</code> 类似于浏览器中的 <code>window</code> 对象，提供对全局变量和函数的访问。以下是核心全局对象和变量：</p>
<h3 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h3><table>
<thead>
<tr>
<th align="left">对象名称</th>
<th align="left">描述</th>
<th align="left">使用示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>global</code></td>
<td align="left">顶层全局对象，所有全局变量都是它的属性</td>
<td align="left"><code>global.console.log()</code></td>
</tr>
<tr>
<td align="left"><code>process</code></td>
<td align="left">提供当前 Node.js 进程的信息和控制</td>
<td align="left"><code>process.env.NODE_ENV</code></td>
</tr>
<tr>
<td align="left"><code>console</code></td>
<td align="left">提供调试输出功能</td>
<td align="left"><code>console.error(&#39;Error!&#39;)</code></td>
</tr>
<tr>
<td align="left"><code>Buffer</code></td>
<td align="left">处理二进制数据的类</td>
<td align="left"><code>Buffer.from(&#39;hello&#39;)</code></td>
</tr>
<tr>
<td align="left"><code>module</code></td>
<td align="left">当前模块的引用</td>
<td align="left"><code>module.exports = &#123;&#125;</code></td>
</tr>
<tr>
<td align="left"><code>exports</code></td>
<td align="left"><code>module.exports</code> 的引用</td>
<td align="left"><code>exports.func = () =&gt; &#123;&#125;</code></td>
</tr>
<tr>
<td align="left"><code>require()</code></td>
<td align="left">引入模块的函数</td>
<td align="left"><code>const fs = require(&#39;fs&#39;)</code></td>
</tr>
</tbody></table>
<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><table>
<thead>
<tr>
<th align="left">变量名称</th>
<th align="left">描述</th>
<th align="left">使用示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>__filename</code></td>
<td align="left">当前模块文件的绝对路径</td>
<td align="left"><code>console.log(__filename)</code></td>
</tr>
<tr>
<td align="left"><code>__dirname</code></td>
<td align="left">当前模块所在目录的绝对路径</td>
<td align="left"><code>console.log(__dirname)</code></td>
</tr>
<tr>
<td align="left"><code>setTimeout</code></td>
<td align="left">定时执行函数</td>
<td align="left"><code>setTimeout(fn, 1000)</code></td>
</tr>
<tr>
<td align="left"><code>setInterval</code></td>
<td align="left">定时循环执行函数</td>
<td align="left"><code>setInterval(fn, 1000)</code></td>
</tr>
<tr>
<td align="left"><code>setImmediate</code></td>
<td align="left">在当前事件循环结束时执行函数</td>
<td align="left"><code>setImmediate(fn)</code></td>
</tr>
<tr>
<td align="left"><code>clearTimeout</code></td>
<td align="left">取消由 <code>setTimeout()</code> 创建的定时器</td>
<td align="left"><code>clearTimeout(timer)</code></td>
</tr>
<tr>
<td align="left"><code>clearInterval</code></td>
<td align="left">取消由 <code>setInterval()</code> 创建的定时器</td>
<td align="left"><code>clearInterval(timer)</code></td>
</tr>
<tr>
<td align="left"><code>clearImmediate</code></td>
<td align="left">取消由 <code>setImmediate()</code> 创建的定时器</td>
<td align="left"><code>clearImmediate(timer)</code></td>
</tr>
</tbody></table>
<h1 id="CommonJS和ES6-Module的区别时"><a href="#CommonJS和ES6-Module的区别时" class="headerlink" title="CommonJS和ES6 Module的区别时"></a>CommonJS和ES6 Module的区别时</h1><p>我们可以归纳出以下几点：</p>
<ol>
<li><strong>语法差异</strong>：CommonJS使用<code>require</code>和<code>module.exports</code>，ES6 Module使用<code>import</code>和<code>export</code>。</li>
<li><strong>加载机制</strong>：CommonJS是运行时加载，ES6 Module是静态加载。</li>
<li><strong>值的处理</strong>：CommonJS导出的是值的拷贝，ES6 Module导出的是值的引用。</li>
<li><strong>模块对象</strong>：CommonJS使用<code>module.exports</code>，ES6 Module使用<code>export</code>。</li>
<li><strong>this指向</strong>：CommonJS中的<code>this</code>指向模块对象，而ES6 Module中的<code>this</code>是<code>undefined</code>。</li>
<li><strong>文件扩展名</strong>：CommonJS可以省略<code>.js</code>，而ES6 Module必须带扩展名。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/29/Node/" data-id="cmchjc7wx000094ur3o1r0toc" data-title="Node" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-前端工程化" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/29/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" class="article-date">
  <time class="dt-published" datetime="2025-06-29T09:09:27.000Z" itemprop="datePublished">2025-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/29/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="npm、yarn-和-pnpm"><a href="#npm、yarn-和-pnpm" class="headerlink" title="npm、yarn 和 pnpm"></a><code>npm</code>、<code>yarn</code> 和 <code>pnpm</code></h1><hr>
<p> <strong>一、技术原理与核心区别</strong></p>
<ol>
<li><strong>依赖管理机制</strong></li>
</ol>
<ul>
<li><strong>npm</strong><ul>
<li><strong>嵌套结构（v2）</strong>：依赖树深层嵌套，相同依赖重复安装，路径过长易超 Windows 限制。</li>
<li><strong>扁平化（v3+）</strong>：依赖提升至顶层，减少重复。但多个版本时仅提升一个，其余版本仍嵌套安装，导致 <strong>依赖分身</strong>（同一包多版本重复存储）。</li>
</ul>
</li>
<li><strong>yarn</strong><ul>
<li><strong>扁平化 + 缓存</strong>：依赖提升至顶层，通过 <code>yarn.lock</code> 锁定版本；并行下载加速安装，缓存机制减少重复下载26。</li>
<li><strong>问题未根治</strong>：仍存在 <strong>幽灵依赖</strong>（未声明的依赖因提升被访问）和 <strong>依赖分身</strong>。</li>
</ul>
</li>
<li><strong>pnpm</strong><ul>
<li><strong>硬链接 + 符号链接</strong>：<ul>
<li><strong>全局存储</strong>（<code>~/.pnpm-store</code>）：每个依赖版本仅存一份。</li>
<li><strong>硬链接</strong>：项目中的依赖通过硬链接指向全局存储，避免磁盘冗余。</li>
<li><strong>符号链接</strong>：<code>node_modules</code> 中只包含直接依赖的符号链接，子依赖通过 <code>.pnpm</code> 目录的软链接组织，严格隔离依赖。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>性能与磁盘效率</strong></li>
</ol>
<table>
<thead>
<tr>
<th align="left">工具</th>
<th align="left">安装速度</th>
<th align="left">磁盘占用</th>
<th align="left">原理优化</th>
</tr>
</thead>
<tbody><tr>
<td align="left">npm</td>
<td align="left">⚠️ 慢（串行）</td>
<td align="left">❌ 高（重复存储）</td>
<td align="left">扁平化减少嵌套问题</td>
</tr>
<tr>
<td align="left">yarn</td>
<td align="left">✅ 快（并行）</td>
<td align="left">⚠️ 中（缓存共享）</td>
<td align="left">并行下载 + 缓存复用</td>
</tr>
<tr>
<td align="left">pnpm</td>
<td align="left">✅ 极快（链接）</td>
<td align="left">✅ 低（全局单份存储）</td>
<td align="left">硬链接 + 符号链接</td>
</tr>
</tbody></table>
<ol start="3">
<li><strong>安全性 &amp; 一致性</strong></li>
</ol>
<ul>
<li><strong>锁定文件</strong>：<ul>
<li><code>npm</code>：<code>package-lock.json</code>（锁定版本，但早期版本存在安全漏洞）。</li>
<li><code>yarn/pnpm</code>：<code>yarn.lock</code>&#x2F;<code>pnpm-lock.yaml</code>（严格锁定版本及哈希值，防篡改）。</li>
</ul>
</li>
<li><strong>依赖隔离</strong>：<ul>
<li><code>pnpm</code> 仅允许访问显式声明的依赖，彻底杜绝幽灵依赖；<code>npm/yarn</code> 因扁平化无法解决。</li>
</ul>
</li>
</ul>
<hr>
<p> <strong>二、依然存在的问题</strong></p>
<ol>
<li><strong>npm</strong></li>
</ol>
<ul>
<li><strong>依赖不确定性</strong>：扁平化导致依赖结构因安装顺序差异可能不同，需依赖 <code>package-lock.json</code> 补救36。</li>
<li><strong>磁盘冗余</strong>：相同依赖在不同项目中重复存储。</li>
</ul>
<ol start="2">
<li><strong>yarn</strong></li>
</ol>
<ul>
<li><strong>幽灵依赖</strong>：未声明的依赖仍可访问，移除父依赖后可能引发运行时错误58。</li>
<li><strong>依赖分身</strong>：多版本包的非提升版本仍重复安装。</li>
</ul>
<ol start="3">
<li><strong>pnpm</strong></li>
</ol>
<ul>
<li><strong>软链接兼容性</strong>：<ul>
<li>不支持软链接的环境（如部分 Electron 应用、Windows 受限模式）无法使用。</li>
</ul>
</li>
<li><strong>调试与补丁困难</strong>：<ul>
<li>依赖源文件在全局存储，修改需通过 <code>pnpm patch</code> 命令，不如直接修改 <code>node_modules</code> 直观。</li>
</ul>
</li>
<li><strong>生态兼容性</strong>：<ul>
<li>少数依赖路径硬编码的包（如某些 Webpack 插件）可能运行失败</li>
</ul>
</li>
</ul>
<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p><strong>Webpack是基于模块化打包的⼯具:</strong> ⾃动化处理模块，webpack把⼀切当成模块，当 webpack 处理应⽤程序时，它会递归地构建⼀个依赖关系图 (dependency graph)，其中包含应⽤程序需要的每个模块，然后将所有这些模块打包成⼀个或多个 bundle。 </p>
<h3 id="webpack的构建流程"><a href="#webpack的构建流程" class="headerlink" title="webpack的构建流程**?**"></a><strong>webpack</strong>的构建流程**?**</h3><p>Webpack 的运⾏流程是⼀个串⾏的过程，从启动到结束会依次执⾏以下流程： </p>
<ol>
<li><strong>初始化参数</strong>：从配置⽂件和 Shell 语句中读取与合并参数，得出最终的参数； </li>
<li><strong>开始编译</strong>：⽤上⼀步得到的参数初始化 Compiler 对象，加载所有配置的插件，执⾏对象的 run ⽅法开始执⾏编译； </li>
<li><strong>确定⼊⼝</strong>：根据配置中的 entry 找出所有的⼊⼝⽂件； </li>
<li><strong>编译模块</strong>：从⼊⼝⽂件出发，调⽤所有配置的 Loader 对模块进⾏翻译，再找出该模块依赖的模块，再递归本步骤直到所有⼊⼝依赖的⽂件都经过了本步骤的处理； </li>
<li><strong>完成模块编译</strong>：在经过第4步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； </li>
<li><strong>输出资源</strong>：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会； </li>
<li><strong>输出完成</strong>：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统。</li>
</ol>
<p>在以上过程中，Webpack 会在特定的时间点⼴播出特定的事件，插件在监听到感兴趣的事件后会执⾏特定的逻辑，并且插件可以调⽤ Webpack 提供的 API 改变 Webpack 的运⾏结果。</p>
<h3 id="常⻅的Loader"><a href="#常⻅的Loader" class="headerlink" title="常⻅的Loader"></a>常⻅的<strong>Loader</strong></h3><ul>
<li>file-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件 </li>
<li>url-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去 </li>
<li>source-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试 </li>
<li>image-loader：加载并且压缩图⽚⽂件 </li>
<li>babel-loader：把 ES6 转换成 ES5 </li>
<li>css-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性 </li>
<li>style-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。 </li>
<li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li>
</ul>
<p><strong>注意：<strong>在Webpack中，loader的执行顺序是</strong>从右向左</strong>执行的。因为webpack选择了<strong>compose这样的函数式编程方式</strong>，这种方式的表达式执行是从右向左的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      <span class="comment">// 处理 JavaScript/TypeScript 文件</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(js|jsx|ts|tsx)$/</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="attr">use</span>: &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>, <span class="string">&#x27;@babel/preset-react&#x27;</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 处理 CSS 文件</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>] <span class="comment">// 从右到左执行</span></span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 处理 SCSS 文件</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        <span class="attr">use</span>: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 处理图片文件</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(png|jpe?g|gif|svg)$/</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&#x27;images/[hash][ext][query]&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 处理字体文件</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(woff|woff2|eot|ttf|otf)$/</span>,</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">        <span class="attr">generator</span>: &#123;</span><br><span class="line">          <span class="attr">filename</span>: <span class="string">&#x27;fonts/[hash][ext][query]&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="常⻅的Plugin"><a href="#常⻅的Plugin" class="headerlink" title="常⻅的Plugin"></a>常⻅的<strong>Plugin</strong></h3><ul>
<li>define-plugin：定义环境变量 </li>
<li>html-webpack-plugin：简化html⽂件创建 </li>
<li>uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码 </li>
<li>webpack-parallel-uglify-plugin: 多核压缩，提⾼压缩速度 </li>
<li>webpack-bundle-analyzer: 可视化webpack输出⽂件的体积 </li>
<li>mini-css-extract-plugin: CSS提取到单独的⽂件中，⽀持按需加载</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CleanWebpackPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MiniCssExtractPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;mini-css-extract-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">BundleAnalyzerPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>).<span class="property">BundleAnalyzerPlugin</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="comment">// 自动清理输出目录</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CleanWebpackPlugin</span>(),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动生成 HTML 文件并注入打包后的资源</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">HtmlWebpackPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;My App&#x27;</span>,</span><br><span class="line">      <span class="attr">template</span>: <span class="string">&#x27;./src/index.html&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 提取 CSS 到单独文件</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MiniCssExtractPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&#x27;css/[name].[contenthash:8].css&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打包分析工具</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">BundleAnalyzerPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">analyzerMode</span>: <span class="string">&#x27;disabled&#x27;</span>, <span class="comment">// 不自动打开</span></span><br><span class="line">      <span class="attr">generateStatsFile</span>: <span class="literal">true</span> <span class="comment">// 生成 stats.json 文件</span></span><br><span class="line">    &#125;),</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义环境变量</span></span><br><span class="line">    <span class="keyword">new</span> webpack.<span class="title class_">DefinePlugin</span>(&#123;</span><br><span class="line">      <span class="string">&#x27;process.env.NODE_ENV&#x27;</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(process.<span class="property">env</span>.<span class="property">NODE_ENV</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Tree-shaking-基本原理"><a href="#Tree-shaking-基本原理" class="headerlink" title="Tree shaking 基本原理"></a>Tree shaking 基本原理</h3><ol>
<li><strong>静态分析</strong>：<ul>
<li>在编译阶段（而非运行时）分析代码的导入导出关系</li>
<li>通过 ES6 模块的静态结构特性（<code>import/export</code> 必须在顶层作用域）实现</li>
</ul>
</li>
<li><strong>标记-清除</strong>过程：<ul>
<li><strong>标记阶段</strong>：从入口文件开始，标记所有被使用的导出</li>
<li><strong>清除阶段</strong>：删除所有未被标记的导出代码</li>
</ul>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;production&#x27;</span>, <span class="comment">// 生产模式自动开启 Tree Shaking</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">usedExports</span>: <span class="literal">true</span>, <span class="comment">// 标记未使用的导出</span></span><br><span class="line">    <span class="attr">minimize</span>: <span class="literal">true</span>,    <span class="comment">// 启用代码压缩</span></span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TerserPlugin</span>(), <span class="comment">// 使用 Terser 进行压缩</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">CssMinimizerPlugin</span>() <span class="comment">// 压缩 CSS</span></span><br><span class="line">    ],</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代码分割配置</span></span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">      <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">        <span class="attr">vendors</span>: &#123;</span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;vendors&#x27;</span>,</span><br><span class="line">          <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><blockquote>
<p>首先这就涉及到我们程序员编写代码的思路和方式了</p>
</blockquote>
<blockquote>
<p>我们都喜欢多模块，SASS&#x2F;LESS预编译器，前沿语法，前言API，命名友好，资源分组，有注释的方式</p>
</blockquote>
<blockquote>
<p>而浏览器喜欢的是少量文件，CSS，兼容语法，兼容API，单字节命名，资源集中，无注释的方式。</p>
</blockquote>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/c7qqzppjlk64c_4fa1deb056684296a4303053b7227c8b.png" alt="image"></p>
<blockquote>
<p>所以我们前端工程化的意义和作用就来了。使用webpack和vite来帮助我们把我们写的代码转换成浏览器能够读写的模式。让我们可以随意的编写我们喜欢的格式的代码</p>
</blockquote>
<h2 id="webpack的构建流程-1"><a href="#webpack的构建流程-1" class="headerlink" title="webpack的构建流程"></a>webpack的构建流程</h2><p><img src="https://ucc.alicdn.com/pic/developer-ecology/c7qqzppjlk64c_4cedd31a7a1444e0a62cfd5ae7ae2b94.png" alt="image"></p>
<ul>
<li><strong>初始化参数：</strong> 从配置文件和shell语句中读取合并参数，得出最终的配置参数。</li>
<li><strong>开始编译：</strong> 从上一步得到的参数初始化compiler对象，加载所有配置插件，执行对象的run方法开始编译</li>
<li><strong>确定入口：</strong> 通过entry找出入口文件</li>
<li><strong>编译模块：</strong> 从入口文件出发，调用所有配置的 <code>loader</code> 对模块进行翻译，再找出该模块依赖的模块，这个步骤是递归执行的，直至所有入口依赖的模块文件都经过本步骤的处理。</li>
<li><strong>完成模块编译：</strong> 经过第 4 步使用 loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系。</li>
<li><strong>输出资源：</strong> 根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 <code>chunk</code>，再把每个 <code>chunk</code> 转换成一个单独的文件加入到输出列表，这一步是可以修改输出内容的最后机会。</li>
<li><strong>输出完成：</strong> 在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li>
</ul>
<p><img src="https://ucc.alicdn.com/pic/developer-ecology/c7qqzppjlk64c_846b80577af74866b212694e710cb593.png" alt="image"></p>
<h2 id="vite的构建流程"><a href="#vite的构建流程" class="headerlink" title="vite的构建流程"></a>vite的构建流程</h2><p>Vite 的构建流程与传统的打包工具（如Webpack）有所不同，主要体现在开发阶段和生产环境阶段。以下是 Vite 的构建流程：</p>
<p><strong>开发阶段：</strong></p>
<ul>
<li><strong>启动开发服务器：</strong> 当你启动 Vite 时，它会启动一个开发服务器来为你提供服务。这个开发服务器利用现代浏览器对 ES 模块的本地支持，实现了快速的冷启动和热模块替换（HMR）。</li>
<li><strong>解析并提供文件：</strong> 当浏览器请求某个文件时，Vite 会解析这个文件，并根据需要进行转换。例如，对于 Vue 单文件组件（SFC），Vite 会将其实时编译成 JavaScript，然后返回给浏览器。</li>
<li><strong>处理依赖关系：</strong> 当浏览器中的代码引入其他模块时，Vite 会分析这些依赖关系，并通过浏览器原生的 ES 模块加载功能来动态地获取这些模块。</li>
</ul>
<p><strong>生产环境阶段：</strong></p>
<ul>
<li><strong>预构建：</strong> 在生产环境中，Vite 会预先构建你的应用程序，以便在部署时能够提供尽可能高效的代码。</li>
<li><strong>优化和压缩：</strong> Vite 会对代码进行优化和压缩，以提高应用程序的性能，并生成适合生产环境部署的静态资源。</li>
<li><strong>输出：</strong> 完成构建后，Vite 会将最终的生产代码输出到指定的目录，准备用于部署到生产环境。</li>
</ul>
<h2 id="webpack和vite的对比"><a href="#webpack和vite的对比" class="headerlink" title="webpack和vite的对比"></a>webpack和vite的对比</h2><h3 id="服务器启动区别"><a href="#服务器启动区别" class="headerlink" title="服务器启动区别"></a>服务器启动区别</h3><ul>
<li><strong>wepack:</strong> 当冷启动开发服务器时，基于打包器的方式是在提供服务前去急切地抓取和构建你的整个应用。</li>
</ul>
<blockquote>
<p>而 Vite 是通过在一开始将应用中的模块区分为 <strong>依赖</strong> 和 <strong>源码</strong> 两类，改进了开发服务器启动时间。</p>
</blockquote>
<blockquote>
<p><strong>依赖</strong> 大多为纯 JavaScript 并在开发时不会变动。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会以某些方式（例如 ESM 或者 CommonJS）被拆分到大量小模块中。</p>
</blockquote>
<blockquote>
<p>Vite 将会使用 esbuild 预构建依赖。<strong>Esbuild 使用 Go 编写</strong>，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。</p>
</blockquote>
<blockquote>
<p>源码 通常包含一些并非直接是 <strong>JavaScript</strong> 的文件，需要转换（例如 JSX，CSS 或者 Vue&#x2F;Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载。（例如基于路由拆分的代码模块）。</p>
</blockquote>
<blockquote>
<p>Vite 以 原生 <strong>ESM</strong> 方式服务源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并<strong>按需提供源码</strong>。根据情景动态导入的代码，即只在当前屏幕上实际使用时才会被处理。</p>
</blockquote>
<h3 id="热更新的区别"><a href="#热更新的区别" class="headerlink" title="热更新的区别"></a>热更新的区别</h3><blockquote>
<p>webpack</p>
</blockquote>
<p><strong>全局刷新：</strong> Webpack 的 HMR 通常会在代码发生变化时替换整个模块，然后通过 HMR runtime 来触发页面级别的刷新或重新渲染，这可能导致部分页面状态的丢失。</p>
<p><strong>较慢的冷启动：</strong> Webpack 的开发模式下，由于整个应用程序需要被打包和构建，因此冷启动时间相对较长，尤其是随着项目规模的增大，冷启动时间会进一步延长。</p>
<p><strong>配置复杂：</strong> 在使用 Webpack 进行 HMR 时，需要进行一定的配置，包括设置 HMR 插件、编写 HMR 相关的代码等，相对来说略显复杂。</p>
<blockquote>
<p><strong>vite</strong></p>
</blockquote>
<ul>
<li><p><strong>局部更新：</strong> Vite 的 HMR 实现了更细粒度的模块更新，可以实现局部模块的更新而无需刷新整个页面，从而减少页面状态的丢失。</p>
</li>
<li><p><strong>快速冷启动：</strong> Vite 利用现代浏览器的原生 ES 模块加载能力，实现了快速的冷启动时间，因为它不需要将整个应用程序打包成一个或多个文件。</p>
</li>
<li><p><strong>无需额外配置：</strong> 在 Vite 中，HMR 是开箱即用的，无需额外配置。Vite 会自动处理模块的更新和热替换，让开发者专注于业务逻辑的开发。</p>
</li>
</ul>
<h3 id="底层代码实现的区别？"><a href="#底层代码实现的区别？" class="headerlink" title="底层代码实现的区别？"></a>底层代码实现的区别？</h3><blockquote>
<p>webpack是用的node.js来实现的，node.js支持的生态库更多，前后端的一致性比较高，对于异步编程有着很好的支持，node.js的跨平台性比较好，在window，Mac,和linux等不同操作系统上都可以运行</p>
</blockquote>
<blockquote>
<p>vite是使用的 esbuild，esbuild 是用 Go 语言编写的，专注于快速的构建和打包，它的底层实现经过了高度优化，能够充分利用多核处理器和其他硬件资源，以及高效的算法和数据结构，从而实现了极快的构建速度。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>webpack服务器启动速度比vite慢：由于vite启动的时候不需要打包，也就<strong>无需分析模块依赖、编译</strong>，所以启动速度<strong>非常快</strong>。当浏览器请求需要的模块时，再对模块进行编译，这种按需动态编译的模式，极大缩短了编译时间，当项目越大，文件越多时，vite的开发时优势越明显</p>
</blockquote>
<blockquote>
<p>vite热更新比webpack快:vite在<strong>HRM</strong>方面，当某个模块内容改变时，让浏览器去<strong>重新请求该模块</strong>即可，而不是像webpack重新将该模块的所有依赖<strong>重新编译</strong>；</p>
</blockquote>
<blockquote>
<p>vite使用<strong>esbuild(Go 编写)</strong> 预构建依赖，而webpack基于<strong>nodejs</strong>, esbuild比node快 10-100 倍</p>
</blockquote>
<blockquote>
<p>vite生态不及webpack，加载器、插件不够丰富</p>
</blockquote>
<h2 id="vite的缺点是什么？"><a href="#vite的缺点是什么？" class="headerlink" title="vite的缺点是什么？"></a>vite的缺点是什么？</h2><ul>
<li><strong>生态，生态，生态不如webpack</strong></li>
</ul>
<blockquote>
<p>wepback厉害之处在于loader和plugin非常丰富,不过我认为生态只是时间问题，现在的vite,更像是当时刚出来的M1芯片Mac，作者当时非常喜欢M1的Mac，毫不犹豫买了，现在也没什么问题，相信vite后续更新会更好</p>
</blockquote>
<ul>
<li><strong>prod环境的构建，目前用的Rollup</strong></li>
</ul>
<blockquote>
<p>原因在于esbuild对于css和代码分割不是很友好</p>
</blockquote>
<ul>
<li><strong>还没有被大规模使用,很多问题或者诉求没有真正暴露出来</strong></li>
</ul>
<blockquote>
<p>vite真正崛起那一天，是跟vue3有关系的,当vue3广泛开始使用在生产环境的时候，vite也就大概率意味着被大家慢慢开始接受了</p>
</blockquote>
<h2 id="vite一定比webpack快吗"><a href="#vite一定比webpack快吗" class="headerlink" title="vite一定比webpack快吗?"></a>vite一定比webpack快吗?</h2><blockquote>
<p>不能说vite一定比webpack快，相对于不同的场景，webpack和vite有不同的速度优势吧。</p>
</blockquote>
<blockquote>
<p>vite相对于webpack在开发环境下有着更快的启动速度，因为vite底层是用的esbuild,这种设计使得 Vite 能够以非常低的延迟启动开发服务器，并且在修改文件时能够实现近乎即时的重新加载。</p>
</blockquote>
<blockquote>
<p>然而，在生产环境中，Vite 和 Webpack 的性能差异可能会变得不那么明显。Webpack 通过使用高度优化的构建算法和各种插件来提供出色的打包性能，尤其适用于复杂的项目和大规模的应用程序。</p>
</blockquote>
<blockquote>
<p>因此，是否可以说 Vite 一定比 Webpack 快，取决于具体的使用场景和项目需求。对于简单的小型项目，特别是新项目，Vite 通常会具有更快的启动和开发速度。而对于复杂的项目或需要更多自定义配置和功能的情况，Webpack 可能会更适合，因为它提供了更多的灵活性和扩展性。</p>
</blockquote>
<h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><h1 id="Babel的原理"><a href="#Babel的原理" class="headerlink" title="Babel的原理"></a><strong>Babel</strong>的原理</h1><p>babel 的转译过程也分为三个阶段，这三步具体是： </p>
<ul>
<li><strong>解析 Parse</strong>: 将代码解析⽣成抽象语法树（AST），即词法分析与语法分析的过程；</li>
<li><strong>转换 Transform</strong>: 对于 AST 进⾏变换⼀系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进⾏遍历，在此过程中进⾏添加、更新及移除等操作；</li>
<li><strong>⽣成 Generate</strong>: 将变换后的 AST 再转换为 JS 代码, 使⽤到的模块是 babel-generator。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/29/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" data-id="cmchjc7x2000194ur94qkgnxq" data-title="前端工程化" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E3%80%81%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/" rel="tag">前端工程、包管理器</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-前端性能" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/" class="article-date">
  <time class="dt-published" datetime="2025-06-29T06:44:38.000Z" itemprop="datePublished">2025-06-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/">前端性能[C</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h1><p>前端监控的目的是：</p>
<p>*<strong>获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，指明产品优化的方向*</strong>。</p>
<p>前端监控可以分为三类：数据监控、性能监控和异常监控。下面我们来一一的了解。</p>
<h4 id="1-数据监控"><a href="#1-数据监控" class="headerlink" title="(1)数据监控"></a>(1)数据监控</h4><p>数据监控，顾名思义就是监听用户的行为。常见的数据监控包括：</p>
<ul>
<li>PV&#x2F;UV:PV(page view)，即页面浏览量或点击量。UV:指访问某个站点或点击某条新闻的不同IP地址的人数</li>
<li>用户在每一个页面的停留时间</li>
<li>用户通过什么入口来访问该网页</li>
<li>用户在相应的页面中触发的行为</li>
</ul>
<p>统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。</p>
<h4 id="2-性能监控"><a href="#2-性能监控" class="headerlink" title="(2)性能监控"></a>(2)性能监控</h4><p>性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控数据包括：</p>
<ul>
<li>不同用户，不同机型和不同系统下的首屏加载时间</li>
<li>白屏时间</li>
<li>http等请求的响应时间</li>
<li>静态资源整体下载时间</li>
<li>页面渲染时间</li>
<li>页面交互动画完成时间</li>
</ul>
<p>这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，比如兼容低版本浏览器的动画效果，加快首屏加载等等。</p>
<h4 id="3-异常监控"><a href="#3-异常监控" class="headerlink" title="(3)异常监控"></a>(3)异常监控</h4><p>此外，产品的前端代码在执行过程中也会发生异常，因此需要引入异常监控。及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过try catch的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：</p>
<ul>
<li>Javascript的异常监控</li>
<li>样式丢失的异常监控</li>
</ul>
<h1 id="前端安全补充"><a href="#前端安全补充" class="headerlink" title="前端安全补充"></a>前端安全补充</h1><h2 id="DoS-Denial-of-Service-Attack-拒绝服务攻击"><a href="#DoS-Denial-of-Service-Attack-拒绝服务攻击" class="headerlink" title="DoS (Denial-of-Service Attack - 拒绝服务攻击)"></a>DoS (Denial-of-Service Attack - 拒绝服务攻击)</h2><ul>
<li><strong>核心目标：</strong> 使目标系统（服务器、网络、服务、应用程序等）<strong>无法为合法用户提供正常的服务</strong>。通常是通过耗尽目标的关键资源（如带宽、CPU、内存、连接数、磁盘I&#x2F;O等）来实现。</li>
<li><strong>基本原理：</strong><ul>
<li><strong>单源攻击：</strong> 攻击流量<strong>主要来源于一个攻击者或一台被攻击者控制的机器</strong>。</li>
<li><strong>资源耗尽：</strong> 攻击者利用协议漏洞、设计缺陷或单纯发送海量垃圾请求，试图压垮目标的某项或多项资源：<ul>
<li><strong>带宽耗尽：</strong> 发送巨大的数据流（如UDP洪水、ICMP洪水&#x2F;Ping of Death）堵塞目标的网络管道。</li>
<li><strong>连接耗尽：</strong> 建立大量半开连接（如SYN洪水攻击），耗尽服务器的TCP连接池，阻止新的合法连接。</li>
<li><strong>CPU&#x2F;内存耗尽：</strong> 发送需要大量计算资源才能处理的请求（如复杂的数据库查询、加密解密操作、特定格式的畸形数据包），导致服务器忙于处理攻击请求而无法响应正常请求。</li>
<li><strong>应用层攻击：</strong> 针对特定的应用协议（如HTTP、DNS、SMTP），发送看似合法但精心构造的请求（如Slowloris攻击、HTTP洪水攻击、CC攻击），消耗应用服务器资源（线程、会话）或后端资源（数据库连接）。</li>
</ul>
</li>
<li><strong>协议利用：</strong> 利用某些网络协议本身的设计弱点（如TCP的三次握手在SYN洪水中的脆弱性、UDP的无连接性在反射放大攻击中的作用）。</li>
</ul>
</li>
</ul>
<h2 id="DDoS-Distributed-Denial-of-Service-Attack-分布式拒绝服务攻击"><a href="#DDoS-Distributed-Denial-of-Service-Attack-分布式拒绝服务攻击" class="headerlink" title="DDoS (Distributed Denial-of-Service Attack - 分布式拒绝服务攻击)"></a>DDoS (Distributed Denial-of-Service Attack - 分布式拒绝服务攻击)</h2><ul>
<li><strong>核心目标：</strong> 与DoS相同，也是使目标系统瘫痪，无法提供正常服务。</li>
<li><strong>基本原理：</strong> <strong>DoS攻击的进化版和加强版</strong>。<ul>
<li><strong>多源攻击：</strong> 攻击流量<strong>来源于大量（成千上万甚至数百万）分布在全球不同地理位置的、被攻击者控制的设备</strong>。这些设备组成了一个 <strong>“僵尸网络”</strong> 。</li>
<li><strong>僵尸网络：</strong> 攻击者通过恶意软件（病毒、蠕虫、特洛伊木马）感染和控制了大量普通用户的计算机、服务器、IoT设备（摄像头、路由器、智能家居）等。这些被控制的设备称为 <strong>“僵尸”</strong> 或 <strong>“肉鸡”</strong> 。</li>
<li><strong>集中指挥：</strong> 攻击者通过一个或多个 <strong>“命令与控制服务器”</strong> 向僵尸网络中的设备发送攻击指令。</li>
<li><strong>放大效应：</strong><ul>
<li><strong>数量放大：</strong> 成千上万的僵尸同时发起攻击，流量规模远超单源DoS。</li>
<li><strong>反射放大：</strong> 利用一些协议（如DNS、NTP、SSDP、Memcached）的响应包远大于请求包的特性，<strong>伪造受害者的IP地址</strong> 向这些服务的开放服务器发送大量小请求，导致这些服务器将巨大的响应流量反射回受害者，从而<strong>放大攻击流量</strong>（可能放大几十倍甚至数万倍）。这是DDoS中极具破坏力的一种形式。</li>
</ul>
</li>
<li><strong>隐蔽性与防御难度：</strong><ul>
<li>流量来源分散且通常是合法的被劫持设备，难以直接定位真正的攻击者。</li>
<li>海量流量来自不同IP，传统的基于IP黑名单的过滤方法效果有限。</li>
<li>攻击流量可能模仿正常流量，增加了区分难度。</li>
<li>攻击规模可以轻易达到数百Gbps甚至数Tbps，远超单个网络的承受能力。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结攻击原理的核心差异"><a href="#总结攻击原理的核心差异" class="headerlink" title="总结攻击原理的核心差异"></a>总结攻击原理的核心差异</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">DoS (拒绝服务)</th>
<th align="left">DDoS (分布式拒绝服务)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>攻击源</strong></td>
<td align="left"><strong>单一</strong> 或 <strong>少量</strong> 源头</td>
<td align="left"><strong>海量分布式</strong> 源头 (僵尸网络)</td>
</tr>
<tr>
<td align="left"><strong>流量规模</strong></td>
<td align="left">相对较小，通常能被单点防御阻挡</td>
<td align="left"><strong>极其巨大</strong> (Gbps&#x2F;Tbps 级别)，难以单点防御</td>
</tr>
<tr>
<td align="left"><strong>复杂性</strong></td>
<td align="left">较低，技术门槛不高</td>
<td align="left"><strong>高</strong>，需要构建&#x2F;租用僵尸网络，组织复杂</td>
</tr>
<tr>
<td align="left"><strong>隐蔽性</strong></td>
<td align="left">较低，源头易被追踪和屏蔽</td>
<td align="left"><strong>高</strong>，源头分散且多为被劫持设备</td>
</tr>
<tr>
<td align="left"><strong>防御难度</strong></td>
<td align="left"><strong>较低</strong></td>
<td align="left"><strong>极高</strong></td>
</tr>
<tr>
<td align="left"><strong>攻击威力</strong></td>
<td align="left"><strong>有限</strong></td>
<td align="left"><strong>毁灭性</strong></td>
</tr>
</tbody></table>
<h2 id="D-DOS-防范措施"><a href="#D-DOS-防范措施" class="headerlink" title="D&#x2F;DOS 防范措施"></a>D&#x2F;DOS 防范措施</h2><p>防范D&#x2F;DoS攻击是一个<strong>多层次、持续性的综合工程</strong>，没有银弹。主要策略包括：</p>
<h3 id="1-基础设施层防护"><a href="#1-基础设施层防护" class="headerlink" title="1. 基础设施层防护"></a>1. 基础设施层防护</h3><ul>
<li><strong>增加带宽冗余：</strong> 虽然无法完全抵御大型DDoS，但更大的带宽能争取更多响应时间，对小规模攻击有效。这是基础。</li>
<li><strong>部署内容分发网络：</strong> CDN将网站内容缓存到全球分布的边缘节点。用户访问边缘节点，大大减少直接攻击源站的机会。CDN提供商通常自身具备强大的DDoS缓解能力，能吸收和过滤大量攻击流量。</li>
<li><strong>使用云防护&#x2F;清洗服务：</strong> <strong>(最有效且主流的方式)</strong><ul>
<li><strong>流量清洗中心：</strong> 所有流量先经过服务提供商的清洗中心。在这里，利用大数据分析、行为分析、机器学习等技术<strong>实时区分恶意流量和合法流量</strong>，只将清洗后的干净流量转发给目标服务器。阿里云DDoS防护、腾讯云大禹、AWS Shield Advanced、Cloudflare、Akamai Prolexic 等都是这类服务。</li>
<li><strong>Anycast 网络：</strong> 云防护提供商通常使用Anycast技术，将攻击流量分散到全球多个数据中心入口点进行处理，稀释攻击威力。</li>
</ul>
</li>
<li><strong>分布式架构：</strong> 设计系统时避免单点故障，采用负载均衡将流量分散到多个服务器或数据中心。</li>
</ul>
<h3 id="2-网络与系统层加固"><a href="#2-网络与系统层加固" class="headerlink" title="2. 网络与系统层加固"></a>2. 网络与系统层加固</h3><ul>
<li><strong>防火墙配置：</strong><ul>
<li>严格配置入站&#x2F;出站规则。</li>
<li>启用抗DDoS模式（如SYN Cookie&#x2F;Cookie Challenge）。</li>
<li>限制特定协议（如ICMP、UDP）的速率或直接屏蔽。</li>
<li>设置连接数限制和新建连接速率限制。</li>
</ul>
</li>
<li><strong>路由器&#x2F;交换机配置：</strong><ul>
<li>启用访问控制列表限制来源。</li>
<li>配置流量限速。</li>
<li>启用源IP验证，防止IP欺骗。</li>
</ul>
</li>
<li><strong>服务器优化：</strong><ul>
<li><strong>及时打补丁：</strong> 修复操作系统、Web服务器、数据库等软件漏洞，防止攻击者利用漏洞发动DoS。</li>
<li><strong>资源限制：</strong> 调整内核参数（如<code>net.core.somaxconn</code>, <code>net.ipv4.tcp_max_syn_backlog</code>），优化TCP&#x2F;IP栈性能，增加半连接队列大小。</li>
<li><strong>关闭不必要的服务：</strong> 减少攻击面。</li>
<li><strong>启用SYN Cookies：</strong> 有效防御SYN洪水攻击。</li>
</ul>
</li>
<li><strong>入侵检测&#x2F;防御系统：</strong> 部署NIDS&#x2F;NIPS，配置规则检测常见DoS攻击模式（如SYN Flood, UDP Flood）并自动阻断。</li>
</ul>
<h3 id="3-应用层防护"><a href="#3-应用层防护" class="headerlink" title="3. 应用层防护"></a>3. 应用层防护</h3><ul>
<li><strong>Web应用防火墙：</strong> WAF能有效防御应用层DDoS攻击（如HTTP Flood、Slowloris、CC攻击）以及利用应用漏洞的攻击。它可以识别恶意Bot流量、设置请求速率限制、验证挑战等。</li>
<li><strong>输入验证与过滤：</strong> 严格检查所有用户输入，防止畸形数据包导致服务崩溃或资源耗尽。</li>
<li><strong>会话管理：</strong> 合理设置会话超时时间，防止僵尸会话占用资源。</li>
<li><strong>资源使用限制：</strong> 对API调用、文件上传、数据库查询等操作实施严格的频率和资源消耗限制。</li>
<li><strong>验证码：</strong> 在可疑流量或高频率操作时引入验证码，区分人机。</li>
<li><strong>限制特定User-Agent或爬虫行为。</strong></li>
</ul>
<h3 id="4-监控与响应"><a href="#4-监控与响应" class="headerlink" title="4. 监控与响应"></a>4. 监控与响应</h3><ul>
<li><strong>实时监控：</strong> 部署全面的网络流量监控系统，密切关注带宽使用率、连接数、CPU&#x2F;内存负载、特定协议流量等关键指标。设置告警阈值。</li>
<li><strong>流量分析工具：</strong> 使用NetFlow&#x2F;sFlow&#x2F;IPFIX、深度包检测等技术分析流量模式，识别异常。</li>
<li><strong>制定应急预案：</strong> 明确在遭受攻击时各个团队（网络、安全、运维、应用开发）的职责和操作流程。包括：<ul>
<li>如何快速确认攻击类型和规模。</li>
<li>如何启动云清洗服务或联系ISP协助。</li>
<li>如何调整防火墙&#x2F;WAF规则进行临时封堵（谨慎使用）。</li>
<li>如何与业务部门沟通。</li>
<li>攻击缓解后的恢复步骤和根因分析。</li>
</ul>
</li>
<li><strong>定期演练：</strong> 测试应急预案的有效性。</li>
</ul>
<h3 id="5-其他重要措施"><a href="#5-其他重要措施" class="headerlink" title="5. 其他重要措施"></a>5. 其他重要措施</h3><ul>
<li><strong>隐藏真实IP：</strong> 尽可能不要让关键服务的真实服务器IP直接暴露在公网上。使用CDN、云WAF、反向代理或高防IP作为前端。</li>
<li><strong>ISP合作：</strong> 与你的互联网服务提供商建立联系。大型ISP通常具备在更上游（靠近攻击源）缓解大规模DDoS的能力。在攻击发生时，及时向其报告并寻求协助。</li>
<li><strong>减少反射放大面：</strong> 确保你管理的服务器（如DNS递归解析器、NTP服务器、Memcached服务器）不会被滥用为反射源。正确配置它们（如限制递归查询来源、禁用不必要功能、更新软件）。</li>
<li><strong>安全意识：</strong> 防止内部设备成为僵尸网络成员（安装杀毒软件、及时更新、强密码）。</li>
</ul>
<h2 id="三、-重要总结"><a href="#三、-重要总结" class="headerlink" title="三、 重要总结"></a>三、 重要总结</h2><ol>
<li><strong>DDoS是更强大、更主流的威胁：</strong> 如今单纯的DoS攻击已较少见，DDoS利用僵尸网络的规模和反射放大技术成为常态。</li>
<li><strong>云防护是核心：</strong> 面对大型DDoS攻击，依靠自身网络和设备几乎无法抵御。专业的云DDoS防护&#x2F;清洗服务是<strong>最有效和最主流</strong>的解决方案。</li>
<li><strong>纵深防御：</strong> 没有单一完美的防御手段。需要结合<strong>基础设施冗余、网络设备加固、服务器优化、应用层防护、持续监控和成熟的应急响应计划</strong>，构建多层次防御体系。</li>
<li><strong>持续性与成本：</strong> DDoS防御是一个持续投入的过程，包括技术、人力和服务成本。需要根据业务的重要性来评估所需的防护等级。</li>
<li><strong>Mirai僵尸网络的警示：</strong> Mirai及其变种利用大量安全性薄弱的IoT设备发动了史上最大规模的DDoS攻击之一，凸显了IoT安全问题和反射放大攻击的威力。</li>
</ol>
<h1 id="Js错误"><a href="#Js错误" class="headerlink" title="Js错误"></a>Js错误</h1><h2 id="JavaScript-错误类型总览"><a href="#JavaScript-错误类型总览" class="headerlink" title="JavaScript 错误类型总览"></a>JavaScript 错误类型总览</h2><table>
<thead>
<tr>
<th align="left">错误类型</th>
<th align="left">触发场景</th>
<th align="left">示例代码</th>
<th align="left">解决方案</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>SyntaxError</strong></td>
<td align="left">语法错误</td>
<td align="left"><code>if (a) &#123;</code></td>
<td align="left">修复代码语法</td>
</tr>
<tr>
<td align="left"><strong>ReferenceError</strong></td>
<td align="left">访问未声明变量</td>
<td align="left"><code>console.log(undeclaredVar);</code></td>
<td align="left">声明变量或检查变量作用域</td>
</tr>
<tr>
<td align="left"><strong>TypeError</strong></td>
<td align="left">类型不匹配操作</td>
<td align="left"><code>null.func();</code></td>
<td align="left">添加类型检查</td>
</tr>
<tr>
<td align="left"><strong>RangeError</strong></td>
<td align="left">数值超出有效范围</td>
<td align="left"><code>new Array(-1);</code></td>
<td align="left">验证输入值范围</td>
</tr>
<tr>
<td align="left"><strong>URIError</strong></td>
<td align="left">URI处理函数使用无效参数</td>
<td align="left"><code>decodeURIComponent(&#39;%&#39;);</code></td>
<td align="left">验证URI参数</td>
</tr>
<tr>
<td align="left"><strong>EvalError</strong></td>
<td align="left"><code>eval()</code> 函数使用不当</td>
<td align="left"><code>new eval();</code></td>
<td align="left">避免使用eval</td>
</tr>
<tr>
<td align="left"><strong>AggregateError</strong></td>
<td align="left">多个错误组合</td>
<td align="left"><code>Promise.any([rejectedPromises]);</code></td>
<td align="left">处理多个错误</td>
</tr>
<tr>
<td align="left"><strong>自定义错误</strong></td>
<td align="left">开发者主动抛出</td>
<td align="left"><code>throw new CustomError(&#39;msg&#39;);</code></td>
<td align="left">实现特定错误处理逻辑</td>
</tr>
</tbody></table>
<h3 id="1-SyntaxError（语法错误）"><a href="#1-SyntaxError（语法错误）" class="headerlink" title="1. SyntaxError（语法错误）"></a>1. SyntaxError（语法错误）</h3><p><strong>触发时机</strong>：代码解析阶段<br><strong>常见场景</strong>：</p>
<ul>
<li>缺少括号、引号或花括号</li>
<li>错误使用保留字</li>
<li>无效的表达式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1: 缺少括号</span></span><br><span class="line"><span class="keyword">if</span> (a &#123;  <span class="comment">// Uncaught SyntaxError: Unexpected token &#x27;&#123;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: 无效赋值</span></span><br><span class="line"><span class="keyword">const</span> 123<span class="keyword">var</span> = <span class="string">&quot;test&quot;</span>;  <span class="comment">// Uncaught SyntaxError: Invalid or unexpected token</span></span><br></pre></td></tr></table></figure>

<h3 id="2-ReferenceError（引用错误）"><a href="#2-ReferenceError（引用错误）" class="headerlink" title="2. ReferenceError（引用错误）"></a>2. ReferenceError（引用错误）</h3><p><strong>触发时机</strong>：运行时<br><strong>常见场景</strong>：</p>
<ul>
<li>访问未声明的变量</li>
<li>访问块作用域变量（let&#x2F;const）的TDZ（暂时性死区）</li>
<li>模块导入错误</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1: 未声明变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(undeclaredVar);  <span class="comment">// Uncaught ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: TDZ访问</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);  <span class="comment">// Uncaught ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-TypeError（类型错误）"><a href="#3-TypeError（类型错误）" class="headerlink" title="3. TypeError（类型错误）"></a>3. TypeError（类型错误）</h3><p><strong>触发时机</strong>：操作不符合变量类型<br><strong>常见场景</strong>：</p>
<ul>
<li>调用非函数值</li>
<li>访问null&#x2F;undefined的属性</li>
<li>尝试修改常量值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1: 调用非函数</span></span><br><span class="line"><span class="keyword">const</span> num = <span class="number">42</span>;</span><br><span class="line"><span class="title function_">num</span>();  <span class="comment">// Uncaught TypeError: num is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: 访问null属性</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">property</span>);  <span class="comment">// Uncaught TypeError: Cannot read property</span></span><br></pre></td></tr></table></figure>

<h3 id="4-RangeError（范围错误）"><a href="#4-RangeError（范围错误）" class="headerlink" title="4. RangeError（范围错误）"></a>4. RangeError（范围错误）</h3><p><strong>触发时机</strong>：参数超出有效范围<br><strong>常见场景</strong>：</p>
<ul>
<li>无效数组长度</li>
<li>数字方法参数越界</li>
<li>递归深度过大</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1: 无效数组长度</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Array</span>(-<span class="number">1</span>);  <span class="comment">// Uncaught RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2: 数字精度超限</span></span><br><span class="line">(<span class="number">123.456</span>).<span class="title function_">toFixed</span>(<span class="number">101</span>);  <span class="comment">// Uncaught RangeError: toFixed() digits argument must be between 0 and 100</span></span><br></pre></td></tr></table></figure>

<h3 id="5-URIError（URI错误）"><a href="#5-URIError（URI错误）" class="headerlink" title="5. URIError（URI错误）"></a>5. URIError（URI错误）</h3><p><strong>触发时机</strong>：URI处理函数参数无效<br><strong>仅影响</strong>：<code>encodeURI()</code>, <code>decodeURI()</code>, <code>encodeURIComponent()</code>, <code>decodeURIComponent()</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例: 无效URI解码</span></span><br><span class="line"><span class="built_in">decodeURIComponent</span>(<span class="string">&#x27;%&#x27;</span>);  <span class="comment">// Uncaught URIError: URI malformed</span></span><br></pre></td></tr></table></figure>

<h3 id="6-EvalError（eval错误）"><a href="#6-EvalError（eval错误）" class="headerlink" title="6. EvalError（eval错误）"></a>6. EvalError（eval错误）</h3><p><strong>触发时机</strong>：<code>eval()</code> 函数使用不当<br><strong>注意</strong>：现代JavaScript中很少见，保留用于兼容性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 历史用法 (现代JS引擎不再抛出)</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EvalError</span>(<span class="string">&quot;Eval error&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e <span class="keyword">instanceof</span> <span class="title class_">EvalError</span>);  <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-AggregateError（聚合错误）"><a href="#7-AggregateError（聚合错误）" class="headerlink" title="7. AggregateError（聚合错误）"></a>7. AggregateError（聚合错误）</h3><p><strong>触发时机</strong>：多个错误需要同时报告<br><strong>常见于</strong>：<code>Promise.any()</code> 全部拒绝时</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">any</span>([</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Error 1&quot;</span>)),</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Error 2&quot;</span>))</span><br><span class="line">]).<span class="title function_">catch</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e <span class="keyword">instanceof</span> <span class="title class_">AggregateError</span>);  <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">errors</span>.<span class="property">length</span>);  <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="WebIDL和ecma-262中的错误类型"><a href="#WebIDL和ecma-262中的错误类型" class="headerlink" title="WebIDL和ecma-262中的错误类型"></a>WebIDL和ecma-262中的错误类型</h4><ul>
<li><p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=WCsyJ0SbM68nFUfknuxc4g==.suEaakDxsFgunJR89KoRM2icTf23NuhbkJlXUUrVWbBpYg3tSQ3Qcro+8NlH58ZUTRaKRVPug72ITCAseJfwzPkhe/P6CqFiA14nNIjGM7E=">ECMAScript exceptions</a> &lt;&#x3D;&#x3D;&gt; <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=PKwXx59Icv2HdaKCGITj+w==.ZkwDXSwbBVZSMF94vbPpyK+w3iC2bcBf19ml+tcJNstSYLackci+BgNMsdSmvchdLjCH5bbjMMICt01dZB8DuA==">IDL 的简单异常</a></p>
<p>当脚本代码运行时发生的错误，会创建Error对象，并将其抛出，除了通用的Error构造函数外，以下是另外几个ECMAScript 2015中定义的错误构造函数。</p>
<ul>
<li><strong>EvalError</strong> eval错误</li>
<li><strong>RangeError</strong> 范围错误</li>
<li><strong>ReferenceError</strong> 引用错误</li>
<li><strong>TypeError</strong> 类型错误</li>
<li><strong>URIError</strong> URI错误</li>
<li><strong>SyntaxError</strong> 语法错误 (这个错误WebIDL中故意省略，保留给ES解析器使用)</li>
<li><strong>Error</strong> 通用错误 （这个错误WebIDL中故意省略，保留给开发者使用使用）</li>
</ul>
</li>
<li><p><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=Qaux4NrI17y7bOplFMyitw==.cL487ezp3TEsLOuy+TKH9OHDliMsEWajxxayEUwyqYIqv9RbXRCkouXogfTnmFZbGfw3Oo476yuXgMBVsvAeEQ==">DOMException</a> 最新的DOM规范定义的错误类型集，兼容旧浏览的DOMError接口, 完善和规范化DOM错误类型。</p>
<ul>
<li><strong>IndexSizeError</strong> 索引不在允许的范围内</li>
<li><strong>HierarchyRequestError</strong> 节点树层次结构是不正确的。</li>
<li><strong>WrongDocumentError</strong> 对象是错误的</li>
<li><strong>InvalidCharacterError</strong> 字符串包含无效字符。</li>
<li><strong>NoModificationAllowedError</strong> 对象不能被修改。</li>
<li><strong>NotFoundError</strong> 对象不能在这里被找到。</li>
<li><strong>NotSupportedError</strong> 不支持的操作</li>
<li><strong>InvalidStateError</strong> 对象是一个无效的状态。</li>
<li><strong>SyntaxError</strong> 字符串不匹配预期的模式</li>
<li><strong>InvalidModificationError</strong> 对象不能以这种方式被修改</li>
<li><strong>NamespaceError</strong> 操作在XML命名空间内是不被允许的</li>
<li><strong>InvalidAccessError</strong> 对象不支持这种操作或参数。</li>
<li><strong>TypeMismatchError</strong> 对象的类型不匹配预期的类型。</li>
<li><strong>SecurityError</strong> 此操作是不安全的。</li>
<li><strong>NetworkError</strong> 发生网络错误</li>
<li><strong>AbortError</strong> 操作被中止</li>
<li><strong>URLMismatchError</strong> 给定的URL不匹配另一个URL。</li>
<li><strong>QuotaExceededError</strong> 已经超过给定配额。</li>
<li><strong>TimeoutError</strong> 操作超时。</li>
<li><strong>InvalidNodeTypeError</strong> 这个操作的 节点或节点祖先 是不正确的</li>
<li><strong>DataCloneError</strong> 对象不能克隆。</li>
</ul>
</li>
</ul>
<h3 id="前端错误异常按照捕获方式分类"><a href="#前端错误异常按照捕获方式分类" class="headerlink" title="前端错误异常按照捕获方式分类"></a>前端错误异常按照捕获方式分类</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 语法错误</li>
<li><input checked="" disabled="" type="checkbox"> 运行时异常</li>
<li><input checked="" disabled="" type="checkbox"> 资源加载异常<ul>
<li>img</li>
<li>script</li>
<li>link</li>
<li>audio</li>
<li>video</li>
<li>iframe</li>
<li>…外链资源的DOM元素</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> 异步请求异常<ul>
<li>XMLHttpRequest</li>
<li>fetch</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> Promise异常</li>
<li><input disabled="" type="checkbox"> <del>CSS中资源异常</del><ul>
<li>@font-face</li>
<li>background-image</li>
<li>…暂时无法捕获</li>
</ul>
</li>
</ul>
<h3 id="前端错误异常的捕获方式"><a href="#前端错误异常的捕获方式" class="headerlink" title="前端错误异常的捕获方式"></a>前端错误异常的捕获方式</h3><ul>
<li>try-catch (ES提供基本的错误捕获语法)<ul>
<li>只能捕获同步代码的异常</li>
<li><del>回调</del></li>
<li><del>setTimeout</del></li>
<li><del>promise</del></li>
</ul>
</li>
<li><strong>window.onerror &#x3D; cb (DOM0)</strong><ul>
<li>img</li>
<li>script</li>
<li>link</li>
</ul>
</li>
<li>window.addEventListener(‘error’, cb, true) (DOM2)</li>
<li>window.addEventListener(“unhandledrejection”, cb) (DOM4)</li>
<li>Promise.then().catch(cb)</li>
<li>封装XMLHttpRequest&amp;fetch | 覆写请求接口对象</li>
</ul>
<h4 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h4><p>将能引发异常的代码块放到try中，并对应一个响应，然后有异常会被捕获</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 模拟一段可能有错误的代码</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;会有错误的代码块&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">  <span class="comment">// 捕获到try中代码块的错误得到一个错误对象e，进行处理分析</span></span><br><span class="line">  <span class="title function_">report</span>(e)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;finally&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="onerror事件"><a href="#onerror事件" class="headerlink" title="onerror事件"></a>onerror事件</h4><h5 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h5><p>当JavaScript运行时错误（包括语法错误）发生时，window会触发一个ErrorEvent接口的事件，并执行window.onerror();</p>
<p>但这里有个信息要注意，语法错误会导致出现语法错误的那个脚本块执行失败，所以语法错误会导致当前代码块运行终止，从而导致整个程序运行中断，如果语法错误这个发生在我们的错误监控语句块中，那么我们就什么也监控不到了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 运行时错误处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; message 错误信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; source 发生错误的脚本URL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; lineno 发生错误的行号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; colno 发生错误的列号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">object</span>&#125; error Error对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">err</span>(<span class="params">message,source,lineno,colno,error</span>) &#123;...&#125;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = err</span><br></pre></td></tr></table></figure>

<h5 id="element-onerror"><a href="#element-onerror" class="headerlink" title="element.onerror"></a>element.onerror</h5><p>当一项资源（如<code>&lt;img&gt;</code>或<code>&lt;script&gt;</code>）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123; ... &#125; <span class="comment">//注意和window.onerror的参数不同</span></span><br></pre></td></tr></table></figure>

<p>注意：这些error事件不会向上冒泡到window，不过能被单一的window.addEventListener捕获。</p>
<h5 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h5><h5 id="addEventListener相关的一些内容"><a href="#addEventListener相关的一些内容" class="headerlink" title="addEventListener相关的一些内容"></a>addEventListener相关的一些内容</h5><p>W3C DOM2 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=t0fRx2nVaR1eu7VXBZ0Oyw==./f7iMYPHVLL1SJ7Tsr8UBsyS07dvVmnWFnPkFkJMUE383Svkr3So82kOIjNpQpQl">Events</a>规范中提供的注册事件监听器的方法, 在这之前均使用<br><code>el.onclick</code>的形式（DOM0 规范的基本内容，几乎所有浏览器都支持）。</p>
<p>注意： <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=jhXgag8h/rd9UmLYcpREUw==.gyww6nUd6BCIKiObOuusn+K7pdiHTFxvnJrdeLqnQ2YuJAup9f50b3dTfzUjfcWVmy/T+2pz16NB64TCAJStAbOv8JVXfXroRUjMA3B3dXo=">接口的几种语法</a></p>
<h5 id="error事件捕获资源加载错误"><a href="#error事件捕获资源加载错误" class="headerlink" title="error事件捕获资源加载错误"></a>error事件捕获资源加载错误</h5><p>资源加载失败，不会冒泡，但是会被addEventListener捕获，所以我们可以指定在加载失败事件的捕获阶段捕获该错误。</p>
<p>注意: 接口同时也能捕获运行时错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;error&quot;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> eventType = [].<span class="property">toString</span>.<span class="title function_">call</span>(e, e);</span><br><span class="line">    <span class="keyword">if</span> (eventType === <span class="string">&quot;[object Event]&quot;</span>) &#123; <span class="comment">// 过滤掉运行时错误</span></span><br><span class="line">      <span class="comment">// 上报加载错误</span></span><br><span class="line">      <span class="title function_">report</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="unhandledrejection事件捕获Promise异常"><a href="#unhandledrejection事件捕获Promise异常" class="headerlink" title="unhandledrejection事件捕获Promise异常"></a>unhandledrejection事件捕获Promise异常</h5><p>最新的规范中定义了 unhandledrejection事件用于全局捕获promise对象没有rejection处理器时异常情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="comment">// ...your code here to handle the unhandled rejection...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prevent the default handling (error in console)</span></span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Promise-then-catch-cb-finally"><a href="#Promise-then-catch-cb-finally" class="headerlink" title="Promise.then().catch(cb).finally()"></a>Promise.then().catch(cb).finally()</h4><p>Promise中的错误会被Promise.prototype.catch捕获，所以我们通过这种方式捕获错误，这包括一些不支持unhandledrejection事件的环境中promisede polyfill实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;Uncaught Exception!&#x27;</span>;</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e); <span class="comment">// Uncaught Exception!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="封装XMLHttpRequest-fetch-覆写请求接口对象"><a href="#封装XMLHttpRequest-fetch-覆写请求接口对象" class="headerlink" title="封装XMLHttpRequest&amp;fetch | 覆写请求接口对象"></a>封装XMLHttpRequest&amp;fetch | 覆写请求接口对象</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 覆写XMLHttpRequest API</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">var</span> xmlhttp = <span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>;</span><br><span class="line">  <span class="keyword">var</span> _oldSend = xmlhttp.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">send</span>;</span><br><span class="line">  <span class="keyword">var</span> _handleEvent = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (event &amp;&amp; event.<span class="property">currentTarget</span> &amp;&amp; event.<span class="property">currentTarget</span>.<span class="property">status</span> !== <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">report</span>(event)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xmlhttp.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">send</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>]) &#123;</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>](<span class="string">&#x27;error&#x27;</span>, _handleEvent);</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>](<span class="string">&#x27;load&#x27;</span>, _handleEvent);</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>](<span class="string">&#x27;abort&#x27;</span>, _handleEvent);</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;addEventListener&#x27;</span>](<span class="string">&#x27;close&#x27;</span>, _handleEvent);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> _oldStateChange = <span class="variable language_">this</span>[<span class="string">&#x27;onreadystatechange&#x27;</span>];</span><br><span class="line">          <span class="variable language_">this</span>[<span class="string">&#x27;onreadystatechange&#x27;</span>] = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">                  <span class="title function_">_handleEvent</span>(event);</span><br><span class="line">              &#125;</span><br><span class="line">              _oldStateChange &amp;&amp; _oldStateChange.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">          &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> _oldSend.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写fetch API</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="property">fetch</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">var</span> _oldFetch = <span class="variable language_">window</span>.<span class="property">fetch</span>;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">fetch</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _oldFetch</span><br><span class="line">    .<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params">res</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span> (!res.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="comment">// True if status is HTTP 2xx</span></span><br><span class="line">        <span class="title function_">report</span>(res)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">error</span>)&#123;</span><br><span class="line">      <span class="title function_">report</span>(res)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="日志上报的方式"><a href="#日志上报的方式" class="headerlink" title="日志上报的方式"></a>日志上报的方式</h3><ul>
<li>异步请求上报, 后端提供接口，或者直接发到日志服务器</li>
<li>img请求上报, url参数带上错误信息<ul>
<li><code>eg:(new Image()).src = &#39;http://baidu.com/tesjk?r=tksjk&#39;</code></li>
</ul>
</li>
</ul>
<h4 id="注意跨源脚本异常"><a href="#注意跨源脚本异常" class="headerlink" title="注意跨源脚本异常"></a>注意跨源脚本异常</h4><p>当加载自不同域的脚本中发生语法错误时，为避免信息泄露，语法错误的细节将不会报告，而代之简单的 “Script error.”</p>
<p>由于同源策略影响，浏览器限制跨源脚本的错误访问，这样跨源脚本错误报错信息如下图：</p>
<p><img src="https://segmentfault.com/img/bV7tjY?w=372&h=126" alt="跨源的脚本的异常"></p>
<p>在H5的规定中，只要满足下面俩个条件，是允许获取跨源脚本的错误信息的。</p>
<ol>
<li>客户端在script标签上增加crossorigin属性；</li>
<li>服务端设置js资源响应头Access-Control-Origin:*（或者是域名）。</li>
</ol>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><h4 id="业界已经有的监控平台"><a href="#业界已经有的监控平台" class="headerlink" title="业界已经有的监控平台"></a>业界已经有的监控平台</h4><ul>
<li>Sentry开源</li>
<li>阿里的ARMS</li>
<li>fundebug</li>
<li>FrontJS</li>
</ul>
<h4 id="几个异常监控的问题"><a href="#几个异常监控的问题" class="headerlink" title="几个异常监控的问题"></a>几个异常监控的问题</h4><ul>
<li><p>如何保证大家提交的代码是符合预期的？ 如何了解前端项目的运行是否正常，是否存在错误？</p>
<p>代码质量体系控制和错误监控以及性能分析</p>
</li>
<li><p>如果用户使用网页，发现白屏，现在联系上了你们，你们会向他询问什么信息呢？先想一下为什么会白屏？</p>
<p>我们以用户访问页面的过程为顺序，大致排查一下</p>
<ol>
<li>用户没打开网络</li>
<li>DNS域名劫持</li>
<li>http劫持</li>
<li>cdn或是其他资源文件访问出错</li>
<li>服务器错误</li>
<li>前端代码错误</li>
<li>前端兼容性问题</li>
<li>用户操作出错</li>
</ol>
</li>
</ul>
<p>通过以上可能发生错误的环节，我们需要向用户手机一下以下的用户信息</p>
<ol>
<li>当前的网络状态</li>
<li>运营商</li>
<li>地理位置</li>
<li>访问时间</li>
<li>客户端的版本(如果是通过客户端访问)</li>
<li>系统版本</li>
<li>浏览器信息</li>
<li>设备分辨率</li>
<li>页面的来源</li>
<li>用户的账号信息</li>
<li>通过performance API收集用户各个页面访问流程所消耗的时间</li>
<li>收集用户js代码报错的信息</li>
</ol>
<ul>
<li>如果我们使用了脚本代码压缩，然而我们又不想将sourcemap文件发布到线上，我们怎么捕获到错误的具体信息？</li>
<li>CSS文件中也存在引用资源，@font-face, background-image …等这些请求错误该如何进行错误捕获？</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>Web规范中相关前端异常<ul>
<li>DOM处理异常</li>
<li>ECMAScript处理异常</li>
</ul>
</li>
<li>异常按照捕获方式分类<ul>
<li>运行时异常</li>
<li>资源加载异常</li>
<li>异步请求异常</li>
<li>Promise异常</li>
</ul>
</li>
<li>异常的捕获方式<ul>
<li>try-catch (ES提供基本的错误捕获语法)<ul>
<li>只能捕获同步代码的异常</li>
<li><del>回调</del></li>
<li><del>setTimeout</del></li>
<li><del>promise</del></li>
</ul>
</li>
<li>window.onerror &#x3D; cb (DOM0)<ul>
<li>img</li>
<li>script</li>
<li>link</li>
</ul>
</li>
<li>window.addEventListener(‘error’, cb, true) (DOM2)</li>
<li>window.addEventListener(“unhandledrejection”, cb) (DOM4)</li>
<li>Promise.then().catch(cb)</li>
<li>封装XMLHttpRequest&amp;fetch | 覆写请求接口对象</li>
</ul>
</li>
</ul>
<p>注意点：跨源脚本异常的捕获</p>
<ul>
<li><p>日志上报的方式</p>
<ul>
<li>异步请求上报</li>
<li>new img上报 避免跨域问题</li>
</ul>
</li>
<li><p>扩展阅读</p>
<ul>
<li>业界已有的异常监控平台</li>
<li>几个跟异常监控有关的问题</li>
</ul>
</li>
</ul>
<p>为了在移动端项目中实现前端错误监控，并考虑极端断网环境，我们需要设计一个健壮且全面的技术方案。移动端环境具有网络不稳定（弱网、断网）、设备多样性、操作系统差异等特点，因此方案需要具备以下能力：</p>
<ol>
<li><p>错误捕获：全面捕获JS错误、资源加载错误、接口错误、框架错误（如React&#x2F;Vue）、Promise错误等。</p>
</li>
<li><p>数据存储：在断网情况下，能够将错误信息暂存本地，待网络恢复后上报。</p>
</li>
<li><p>上报机制：支持重试机制，避免因网络问题导致数据丢失。</p>
</li>
<li><p>数据压缩与批处理：减少网络请求，节省流量。</p>
</li>
<li><p>区分错误类型：对错误进行分类，便于分析。</p>
</li>
</ol>
<p> 我们将从以下几个方面进行设计：</p>
<p> 一、错误捕获</p>
<p> 二、错误信息处理</p>
<p> 三、本地存储与上报</p>
<p> 四、网络恢复后的处理</p>
<p> 五、其他优化措施</p>
<p> 详细方案如下：</p>
<p> 一、错误捕获</p>
<ol>
<li>JavaScript运行时错误</li>
</ol>
<p>​    - 使用 <code>window.onerror</code> 捕获全局同步错误。</p>
<p>​    - 注意：<code>window.onerror</code> 无法捕获语法错误（一般会在编译阶段发现，不会进入线上环境）和跨域脚本错误（需要为跨域脚本添加 <code>crossorigin</code> 属性）。</p>
<ol start="2">
<li>Promise错误</li>
</ol>
<p>​    - 使用 <code>unhandledrejection</code> 事件捕获未处理的Promise拒绝。</p>
<ol start="3">
<li>资源加载错误</li>
</ol>
<p>​    - 使用 <code>window.addEventListener(&#39;error&#39;, callback, true)</code> 捕获资源（如图片、脚本、样式）加载错误。注意第三个参数为 <code>true</code>（捕获阶段）。</p>
<ol start="4">
<li>框架错误</li>
</ol>
<p>​    - React：使用 <code>ErrorBoundary</code> 组件捕获组件树中的错误。</p>
<p>​    - Vue：使用 <code>Vue.config.errorHandler</code> 全局错误处理函数。</p>
<ol start="5">
<li>控制台错误（可选）</li>
</ol>
<p>​    - 重写 <code>console.error</code> 方法，捕获通过 <code>console.error</code> 输出的错误。</p>
<ol start="6">
<li>接口错误</li>
</ol>
<p>​    - 重写 <code>XMLHttpRequest</code> 和 <code>fetch</code> 方法，拦截请求并监听错误。</p>
<p> 二、错误信息处理</p>
<p> 对捕获到的错误信息进行规范化处理，提取关键信息，包括：</p>
<p>   - 错误类型（如JS错误、资源错误、Promise错误等）</p>
<p>   - 错误消息</p>
<p>   - 错误堆栈（尽可能完整）</p>
<p>   - 发生错误的页面URL</p>
<p>   - 设备信息（如UA、屏幕分辨率、设备型号等，通过navigator获取）</p>
<p>   - 用户信息（如果有登录用户）</p>
<p>   - 发生时间</p>
<p>   - 其他上下文信息（如当前路由、前端版本号等）</p>
<p> 三、本地存储与上报</p>
<ol>
<li>本地存储</li>
</ol>
<p>​    - 使用浏览器提供的持久化存储（如IndexedDB）来存储错误日志。因为IndexedDB存储容量较大（通常50MB以上），且支持异步操作，不会阻塞主线程。</p>
<p>​    - 在断网情况下，将错误日志存入IndexedDB，并标记为待上报状态。</p>
<ol start="2">
<li>上报机制</li>
</ol>
<p>​    - 每次发生错误，先尝试立即上报（如果网络正常）。</p>
<p>​    - 如果上报失败（网络错误或服务器错误），则将错误日志存入IndexedDB。</p>
<p>​    - 定时检查（例如每5分钟）IndexedDB中是否有待上报的错误日志，如果有且网络可用，则进行上报。</p>
<p>​    - 在页面可见性变化时（例如用户切换回应用）检查并上报。</p>
<p>​    - 在页面关闭前（<code>visibilitychange</code> 和 <code>pagehide</code> 事件）尝试上报，但要注意此时不能使用同步的XHR（推荐使用 <code>navigator.sendBeacon</code> 方法）。</p>
<ol start="3">
<li>重试机制</li>
</ol>
<p>​    - 每条错误日志设置重试次数（如3次），超过重试次数则丢弃（避免存储爆满）。</p>
<p>​    - 每次重试间隔时间递增（指数退避策略）。</p>
<p> 四、网络恢复后的处理</p>
<p>   监听网络状态变化（<code>navigator.onLine</code>），当网络恢复时，触发一次上报。</p>
<p> 五、其他优化措施</p>
<ol>
<li><p>数据压缩：在存储和上报前，对数据进行压缩（如使用gzip，但前端压缩通常用lz-string等库进行简单压缩，或使用JSON字符串减少冗余字段名）。</p>
</li>
<li><p>批量上报：将多个错误日志合并为一个请求上报，减少请求次数。</p>
</li>
<li><p>采样率：根据错误类型和严重程度设置采样率，避免大量重复错误导致存储和上报压力。</p>
</li>
<li><p>存储上限：设置IndexedDB存储上限（如最多存储1000条错误日志），超过时丢弃旧日志。</p>
</li>
<li><p>区分环境：开发环境不上报，避免开发过程中产生的大量错误上报。</p>
</li>
</ol>
<h1 id="前端场景"><a href="#前端场景" class="headerlink" title="前端场景"></a>前端场景</h1><p>参考思路：<a href="%5B%E5%89%8D%E7%AB%AF%E5%8D%8F%E5%90%8C%E6%96%87%E6%A1%A3%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF_%E5%89%8D%E7%AB%AF%E6%96%87%E6%A1%A3%E5%8D%8F%E5%90%8C-CSDN%E5%8D%9A%E5%AE%A2%5D" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;Bruce__taotao&#x2F;article&#x2F;details&#x2F;148200821#:~:text&#x3D;本文介绍了前端协同文档系统的实现技术和方法，主要包括实时同步机制（WebSocket、OT和CRDT算法）、实时文本编辑（Diff算法和协作框架）、后端实现（数据库同步与技术栈）以及前端技术（React%2FVue和WebRTC）。 此外，还讨论了功能扩展如版本控制和权限管理，并提供了基于Vue.js和Node.js的简单实现示例。,协同文档开发需结合多种技术，确保实时性和数据一致性。 _前端协同算法">前端协同文档实现思路</a></p>
<h2 id="RN容器与浏览器容器的区别"><a href="#RN容器与浏览器容器的区别" class="headerlink" title="RN容器与浏览器容器的区别"></a>RN容器与浏览器容器的区别</h2><ol>
<li><strong>RN容器 (React Native 容器)</strong><ul>
<li><strong>目标：</strong> 在**原生移动应用（iOS&#x2F;Android）**中运行。</li>
<li><strong>核心：</strong> 它是一个<strong>原生应用框架</strong>（虽然使用了JavaScript）。React Native 应用最终会被编译&#x2F;打包成包含原生代码（Objective-C&#x2F;Swift for iOS, Java&#x2F;Kotlin for Android）的安装包（.ipa&#x2F;.apk）。</li>
<li><strong>渲染：</strong> <strong>不依赖浏览器引擎</strong>。RN 的核心在于其<strong>原生桥接</strong>。你的 JavaScript 代码（描述UI和逻辑）通过这个桥接与<strong>原生UI组件</strong>通信。当你在 RN 中写一个 <code>&lt;View&gt;</code> 或 <code>&lt;Text&gt;</code> 时，最终在屏幕上显示的是平台对应的原生视图（<code>UIView</code> on iOS, <code>android.view.View</code> on Android）。JavaScript 线程计算布局和逻辑，然后通过桥接将指令发送到原生主线程进行实际的渲染。</li>
<li><strong>能力：</strong> 可以<strong>直接访问绝大部分原生设备功能</strong>（摄像头、地理位置、传感器、文件系统、蓝牙等），通过 JavaScript 桥接调用原生模块实现。性能通常接近纯原生应用，尤其是在复杂UI和动画方面。</li>
<li><strong>打包：</strong> 最终打包成一个独立的、需要安装的<strong>原生移动应用</strong>。</li>
<li><strong>开发体验：</strong> 使用 JavaScript (或 TypeScript) 和 React 范式开发，但需要理解原生概念（如桥接、线程、原生模块）以及特定平台的差异。可以使用热重载。</li>
<li><strong>例子：</strong> Facebook、Instagram、Discord、Shopify 的部分功能。</li>
</ul>
</li>
<li><strong>浏览器容器 (Browser Container &#x2F; WebView)</strong><ul>
<li><strong>目标：</strong> 在<strong>任何有兼容浏览器（或 WebView 控件）</strong> 的环境（桌面、移动、电视、甚至某些嵌入式设备）中运行。</li>
<li><strong>核心：</strong> 它是一个<strong>网页渲染引擎</strong>（如 WebKit, Blink, Gecko）。浏览器容器（如 Chrome, Safari, Firefox，或者移动 App 内嵌的 <code>UIWebView</code>&#x2F;<code>WKWebView</code> on iOS, <code>WebView</code> on Android）的工作就是下载、解析 HTML&#x2F;CSS&#x2F;JavaScript 代码，并根据 Web 标准将其渲染成可视化的网页。</li>
<li><strong>渲染：</strong> <strong>完全依赖浏览器引擎</strong>。它渲染的是 <strong>HTML DOM 元素</strong> 和 <strong>CSS 样式</strong>。JavaScript 运行在浏览器提供的沙盒环境中，操作 DOM 和 CSSOM 来实现交互和动态效果。</li>
<li><strong>能力：</strong> 通过 Web APIs（如 <code>Geolocation API</code>, <code>Camera API (getUserMedia)</code>, <code>Web Bluetooth</code> 等）访问设备功能，但这些 API 的<strong>支持度、权限模型和性能通常不如原生访问直接和强大</strong>，且依赖于浏览器厂商的实现。性能受限于浏览器渲染引擎和 JavaScript 引擎。</li>
<li><strong>打包：</strong> 本质上是<strong>网页</strong>，通过 URL 访问（在线或离线包）。在移动端，可以通过 <strong>PWA</strong> 技术或简单的 <strong>WebView 封装</strong> 使其看起来更像一个 App（有图标、启动屏等），但其核心仍是网页。</li>
<li><strong>开发体验：</strong> 使用标准的 Web 技术（HTML, CSS, JavaScript）。一次编写，理论上可以在所有现代浏览器上运行（虽然存在兼容性问题）。开发工具链成熟（浏览器开发者工具）。热重载是标准功能。</li>
<li><strong>例子：</strong> 任何网站或 Web App。移动端内嵌 WebView 的混合应用（Hybrid App），或者 PWA（如 Twitter Lite, Starbucks PWA）。</li>
</ul>
</li>
</ol>
<p><strong>核心区别总结：</strong></p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">RN 容器 (React Native App)</th>
<th align="left">浏览器容器 (Web App &#x2F; WebView)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>本质</strong></td>
<td align="left"><strong>原生应用框架</strong> (JS驱动原生UI)</td>
<td align="left"><strong>网页渲染引擎</strong> (渲染 HTML&#x2F;CSS&#x2F;JS DOM)</td>
</tr>
<tr>
<td align="left"><strong>目标平台</strong></td>
<td align="left"><strong>原生移动平台 (iOS&#x2F;Android)</strong></td>
<td align="left"><strong>任何有兼容浏览器&#x2F;WebView的平台</strong></td>
</tr>
<tr>
<td align="left"><strong>最终产物</strong></td>
<td align="left">原生安装包 (.ipa&#x2F;.apk)</td>
<td align="left">网页资源 (HTML&#x2F;CSS&#x2F;JS)，通过 URL 访问</td>
</tr>
<tr>
<td align="left"><strong>渲染方式</strong></td>
<td align="left"><strong>原生UI组件</strong> (通过JS桥接驱动)</td>
<td align="left"><strong>HTML DOM &#x2F; CSSOM</strong> (由浏览器引擎渲染)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left"><strong>接近原生</strong>，复杂UI&#x2F;动画更流畅</td>
<td align="left">受限于浏览器引擎，复杂场景可能较差</td>
</tr>
<tr>
<td align="left"><strong>设备访问</strong></td>
<td align="left"><strong>直接、强大</strong> (通过原生桥接模块)</td>
<td align="left"><strong>通过 Web APIs</strong>，支持度和能力有限</td>
</tr>
<tr>
<td align="left"><strong>开发技术</strong></td>
<td align="left">JS&#x2F;TS + React + 原生概念</td>
<td align="left">HTML + CSS + JS&#x2F;TS</td>
</tr>
<tr>
<td align="left"><strong>跨平台</strong></td>
<td align="left">需为iOS&#x2F;Android分别构建，代码可共享</td>
<td align="left"><strong>一次编写，随处运行</strong> (理论，需适配)</td>
</tr>
<tr>
<td align="left"><strong>安装</strong></td>
<td align="left">需要从应用商店下载安装</td>
<td align="left">通过URL访问，PWA可“安装”到桌面&#x2F;主屏</td>
</tr>
<tr>
<td align="left"><strong>更新</strong></td>
<td align="left">需通过应用商店审核更新</td>
<td align="left"><strong>即时更新</strong> (服务器端更新资源即可)</td>
</tr>
</tbody></table>
<p><strong>简单类比：</strong></p>
<ul>
<li><strong>RN容器：</strong> 像一个用JavaScript编写的“说明书”，交给当地（iOS&#x2F;Android）的“施工队”（原生桥接和组件）按照说明书，用当地最好的“建材”（原生UI组件）来建造房子（App）。结果是本地化的、高质量的房子。</li>
<li><strong>浏览器容器：</strong> 像一个预制的“活动板房”（网页）。施工队（浏览器引擎）按照统一的“国际标准”（Web标准），用自带的“标准化板材”（HTML&#x2F;CSS）在任何地方快速搭建。房子可以快速搭建和修改，但可能不如本地定制的那么坚固或贴合当地环境。</li>
</ul>
<p><strong>选择哪一个？</strong></p>
<p>需要<strong>最佳性能、深度设备集成、原生用户体验</strong> -&gt; <strong>React Native</strong>。</p>
<p>需要<strong>最广泛的跨平台覆盖（包括Web）、最快的开发迭代速度、即时更新</strong> -&gt; <strong>浏览器容器 (Web技术&#x2F;PWA)</strong>。</p>
<p>混合方案：在原生App中嵌入<strong>WebView</strong>来展示部分内容（如帮助页面、营销活动页），结合两者优势。React Native 本身也提供了 <code>WebView</code> 组件来实现这一点。</p>
<h2 id="静态资源失效"><a href="#静态资源失效" class="headerlink" title="静态资源失效"></a>静态资源失效</h2><h3 id="方法一：基础而有效的-onerror-事件降级"><a href="#方法一：基础而有效的-onerror-事件降级" class="headerlink" title="方法一：基础而有效的 onerror 事件降级"></a><strong>方法一：基础而有效的 onerror 事件降级</strong></h3><h3 id="先讲个小故事："><a href="#先讲个小故事：" class="headerlink" title="先讲个小故事："></a><strong>先讲个小故事：</strong></h3><p>有次上线前我自信满满，刚发版就邀请产品经理来验收。结果尴尬的是，CDN图片资源同步延迟了，头像全裂开。产品经理抬头问我：“这是个啥？”。我赶紧安抚后，马上想到的应急方案就是 <code>onerror</code>：</p>
<h3 id="原理说明："><a href="#原理说明：" class="headerlink" title="原理说明："></a><strong>原理说明：</strong></h3><p><code>onerror</code> 事件会在资源加载失败时被触发，我们只要捕获到这个错误，就可以立即切换到备用资源。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 图片加载失败用默认头像补救 --&gt;</span><br><span class="line">&lt;img src=&quot;https://cdn.example.com/avatar.png&quot;</span><br><span class="line">     alt=&quot;用户头像&quot;</span><br><span class="line">     onerror=&quot;this.onerror=null;this.src=&#x27;/static/default-avatar.png&#x27;;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>JS脚本的方案类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">script.src = &#x27;https://cdn.example.com/app.js&#x27;;</span><br><span class="line">script.onerror = () =&gt; &#123;</span><br><span class="line">  console.warn(&#x27;CDN挂了，正在加载本地脚本...&#x27;);</span><br><span class="line">  const localScript = document.createElement(&#x27;script&#x27;);</span><br><span class="line">  localScript.src = &#x27;/static/app.js&#x27;;</span><br><span class="line">  document.head.appendChild(localScript);</span><br><span class="line">&#125;;</span><br><span class="line">document.head.appendChild(script);</span><br></pre></td></tr></table></figure>

<p>这样做的好处是：简单、直接，而且对用户几乎无感知。</p>
<p>不过缺点也明显，每个资源都需要单独处理，管理起来会有点麻烦。</p>
<h3 id="方法二：Service-Worker-缓存兜底方案"><a href="#方法二：Service-Worker-缓存兜底方案" class="headerlink" title="方法二：Service Worker 缓存兜底方案"></a><strong>方法二：Service Worker 缓存兜底方案</strong></h3><h3 id="再聊个真实场景："><a href="#再聊个真实场景：" class="headerlink" title="再聊个真实场景："></a><strong>再聊个真实场景：</strong></h3><p>去年负责做一个PWA应用，上线后有用户特意反馈：“你们的网站牛啊，进电梯没网还能打开！”我当时特别得意，因为这正是 Service Worker 缓存策略发挥了作用。</p>
<h3 id="原理说明：-1"><a href="#原理说明：-1" class="headerlink" title="原理说明："></a><strong>原理说明：</strong></h3><p>Service Worker 会在后台拦截页面的网络请求，实现「缓存优先（Cache First）」，让页面的关键资源都预先存好，离线也能打开。</p>
<p>核心代码示意：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&#x27;install&#x27;, event =&gt; &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(&#x27;v1&#x27;).then(cache =&gt; cache.addAll([</span><br><span class="line">      &#x27;/index.html&#x27;, &#x27;/styles.css&#x27;, &#x27;/app.js&#x27;</span><br><span class="line">    ]))</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(&#x27;fetch&#x27;, event =&gt; &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request).then(cachedResponse =&gt; &#123;</span><br><span class="line">      return cachedResponse || fetch(event.request).then(networkResponse =&gt; &#123;</span><br><span class="line">        caches.open(&#x27;v1&#x27;).then(cache =&gt; cache.put(event.request, networkResponse.clone()));</span><br><span class="line">        return networkResponse;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样一来，首次访问后关键文件都会被缓存，后续访问即便网络不佳，体验依旧稳定。</p>
<p>不过要注意缓存版本管理，定期更新缓存版本，比如<code>v1</code>变更为<code>v2</code>时要及时清理旧缓存。</p>
<h3 id="方法三：CSS资源的优雅降级（防止页面变丑）"><a href="#方法三：CSS资源的优雅降级（防止页面变丑）" class="headerlink" title="方法三：CSS资源的优雅降级（防止页面变丑）"></a><strong>方法三：CSS资源的优雅降级（防止页面变丑）</strong></h3><h3 id="说个囧事儿："><a href="#说个囧事儿：" class="headerlink" title="说个囧事儿："></a><strong>说个囧事儿：</strong></h3><p>之前赶上线，有次CSS文件被错误删除了，用户打开网页一瞬间以为电脑坏了，满屏都是乱掉的元素。我赶紧临时补救——塞了一段最小可用的内联样式，勉强挽救了场面。</p>
<h3 id="原理说明：-2"><a href="#原理说明：-2" class="headerlink" title="原理说明："></a><strong>原理说明：</strong></h3><p>CSS出问题容易导致“无样式内容闪现”（FOUC），解决方法是利用 preload 提前加载关键 CSS，并配合超时策略内联兜底。</p>
<p>示例代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;preload&quot; href=&quot;/critical.css&quot; as=&quot;style&quot; onload=&quot;this.rel=&#x27;stylesheet&#x27;&quot;&gt;</span><br><span class="line">&lt;noscript&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/critical.css&quot;&gt;&lt;/noscript&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  if (!document.querySelector(&#x27;link[href=&quot;/critical.css&quot;]&#x27;)) &#123;</span><br><span class="line">    const style = document.createElement(&#x27;style&#x27;);</span><br><span class="line">    style.textContent = `</span><br><span class="line">      body &#123; font-family: sans-serif; background-color: #fff; &#125;</span><br><span class="line">      h1, p &#123; margin: 0; padding: 10px; &#125;</span><br><span class="line">    `;</span><br><span class="line">    document.head.appendChild(style);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 3000);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>这个策略让页面至少能保证基础的样式效果。用户甚至不会觉察出原始样式加载失败。</p>
<h3 id="方法四：React-Vue-组件的错误边界"><a href="#方法四：React-Vue-组件的错误边界" class="headerlink" title="方法四：React&#x2F;Vue 组件的错误边界"></a><strong>方法四：React&#x2F;Vue 组件的错误边界</strong></h3><h3 id="现场再现："><a href="#现场再现：" class="headerlink" title="现场再现："></a><strong>现场再现：</strong></h3><p>有一次后台项目演示，我用了个特别重的图表组件，结果网络不好加载失败。</p>
<p>如果整个页面跟着白屏，估计当场想死的心都有。不过我提前用了 React 的 Error Boundary 包裹这个组件，它显示了一句友好的“加载失败，请稍后重试”，整个页面还能用。最后老板就只提了一嘴看看啥情况（还好还好）。</p>
<h3 id="原理说明：-3"><a href="#原理说明：-3" class="headerlink" title="原理说明："></a><strong>原理说明：</strong></h3><p>React 的 Error Boundary 就是捕获组件渲染或加载错误的边界组件，常配合懒加载 (<code>React.lazy</code>) 使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// ErrorBoundary.jsx</span><br><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  state = &#123; hasError: false &#125;;</span><br><span class="line">static getDerivedStateFromError() &#123; return &#123; hasError: true &#125;; &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.hasError) &#123;</span><br><span class="line">      return&lt;div&gt;加载失败，稍后重试一下~&lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">    returnthis.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// App.jsx</span><br><span class="line">const Chart = React.lazy(() =&gt;import(&#x27;./Chart&#x27;));</span><br><span class="line">function App() &#123;</span><br><span class="line">return (</span><br><span class="line">    &lt;ErrorBoundary&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;加载中...&lt;/div&gt;&#125;&gt;</span><br><span class="line">        &lt;Chart /&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/ErrorBoundary&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原理简单而实用：一个组件失败，不会影响整体页面。类似的，Vue中也有 <code>defineAsyncComponent</code> 做类似的降级处理。</p>
<h3 id="深度总结：降级处理的精髓是什么？"><a href="#深度总结：降级处理的精髓是什么？" class="headerlink" title="深度总结：降级处理的精髓是什么？"></a><strong>深度总结：降级处理的精髓是什么？</strong></h3><p>其实，资源降级真正的核心思路就三个字：</p>
<ol>
<li><strong>稳</strong>：确保页面基本功能绝不挂掉；</li>
<li><strong>快</strong>：用户尽量无感知，备用方案秒级切换；</li>
<li><strong>省</strong>：兜底策略简单易维护，不制造新麻烦。</li>
</ol>
<p>从<code>onerror</code>事件、Service Worker缓存，到CSS优雅降级和组件级错误边界，这些方案是逐步深入的，形成一整套完整的容错机制。此外，还要配合前端监控（如上报加载失败率），形成反馈闭环，确保长期稳定运行。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="一、衡量前端性能"><a href="#一、衡量前端性能" class="headerlink" title="一、衡量前端性能"></a><strong>一、衡量前端性能</strong></h3><p>要做前端性能优化，首要工作是<strong>分析和衡量</strong>页面内容，找出网站中需要优化的部分，对症下药。</p>
<p>衡量性能的方式有以下几种：</p>
<ol>
<li>加载时间</li>
<li>性能指标</li>
<li>长任务卡顿</li>
<li>浏览器 Performance 选项卡</li>
</ol>
<h4 id="1、加载时间"><a href="#1、加载时间" class="headerlink" title="1、加载时间"></a><strong>1、加载时间</strong></h4><p>浏览器 <code>PerformanceNavigationTiming</code> 对象提供了关于页面加载性能各种计时的详细信息。（<code>对应旧版本的 performance.timing 对象</code>）比如可以分析 <strong>DOM 树构建完成的时间（<code>DOMContentLoaded</code>） 和 页面完整的加载时间（<code>load</code>）</strong>。</p>
<p>如下示例，在 DOM 树中增加一个  标签来渲染图片，其中：</p>
<ul>
<li><code>DOMContentLoaded</code>，是一个 DOM 事件，当浏览器完成 HTML 文档的解析，构建完成 DOM 树后触发，但不包含图片、CSS、JavaScript 等外部资源的加载。</li>
<li><code>onLoad</code>，是一个 JS 事件，它在页面的所有资源（包括 HTML、CSS、图片、JavaScript 等）完全加载完成后触发。</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://picsum.photos/200/300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;load&quot;</span>, <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 新版浏览器 API：PerformanceNavigationTiming 提供了关于页面加载性能的详细信息，替代旧的 performance.timing</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (performance.<span class="property">getEntriesByType</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> perfEntries = performance.<span class="title function_">getEntriesByType</span>(<span class="string">&quot;navigation&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (perfEntries.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> navigationEntry = perfEntries[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> &#123; domContentLoadedEventStart, loadEventStart, fetchStart &#125; = navigationEntry;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> <span class="title class_">DOMContentLoadedTime</span> = domContentLoadedEventStart - fetchStart;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`DOMContentLoaded 的执行时间：<span class="subst">$&#123;DOMContentLoadedTime&#125;</span>ms`</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> loadTime = loadEventStart - fetchStart;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`load 页面完整的加载时间：<span class="subst">$&#123;loadTime&#125;</span>ms`</span>);</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 旧版浏览器降级使用 performance.timing</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> &#123; fetchStart, domContentLoadedEventStart, loadEventStart &#125; = performance.<span class="property">timing</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> <span class="title class_">DOMContentLoadedTime</span> = domContentLoadedEventStart - fetchStart;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`---DOMContentLoaded 的执行时间：<span class="subst">$&#123;DOMContentLoadedTime&#125;</span>ms`</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> loadTime = loadEventStart - fetchStart;</span></span><br><span class="line"><span class="language-javascript">          <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`load 页面完整的加载时间：<span class="subst">$&#123;loadTime&#125;</span>ms`</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>PS：页面加载性能详细信息参考资料：<strong>PerformanceNavigationTiming</strong>[1]</p>
<h3 id="2、性能指标"><a href="#2、性能指标" class="headerlink" title="2、性能指标"></a><strong>2、性能指标</strong></h3><p>分析以用户为中心的性能指标，包含 <strong>FP（首次像素绘制）、FCP（首次内容绘制）、FMP（首次有意义内容绘制）、LCP（页面中最大可见 图片或者文本块 加载时间）等</strong>。</p>
<p>一般在 <strong>客户端渲染单页面应用</strong> 中，为了优化<strong>首屏渲染白屏时间</strong>，会重点关注 <strong>FCP（首次内容绘制）</strong> 性能指标。该绘制时长越短，说明白屏时间越少，用户打开网站的使用体验就越好。</p>
<blockquote>
<p>说明：<strong>FCP 首次内容绘制</strong> 是指用户在页面中看到了有效内容。比如在 React 框架中，初始时会有一个空 id&#x3D;root div 元素，此时不会计算 FCP，只有等 id&#x3D;root 经过 ReactDOM render 以后，页面呈现了文本等有效内容，这时会计算出 FCP。</p>
</blockquote>
<p>JS 可以通过 <code>PerformanceObserver</code> 观察 <code>event type paint</code> 来获取 FCP 指标。如下示例，初始放置一个空 div，在 1s 以后给 div 中添加有效内容（模拟框架渲染），FCP 指标会在这时生成。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="comment">/* 设置背景图，生成 FP 指标 */</span></span></span><br><span class="line"><span class="language-css">      <span class="selector-id">#root</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background</span>: <span class="number">#eee</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 模拟框架渲染，1s 后在页面呈现有效内容</span></span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        root.<span class="property">innerHTML</span> = <span class="string">&quot;content&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">      &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="title class_">PerformanceObserver</span>(<span class="keyword">function</span>(<span class="params">entryList</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">const</span> perfEntries = entryList.<span class="title function_">getEntries</span>();</span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">for</span> (<span class="keyword">const</span> perfEntry <span class="keyword">of</span> perfEntries) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (perfEntry.<span class="property">name</span> === <span class="string">&quot;first-paint&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">const</span> <span class="variable constant_">FP</span> = perfEntry;</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;首次像素绘制 时间：&quot;</span>, <span class="variable constant_">FP</span>?.<span class="property">startTime</span>); <span class="comment">// 674ms（div 设有背景图，会在元素渲染时生成 FP 指标）</span></span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="title function_">elseif</span> (perfEntry.<span class="property">name</span> === <span class="string">&quot;first-contentful-paint&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="keyword">const</span> <span class="variable constant_">FCP</span> = perfEntry;</span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;首次内容绘制 时间：&quot;</span>, <span class="variable constant_">FCP</span>?.<span class="property">startTime</span>); <span class="comment">// 1174ms</span></span></span><br><span class="line"><span class="language-javascript">              observer.<span class="title function_">disconnect</span>(); <span class="comment">// 断开观察，不再观察了</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 观察 paint 相关性能指标</span></span></span><br><span class="line"><span class="language-javascript">        observer.<span class="title function_">observe</span>(&#123; <span class="attr">entryTypes</span>: [<span class="string">&quot;paint&quot;</span>] &#125;);</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、页面卡顿"><a href="#3、页面卡顿" class="headerlink" title="3、页面卡顿"></a><strong>3、页面卡顿</strong></h3><p>当一段代码的执行占用主线程时间过长时，用户在页面上的交互就会出现卡顿，我们可以通过监控这类长任务，针对性地进行优化。</p>
<p>如下示例，点击按钮执行一个 1000ms 长任务，我们可以使用 <code>PerformanceObserver</code> 观察 <code>event type longtask</code> 并设置阈值。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;longTaskBtn&quot;</span>&gt;</span>执行longTask<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 默认长任务</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> longTaskBtn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;longTaskBtn&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">function</span> <span class="title function_">longTask</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> start = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;longTask开始 start&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">while</span> (<span class="title class_">Date</span>.<span class="title function_">now</span>() &lt; <span class="number">1000</span> + start) &#123;&#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;longTask结束 end，耗时：&quot;</span>, <span class="title class_">Date</span>.<span class="title function_">now</span>() - start);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      longTaskBtn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, longTask);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// 观察长任务</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">new</span> <span class="title class_">PerformanceObserver</span>(<span class="function">(<span class="params">list</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        list.<span class="title function_">getEntries</span>().<span class="title function_">forEach</span>(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">// 设定卡顿阈值：执行时长大于 500 ms</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (entry.<span class="property">duration</span> &gt; <span class="number">500</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行的长任务耗时：&quot;</span>, entry.<span class="property">duration</span>);</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">      &#125;).<span class="title function_">observe</span>(&#123; <span class="attr">entryTypes</span>: [<span class="string">&quot;longtask&quot;</span>] &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4、浏览器-Performance-选项卡"><a href="#4、浏览器-Performance-选项卡" class="headerlink" title="4、浏览器 Performance 选项卡"></a><strong>4、浏览器 Performance 选项卡</strong></h3><p>除了上述通过代码进行度量性能外，还可以在 <strong>浏览器控制台 - Performance 选项卡</strong> 中查看和分析页面性能。其中包含 <strong>FCP 性能指标、页面内容绘制 的耗时统计</strong> 等。</p>
<p><img src="C:\Users\Zhangwenye\Desktop\博客\source\img\640.jpg" alt="image.png"></p>
<h3 id="二、代码逻辑"><a href="#二、代码逻辑" class="headerlink" title="二、代码逻辑"></a><strong>二、代码逻辑</strong></h3><p>在特定需求场景下，我们可以通过一些 <strong>编程技巧</strong> 来提升性能网站的运行时性能。如：<strong>防抖&#x2F;节流、图片懒加载、时间切片</strong>等。</p>
<h4 id="1、关注复杂度分析"><a href="#1、关注复杂度分析" class="headerlink" title="1、关注复杂度分析"></a><strong>1、关注复杂度分析</strong></h4><p>我们在学习算法的时候入门课就是接触<strong>复杂度分析(大 O 表示法)</strong>，通过它来分析一个算法的 执行效率 和 占用内存 的好坏。</p>
<p>复杂度分析同样可以应用在日常开发中，它能约束你的代码编写逻辑，也会考察你的 编程思维 和 基础内功。</p>
<p>现有一个需求：在一组数据中查询目标值。</p>
<p>如果不注重代码执行效率，可能会写成下面这样，查找 N 个目标值就要执行 N 遍循环，如果不忽略系数，它的时间复杂度为 O(n^2)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">  &#123; <span class="attr">cityId</span>: <span class="string">&quot;bj&quot;</span>, <span class="attr">cityName</span>: <span class="string">&quot;北京&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">cityId</span>: <span class="string">&quot;sh&quot;</span>, <span class="attr">cityName</span>: <span class="string">&quot;上海&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">cityId</span>: <span class="string">&quot;gz&quot;</span>, <span class="attr">cityName</span>: <span class="string">&quot;广州&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">cityId</span>: <span class="string">&quot;sz&quot;</span>, <span class="attr">cityName</span>: <span class="string">&quot;深圳&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bj = list.<span class="title function_">find</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">cityId</span> === <span class="string">&quot;bj&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> sh = list.<span class="title function_">find</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">cityId</span> === <span class="string">&quot;sh&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> gz = list.<span class="title function_">find</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">cityId</span> === <span class="string">&quot;gz&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> sz = list.<span class="title function_">find</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> item.<span class="property">cityId</span> === <span class="string">&quot;sz&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>而对于注重编程思维的工程师，只需进行一轮遍历并将结果存储在 <code>Map</code> 中实现需求（时间复杂度 O(n) ）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [</span><br><span class="line">  &#123; <span class="attr">cityId</span>: <span class="string">&quot;bj&quot;</span>, <span class="attr">cityName</span>: <span class="string">&quot;北京&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">cityId</span>: <span class="string">&quot;sh&quot;</span>, <span class="attr">cityName</span>: <span class="string">&quot;上海&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">cityId</span>: <span class="string">&quot;gz&quot;</span>, <span class="attr">cityName</span>: <span class="string">&quot;广州&quot;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">cityId</span>: <span class="string">&quot;sz&quot;</span>, <span class="attr">cityName</span>: <span class="string">&quot;深圳&quot;</span> &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cityMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">list.<span class="title function_">forEach</span>(<span class="function">(<span class="params">city</span>) =&gt;</span> &#123;</span><br><span class="line">  cityMap[city.<span class="property">cityId</span>] = city;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; bj, sh, gz, sz &#125; = cityMap;</span><br></pre></td></tr></table></figure>

<h4 id="2、防抖和节流"><a href="#2、防抖和节流" class="headerlink" title="2、防抖和节流"></a><strong>2、防抖和节流</strong></h4><p>防抖和节流大家都不陌生，在用户频繁操作一个功能时，可以适当使用 <strong>防抖和节流</strong> 优化逻辑执行时机，避免重复执行 JS 逻辑造成页面交互阻塞。</p>
<ul>
<li>对于防抖，常见的场景是 <strong>输入框搜索查询</strong>，短时间内重复操作会 <strong>清除并重新计时</strong> 来执行回调任务；</li>
<li>对于节流，常见的场景是 <strong>调整窗口大小</strong>，以 <strong>固定的短间隔频率</strong> 执行回调任务。</li>
</ul>
<h4 id="3、图片懒加载"><a href="#3、图片懒加载" class="headerlink" title="3、图片懒加载"></a><strong>3、图片懒加载</strong></h4><p>图片懒加载也是一种网站优化手段。如果不做控制，图片全部加载发送 HTTP 请求可能会导致网站卡顿崩溃。</p>
<p>首次进入页面，我们只需要加载出首屏区域的图片，其他区域的图片放置一个小的默认图，后续将图片滑动到可视区域后再加载实际的图片。</p>
<p>懒加载可以使用 <strong>IntersectionObserver API</strong> 实现。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./loading-url.png&quot;</span> <span class="attr">data-src</span>=<span class="string">&quot;./url.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">const imgList = [...document.querySelectorAll(&#x27;img&#x27;)];</span><br><span class="line">const io = new IntersectionObserver((entries) =&gt;&#123;</span><br><span class="line">  entries.forEach(item =&gt; &#123;</span><br><span class="line">    // isIntersecting 是一个 Boolean 值，判断目标元素当前是否进入 root 视窗（默认 root 是 window 窗口可视区域）</span><br><span class="line">    if (item.isIntersecting) &#123;</span><br><span class="line">      item.target.src = item.target.dataset.src; // 真实的图片地址存放在 data-src 自定义属性上</span><br><span class="line">      // 图片加载后停止监听该元素，释放内存</span><br><span class="line">      io.unobserve(item.target);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">// observe 监听所有 img 节点</span><br><span class="line">imgList.forEach(img =&gt; io.observe(img));</span><br></pre></td></tr></table></figure>

<h4 id="4、时间切片"><a href="#4、时间切片" class="headerlink" title="4、时间切片"></a><strong>4、时间切片</strong></h4><p>我们知道 浏览器的渲染 和 JS 运行在一个单线程上，如果 JS 执行一个 <strong>LongTask 长任务</strong>，势必会阻塞浏览器渲染，导致用户在界面交互出现卡顿。</p>
<p>因此我们需要避免长任务的执行，或按照一定规则拆分成一个个小任务通过 <strong>时间切片</strong> 来管理和执行。</p>
<h4 id="5、Web-Worker-子线程"><a href="#5、Web-Worker-子线程" class="headerlink" title="5、Web Worker 子线程"></a><strong>5、Web Worker 子线程</strong></h4><p>如果说一个长任务仅是做一些计算的逻辑，并不一定非要在主线程上运行，那么可以选择使用 Worker 开启子线程并行执行计算任务。</p>
<p>常见的场景是 <strong>大文件切片上传 - 计算文件 hash</strong>，文件越大计算 hash 耗时就越长，因此这种耗时的工作可以交给 Web Worker。</p>
<h4 id="6、LRU-算法"><a href="#6、LRU-算法" class="headerlink" title="6、LRU 算法"></a><strong>6、LRU 算法</strong></h4><p>在做业务功能时为了提升用户体验（提升二次访问速度），会涉及 <strong>对已访问数据进行缓存</strong> 的操作，缓存存储可以是在 <strong>内存变量 或 浏览器本地缓存</strong> 中。</p>
<p>无论是哪种存放位置，都不宜无限制的向缓存中存储数据，存储的越多，就会导致计算机运行越来越慢。</p>
<p><strong>LRU（最近最少使用）算法用于管理缓存中的数据</strong>，确保缓存集合中数据的条目在一个可控的范围内。</p>
<p>通过 <strong>队列</strong> 可以实现 LRU 算法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="title function_">constructor</span>(<span class="params">max</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">max</span> = max; <span class="comment">// 缓存容量</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = <span class="title function_">newMap</span>(); <span class="comment">// 定义缓存 Map，优化查找速度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">keys</span> = []; <span class="comment">// 队列，记录最近节点的 key</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问数据</span></span><br><span class="line"><span class="title function_">get</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">      <span class="comment">// 更新节点到队列尾部</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">update</span>(key);</span><br><span class="line">      <span class="keyword">const</span> val = <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">get</span>(key);</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    returnundefined;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加/更新数据</span></span><br><span class="line">  <span class="title function_">put</span>(<span class="params">key, val</span>) &#123;</span><br><span class="line">    <span class="comment">// 1、更新数据（和 get 相似都是更新节点到队列尾部，不过多了更新 val 操作）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, val);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">update</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、添加数据</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">set</span>(key, val); <span class="comment">// 记录到 Map 中</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">keys</span>.<span class="title function_">push</span>(key); <span class="comment">// 添加到队列尾部</span></span><br><span class="line">      <span class="comment">// 考虑容量是否超出</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">keys</span>.<span class="property">length</span> &gt; <span class="variable language_">this</span>.<span class="property">max</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> oldKey = <span class="variable language_">this</span>.<span class="property">keys</span>.<span class="title function_">shift</span>(); <span class="comment">// 删除队列头部</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cache</span>.<span class="title function_">delete</span>(oldKey);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动到队列尾部</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="property">keys</span>.<span class="title function_">indexOf</span>(key);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">keys</span>.<span class="title function_">splice</span>(index, <span class="number">1</span>); <span class="comment">// 删除旧的位置</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">keys</span>.<span class="title function_">push</span>(key); <span class="comment">// 添加到队列尾部</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="title class_">LRUCache</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 添加新数据，此时缓存未满</span></span><br><span class="line">cache.<span class="title function_">put</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">cache.<span class="title function_">put</span>(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">cache.<span class="title function_">put</span>(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cache.<span class="property">keys</span>); <span class="comment">// [a, b, c]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 访问已有数据</span></span><br><span class="line">cache.<span class="title function_">get</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cache.<span class="property">keys</span>); <span class="comment">// [a, c, b]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 添加新数据，此时缓存已满</span></span><br><span class="line">cache.<span class="title function_">put</span>(<span class="string">&quot;d&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(cache.<span class="property">keys</span>); <span class="comment">// [c, b, d]</span></span><br></pre></td></tr></table></figure>

<h4 id="7、虚拟滚动列表"><a href="#7、虚拟滚动列表" class="headerlink" title="7、虚拟滚动列表"></a><strong>7、虚拟滚动列表</strong></h4><p><strong>虚拟滚动列表</strong> 是一种用于优化长列表或大量数据展示的前端技术。它的核心思想是只渲染当前可视区域内的数据项，而不是一次性渲染整个列表。</p>
<p>这种方式可以显著减少DOM操作，降低浏览器的渲染负担，从而提高性能和用户体验。</p>
<p>假设我们向服务端查询到 1000 条数据，<strong>如果原样将这 1000 个数据渲染在页面上，就会生成 1000 个 DOM 节点</strong>。</p>
<p>对于用户而言，其实并不关心是否是一次性将数据全部渲染到列表容器中，只要在容器的可视区域内的 DOM 数据能够正常看到就行。</p>
<p>虚拟滚动的核心优化思路：<strong>结合滚动条 top 位置和容器的可视区域，计算出这个区间的数据项，渲染到滚动容器中</strong>。</p>
<p>另外还有一个 <strong>虚拟滑动列表</strong> 也称为 无限滑动列表，和虚拟滚动列表的实现相似，适合应用在 H5 移动端，类似抖音的 短视频 推荐列表。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/29/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD/" data-id="cmchb34xk0000c4ur8wemfedc" data-title="前端性能[C" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E3%80%81%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E3%80%81/" rel="tag">前端页面、错误监控、</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-基础开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/06/28/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2025-06-28T13:03:52.000Z" itemprop="datePublished">2025-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/06/28/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/">基础开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="Canvas和SVG"><a href="#Canvas和SVG" class="headerlink" title="Canvas和SVG"></a>Canvas和SVG</h2><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>Canvas</strong></th>
<th align="center"><strong>SVG</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型</strong></td>
<td align="left">位图（像素操作）</td>
<td align="center">矢量图（XML 描述）</td>
</tr>
<tr>
<td align="left"><strong>渲染方式</strong></td>
<td align="left">即时模式（绘制后不保留对象）</td>
<td align="center">保留模式（DOM 树存储对象）</td>
</tr>
<tr>
<td align="left"><strong>分辨率依赖</strong></td>
<td align="left">依赖分辨率（放大失真）</td>
<td align="center">独立分辨率（无限缩放不失真）</td>
</tr>
<tr>
<td align="left"><strong>事件处理</strong></td>
<td align="left">需手动计算坐标（无内置事件）</td>
<td align="center">支持 DOM 事件（如 click&#x2F;hover）</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">适合高频重绘（如游戏&#x2F;动画）</td>
<td align="center">元素过多时性能下降</td>
</tr>
<tr>
<td align="left"><strong>输出格式</strong></td>
<td align="left">生成 PNG&#x2F;JPG</td>
<td align="center">XML 文本（可被 CSS&#x2F;JS 操作）</td>
</tr>
<tr>
<td align="left"><strong>文本渲染</strong></td>
<td align="left">支持基础文本（无富文本）</td>
<td align="center">支持完整文本操作（含 CSS 样式）</td>
</tr>
<tr>
<td align="left"><strong>内存占用</strong></td>
<td align="left">低（无对象存储）</td>
<td align="center">高（每个元素占用 DOM 节点）</td>
</tr>
</tbody></table>
<h2 id="src和href的区别"><a href="#src和href的区别" class="headerlink" title="src和href的区别"></a>src和href的区别</h2><p><strong>src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</strong> </p>
<p>（1）src</p>
<p>src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src =”js.<span class="property">js</span>”&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js 脚本放在底部而不是头部。 </p>
<p>（2）href</p>
<p>href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果在文档中添加 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link href=”common.<span class="property">css</span>” rel=”stylesheet”/&gt;</span><br></pre></td></tr></table></figure>

<p>那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。</p>
<h2 id="常⽤的meta标签有哪些"><a href="#常⽤的meta标签有哪些" class="headerlink" title="常⽤的meta标签有哪些"></a>常⽤的meta标签有哪些</h2><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。</p>
<p>常用的meta标签：</p>
<p>（1）<code>charset</code>，用来描述HTML文档的编码类型：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>（2） <code>keywords</code>，页面关键词：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;关键词&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（3）<code>description</code>，页面描述：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;页面描述内容&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（4）<code>refresh</code>，页面重定向和刷新：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;0;url=&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li><code>width viewport</code> ：宽度(数值&#x2F;device-width)</li>
<li><code>height viewport</code> ：高度(数值&#x2F;device-height)</li>
<li><code>initial-scale</code> ：初始缩放比例</li>
<li><code>maximum-scale</code> ：最大缩放比例</li>
<li><code>minimum-scale</code> ：最小缩放比例</li>
<li><code>user-scalable</code> ：是否允许用户缩放(yes&#x2F;no）</li>
</ul>
<p>（6）搜索引擎索引方式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;index,follow&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li><code>all</code>：文件将被检索，且页面上的链接可以被查询；</li>
<li><code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li>
<li><code>index</code>：文件将被检索；</li>
<li><code>follow</code>：页面上的链接可以被查询；</li>
<li><code>noindex</code>：文件将不被检索；</li>
<li><code>nofollow</code>：页面上的链接不可以被查询</li>
</ul>
<h2 id="iframe-有那些优点和缺点？"><a href="#iframe-有那些优点和缺点？" class="headerlink" title="iframe 有那些优点和缺点？"></a><strong>iframe 有那些优点和缺点？</strong></h2><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p>
<p><strong>优点：</strong></p>
<ul>
<li>用来加载速度较慢的内容（如广告）</li>
<li>可以使脚本可以并行下载</li>
<li>可以实现跨子域通信</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>iframe 会阻塞主页面的 onload 事件</li>
<li>无法被一些搜索引擎索识别</li>
<li>会产生很多页面，不容易管理</li>
</ul>
<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS三大特性"><a href="#CSS三大特性" class="headerlink" title="CSS三大特性"></a>CSS三大特性</h2><p><strong>1、层叠性（Cascading）</strong></p>
<p><strong>定义</strong>：当多个 CSS 规则作用于同一元素时，浏览器根据特定规则”层叠”这些样式，最终确定生效的样式。</p>
<p><strong>核心规则</strong>（按顺序判断）：</p>
<ol>
<li><p><strong>来源顺序</strong>：后出现的规则覆盖先出现的规则</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p &#123; color: blue; &#125;</span><br><span class="line">p &#123; color: red; &#125; /* 最终生效 */</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>来源重要性</strong>（优先级从低到高）：</p>
<ul>
<li>浏览器默认样式</li>
<li>用户样式表（普通）</li>
<li>作者样式表（开发者写的普通样式）</li>
<li>作者样式表（<code>!important</code>）</li>
<li>用户样式表（<code>!important</code>）</li>
</ul>
</li>
<li><p><strong><code>!important</code> 标志</strong>：打破常规优先级</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: blue <span class="meta">!important</span>; <span class="comment">/* 最终生效 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.special</span> &#123; </span><br><span class="line">  <span class="attribute">color</span>: red; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>2、继承性（Inheritance）</strong></p>
<p><strong>定义</strong>：某些 CSS 属性会自动从父元素传递到子元素。</p>
<p><strong>核心特点</strong>：</p>
<ol>
<li><p><strong>可继承属性</strong>（约 30%）：</p>
<ul>
<li>文本相关：<code>font-family</code>, <code>color</code>, <code>line-height</code>, <code>text-align</code></li>
<li>列表相关：<code>list-style-type</code></li>
<li>可见性：<code>visibility</code></li>
<li>表格边框：<code>border-collapse</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: blue&quot;</span>&gt;</span></span><br><span class="line">  父元素文字</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>子元素继承蓝色文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 自动继承 color 属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>不可继承属性</strong>（约 70%）：</p>
<ul>
<li>盒模型：<code>width</code>, <code>height</code>, <code>margin</code>, <code>padding</code>, <code>border</code></li>
<li>定位：<code>position</code>, <code>top</code>, <code>left</code></li>
<li>背景：<code>background-color</code></li>
</ul>
</li>
<li><p><strong>强制继承</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.child &#123;</span><br><span class="line">  border: inherit; /* 强制继承父元素的边框 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>3、优先级（Specificity）</strong></p>
<p><strong>定义</strong>：当多个选择器作用于同一元素时，通过权重计算确定哪个规则生效。</p>
<p><strong>权重计算规则</strong>（从高到低）：</p>
<table>
<thead>
<tr>
<th align="left">选择器类型</th>
<th align="left">示例</th>
<th align="left">权重值（a,b,c,d）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">行内样式</td>
<td align="left"><code>style=&quot;...&quot;</code></td>
<td align="left">1,0,0,0</td>
</tr>
<tr>
<td align="left">ID 选择器</td>
<td align="left"><code>#header</code></td>
<td align="left">0,1,0,0</td>
</tr>
<tr>
<td align="left">类&#x2F;伪类&#x2F;属性选择器</td>
<td align="left"><code>.btn</code>, <code>:hover</code></td>
<td align="left">0,0,1,0</td>
</tr>
<tr>
<td align="left">元素&#x2F;伪元素选择器</td>
<td align="left"><code>div</code>, <code>::before</code></td>
<td align="left">0,0,0,1</td>
</tr>
<tr>
<td align="left">通配符&#x2F;关系选择器</td>
<td align="left"><code>*</code>, <code>&gt;</code>, <code>+</code></td>
<td align="left">0,0,0,0</td>
</tr>
</tbody></table>
<p><strong>计算示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#nav .item:hover &#123;&#125;   /* 权重：0,1,2,0 (ID×1 + 类×2) */</span><br><span class="line">header#top h1.title &#123;&#125; /* 权重：0,1,1,2 (ID×1 + 类×1 + 元素×2) */</span><br></pre></td></tr></table></figure>

<p><strong>比较规则</strong>：</p>
<ol>
<li>从左到右逐级比较：<code>a</code> &gt; <code>b</code> &gt; <code>c</code> &gt; <code>d</code></li>
<li><code>!important</code> &gt; 行内样式 &gt; ID &gt; 类 &gt; 元素</li>
<li>相同权重时，后定义的生效</li>
</ol>
<h2 id="CSS选择器与优先级"><a href="#CSS选择器与优先级" class="headerlink" title="CSS选择器与优先级"></a><strong>CSS选择器与优先级</strong></h2><ul>
<li>!important声明的样式的优先级最高；</li>
<li>如果优先级相同，则最后出现的样式生效；</li>
<li>继承得到的样式的优先级最低；</li>
<li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li>
<li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li>
</ul>
<h2 id="display的属性值及其作用"><a href="#display的属性值及其作用" class="headerlink" title="display的属性值及其作用"></a>display的属性值及其作用</h2><table>
<thead>
<tr>
<th><strong>属性值</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>元素不显示，并且会从文档流中移除。</td>
</tr>
<tr>
<td>block</td>
<td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td>
</tr>
<tr>
<td>inline</td>
<td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td>
</tr>
<tr>
<td>inline-block</td>
<td>默认宽度为内容宽度，可以设置宽高，同行显示。</td>
</tr>
<tr>
<td>list-item</td>
<td>像块类型元素一样显示，并添加样式列表标记。</td>
</tr>
<tr>
<td>table</td>
<td>此元素会作为块级表格来显示。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承display属性的值。</td>
</tr>
</tbody></table>
<h3 id="display的block、inline和inline-block的区别"><a href="#display的block、inline和inline-block的区别" class="headerlink" title="display的block、inline和inline-block的区别"></a>display的block、inline和inline-block的区别</h3><p>　（1）**block：**会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p>
<p>　（2）**inline：**元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p>
<p>　（3）**inline-block：**将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>block (块级)</strong></th>
<th align="left"><strong>inline (行内)</strong></th>
<th align="center"><strong>inline-block (行内块)</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>是否独占一行</strong></td>
<td align="left">✅ 独占整行</td>
<td align="left">❌ 与其他行内元素共享一行</td>
<td align="center">❌ 与其他行内元素共享一行</td>
</tr>
<tr>
<td align="left"><strong>尺寸设置</strong></td>
<td align="left">✅ 可设置宽高，默认撑开父元素宽度由</td>
<td align="left">❌ 默认宽高由内容决定</td>
<td align="center">✅ 可设置宽高，默认宽高由内容决定</td>
</tr>
<tr>
<td align="left"><strong>盒模型属性</strong></td>
<td align="left">✅ 完整 margin&#x2F;padding</td>
<td align="left">❌ 仅水平方向 margin&#x2F;padding</td>
<td align="center">✅ 完整 margin&#x2F;padding</td>
</tr>
<tr>
<td align="left"><strong>默认排列方式</strong></td>
<td align="left">垂直堆叠</td>
<td align="left">水平排列</td>
<td align="center">水平排列</td>
</tr>
<tr>
<td align="left"><strong>包含关系</strong></td>
<td align="left">可包含其他块级&#x2F;行内元素</td>
<td align="left">只能包含行内元素</td>
<td align="center">可包含其他块级&#x2F;行内元素</td>
</tr>
<tr>
<td align="left"><strong>典型默认元素</strong></td>
<td align="left"><code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;-&lt;h6&gt;</code></td>
<td align="left"><code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code></td>
<td align="center"><code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;button&gt;</code></td>
</tr>
</tbody></table>
<p><img src="/../img/23353.jpg"></p>
<p><strong>1. 空白间隙问题 (inline-block)</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Item1<span class="tag">&lt;/<span class="name">span</span>&gt;</span>  <span class="comment">&lt;!-- 这里有换行符 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Item2<span class="tag">&lt;/<span class="name">span</span>&gt;</span>   <span class="comment">&lt;!-- 显示时产生 4px 间隙 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong>：</p>
<ul>
<li>父元素设置 <code>font-size: 0</code>（需重置子元素字体）</li>
<li>使用负 margin：<code>margin-right: -4px</code></li>
<li>删除 HTML 标签间的空白</li>
</ul>
<p><strong>2.垂直对齐控制</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inline-block</span> &#123;</span><br><span class="line">  <span class="attribute">vertical-align</span>: top; <span class="comment">/* 可选值: top/middle/bottom */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 行内元素边距陷阱</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>链接2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">a</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin</span>: <span class="number">20px</span>; <span class="comment">/* 仅左右生效，上下无效！ */</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">padding</span>: <span class="number">10px</span>; <span class="comment">/* 上下padding会覆盖其他行但无位移 */</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><p>作用：<strong>选中特殊状态的元素</strong> </p>
<p>如何理解“伪” ? — 虚假的，不是真的。 </p>
<p>如何理解“伪类”？</p>
<ol>
<li>— 像类( class )，但不是类，是元素的一种特殊状态。</li>
</ol>
<p>常用的伪类选择器： </p>
<p>一、动态伪类： </p>
<p>:link 超链接未被访问的状态。</p>
<p>:visited 超链接访问过的状态。 </p>
<p>:hover 鼠标悬停在元素上的状态。</p>
<p>:active 元素激活的状态。 什么是激活？—— 按下鼠标不松开。注意点：遵循 LVHA 的顺序，即： link 、 visited 、 hover 、 active 。 </p>
<p>:focus 获取焦点的元素。 </p>
<p>表单类元素才能使用 :focus 伪类。 当用户：点击元素、触摸元素、或通过键盘的 “ tab ” 键等方式，选择元素时，就是获 得焦点。 </p>
<p>二、结构伪类 </p>
<ol>
<li><p>:first-child 所有兄弟元素中的第一个。</p>
</li>
<li><p>:last-child 所有兄弟元素中的最后一个。</p>
</li>
<li><p>:nth-child(n) 所有兄弟元素中的第 n 个。 </p>
</li>
<li><p>:first-of-type 所有同类型兄弟元素中的第一个。 </p>
</li>
<li><p>:last-of-type 所有同类型兄弟元素中的最后一个。 </p>
</li>
<li><p>:nth-of-type(n) 所有同类型兄弟元素中的 第n个 。 </p>
<p>关于 n 的值： 1. 0 或 不写 ：什么都选不中 —— 几乎不用。 2. n ：选中所有子元素 —— 几乎不用。 3. 1~正无穷的整数 ：选中对应序号的子元素。 4. 2n 或 even ：选中序号为偶数的子元素。 5. 2n+1 或 odd ：选中序号为奇数的子元素。 6. -n+3 ：选中的是前 3 个。 div[title^&#x3D;”a”]{color:red;} &#x2F;* 选中title属性值以u结尾的元素 <em>&#x2F; div[title$&#x3D;”u”]{color:red;} &#x2F;</em> 选中title属性值包含g的元素 <em>&#x2F; div[title</em>&#x3D;”g”]{color:red;} 了解即可： 1. :nth-last-child(n) 所有兄弟元素中的倒数第 n 个。 2. :nth-last-of-type(n) 所有同类型兄弟元素中的 倒数第n个 。 3. :only-child 选择没有兄弟的元素（独生子女）。 4. :only-of-type 选择没有同类型兄弟的元素。 5. :root 根元素。 6. :empty 内容为空元素（空格也算内容）。 </p>
<p>三、否定伪类： :not(选择器) 排除满足括号中条件的元素。</p>
<p>四、UI伪类： </p>
<ol>
<li><p>:checked 被选中的复选框或单选按钮。 </p>
</li>
<li><p>:enable 可用的表单元素（没有 disabled 属性）。 </p>
</li>
<li><p>:disabled 不可用的表单元素（有 disabled 属性）。</p>
</li>
</ol>
</li>
</ol>
<p>​      </p>
<pre><code>  五、目标伪类（了解） :target 选中锚点指向的元素。 

  六、语言伪类（了解） :lang() 根据指定的语言选择元素（本质是看 lang 属性的值）。
</code></pre>
<h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><p><img src="/../img/13609.jpg"></p>
<h2 id="百分比计算规则"><a href="#百分比计算规则" class="headerlink" title="百分比计算规则"></a>百分比计算规则</h2><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">百分比计算基础</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>width</code></td>
<td align="left">父元素的内容宽度</td>
<td align="left">父元素width: 600px，子元素width: 50% → 300px</td>
</tr>
<tr>
<td align="left"><code>height</code></td>
<td align="left">父元素的内容高度</td>
<td align="left">父元素height: 400px，子元素height: 50% → 200px</td>
</tr>
<tr>
<td align="left"><code>padding</code></td>
<td align="left">父元素的内容宽度</td>
<td align="left">父元素width: 800px，padding: 10% → 80px</td>
</tr>
<tr>
<td align="left"><code>margin</code></td>
<td align="left">父元素的内容宽度</td>
<td align="left">父元素width: 1000px，margin: 5% → 50px</td>
</tr>
<tr>
<td align="left"><code>top/bottom</code></td>
<td align="left">包含块的高度</td>
<td align="left">包含块height: 500px，top: 20% → 100px</td>
</tr>
<tr>
<td align="left"><code>left/right</code></td>
<td align="left">包含块的宽度</td>
<td align="left">包含块width: 1200px，left: 15% → 180px</td>
</tr>
<tr>
<td align="left"><code>font-size</code></td>
<td align="left">父元素的字体大小</td>
<td align="left">父元素font-size: 16px，子元素font-size: 150% → 24px</td>
</tr>
<tr>
<td align="left"><code>line-height</code></td>
<td align="left">元素自身的字体大小</td>
<td align="left">元素font-size: 20px，line-height: 150% → 30px</td>
</tr>
<tr>
<td align="left"><code>background-position</code></td>
<td align="left">(容器尺寸 - 背景图尺寸)</td>
<td align="left">容器宽度1000px，图片宽度800px，background-position: 50% → 100px</td>
</tr>
<tr>
<td align="left"><code>transform: translate()</code></td>
<td align="left">元素自身的尺寸</td>
<td align="left">元素width: 200px，translateX(50%) → 100px</td>
</tr>
<tr>
<td align="left"><code>border-radius</code></td>
<td align="left">元素自身的尺寸</td>
<td align="left">元素200px×100px，border-radius: 50% → 100px&#x2F;50</td>
</tr>
</tbody></table>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>margin（外边距）： 盒子与外界的距离。 </p>
<ul>
<li>子元素的 margin ，是参考父元素的 content 计算的。（因为是父亲的 content 中承装着 子元素） </li>
<li>上 margin 、左 margin ：影响自己的位置；下 margin 、右 margin ：影响后面兄弟元素 的位置。 </li>
<li>块级元素、行内块元素，均可以完美地设置四个方向的 margin ；但行内元素，左右 margin 可以完美设置，上下 margin 设置无效。 </li>
<li>margin 的值也可以是 auto ，如果给一个块级元素设置左右 margin 都为 auto ，该块级 元素会在父元素中水平居中。 </li>
<li><strong>margin 的值可以是负值。</strong></li>
</ul>
<p><img src="/../img/14468.jpg"></p>
<p>border（边框）： 盒子的边框。 </p>
<p>padding（内边距）： 紧贴内容的补白区域。 </p>
<ul>
<li><strong>padding 的值不能为负数</strong> </li>
<li>行内元素 的 左右内边距是没问题的，上下内边距不能完美的设置。 </li>
<li>块级元素、行内块元素，四个方向内边距都可以完美设置<br><strong>百分比计算来源为父元素宽度</strong></li>
</ul>
<p>content（内容）：元素中的文本或后代元素都是它的内容。</p>
<p><img src="C:\Users\Zhangwenye\Desktop\博客\source\img\4611.jpg"></p>
<h2 id="文本溢出"><a href="#文本溢出" class="headerlink" title="文本溢出"></a>文本溢出</h2><ul>
<li>单行文本溢出</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;      // 溢出用省略号显示</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;         // 规定段落中的文本不进行换行</span><br></pre></td></tr></table></figure>

<ul>
<li>多行文本溢出</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;            // 溢出隐藏</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;     // 溢出用省略号显示</span><br><span class="line"><span class="attribute">display</span>:-webkit-box;         // 作为弹性伸缩盒子模型显示。</span><br><span class="line">-webkit-<span class="attribute">box-orient</span>:vertical; // 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br><span class="line">-webkit-<span class="selector-tag">line</span>-clamp:<span class="number">3</span>;        // 显示的行数</span><br></pre></td></tr></table></figure>

<p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器</p>
<h2 id="CSS中可继承与不可继承属性"><a href="#CSS中可继承与不可继承属性" class="headerlink" title="CSS中可继承与不可继承属性"></a>CSS中可继承与不可继承属性</h2><p><strong>一、无继承性的属性</strong></p>
<ol>
<li><strong>display</strong>：规定元素应该生成的框的类型</li>
<li><strong>文本属性</strong>：</li>
</ol>
<ul>
<li>vertical-align：垂直文本对齐</li>
<li>text-decoration：规定添加到文本的装饰</li>
<li>text-shadow：文本阴影效果</li>
<li>white-space：空白符的处理</li>
<li>unicode-bidi：设置文本的方向</li>
</ul>
<ol>
<li><strong>盒子模型的属性</strong>：width、height、margin、border、padding</li>
<li><strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li>
<li><strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li>
<li><strong>生成内容属性</strong>：content、counter-reset、counter-increment</li>
<li><strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li>
<li><strong>页面样式属性</strong>：size、page-break-before、page-break-after</li>
<li><strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li>
</ol>
<p><strong>二、有继承性的属性</strong></p>
<ol>
<li><strong>字体系列属性</strong></li>
</ol>
<ul>
<li>font-family：字体系列</li>
<li>font-weight：字体的粗细</li>
<li>font-size：字体的大小</li>
<li>font-style：字体的风格</li>
</ul>
<ol>
<li><strong>文本系列属性</strong></li>
</ol>
<ul>
<li>text-indent：文本缩进</li>
<li>text-align：文本水平对齐</li>
<li>line-height：行高</li>
<li>word-spacing：单词之间的间距</li>
<li>letter-spacing：中文或者字母之间的间距</li>
<li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li>
<li>color：文本颜色</li>
</ul>
<ol>
<li><strong>元素可见性</strong></li>
</ol>
<ul>
<li>visibility：控制元素显示隐藏</li>
</ul>
<ol>
<li><strong>列表布局属性</strong></li>
</ol>
<ul>
<li>list-style：列表风格，包括list-style-type、list-style-image等</li>
</ul>
<ol>
<li><strong>光标属性</strong></li>
</ol>
<ul>
<li>cursor：光标显示为何种形态</li>
</ul>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><ul>
<li>脱离文档流</li>
<li>不管浮动前是什么元素，浮动后：默认宽与高都是被内容撑开（尽可能小），而且可以设置宽高</li>
<li>不会独占一行，可以与其他元素共用一行 </li>
<li>不会 margin 合并，也不会 margin 塌陷，能够完美的设置四个方向的 margin 和 padding </li>
<li>不会像行内块一样被当做文本处理（没有行内块的空白问题）</li>
</ul>
<p><strong>元素浮动后会有哪些影响</strong><br>对兄弟元素的影响： 后面的兄弟元素，会占据浮动元素之前的位置，在浮动元素的下面；对前面的兄弟无影响。 </p>
<p>对父元素的影响： 不能撑起父元素的高度，导致父元素高度塌陷；但父元素的宽度依然束缚浮动的元素。 </p>
<p><strong>解决浮动产生的影响（清除浮动）</strong><br>解决方案： </p>
<ul>
<li>方案一： 给父元素指定高度 </li>
<li>方案二： 给父元素也设置浮动，带来其他影响</li>
<li>方案三： 给父元素设置 overflow:hidden </li>
<li>方案四： 在所有浮动元素的最后面，添加一个块级元素，并给该块级元素设置 clear:both </li>
<li>方案五： 给浮动元素的父元素，设置伪元素，通过伪元素清除浮动，原理与方案四相同。&#x3D;&#x3D;&#x3D;&gt; 推 荐使用 布局中的一个原则：设置浮动的时候，兄弟元素要么全都浮动，要么全都不浮动</li>
</ul>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><table>
<thead>
<tr>
<th align="left">定位类型</th>
<th align="left">定位基准</th>
<th align="left">是否脱离文档流</th>
<th align="left">特点</th>
<th align="left">常见应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>static</strong></td>
<td align="left">正常文档流</td>
<td align="left">否</td>
<td align="left">默认定位，不受 top&#x2F;right&#x2F;bottom&#x2F;left 影响</td>
<td align="left">普通文档流布局</td>
</tr>
<tr>
<td align="left"><strong>relative</strong></td>
<td align="left">自身原始位置</td>
<td align="left">否</td>
<td align="left">保留原始空间，相对自身偏移</td>
<td align="left">微调元素位置，作为 absolute 的参照</td>
</tr>
<tr>
<td align="left"><strong>absolute</strong></td>
<td align="left">最近的定位祖先元素</td>
<td align="left">是</td>
<td align="left">完全脱离文档流，不保留空间</td>
<td align="left">弹出层、下拉菜单、图标定位</td>
</tr>
<tr>
<td align="left"><strong>fixed</strong></td>
<td align="left">浏览器视口</td>
<td align="left">是</td>
<td align="left">固定于视口位置，不随滚动移动</td>
<td align="left">固定导航栏、悬浮按钮</td>
</tr>
<tr>
<td align="left"><strong>sticky</strong></td>
<td align="left">最近的滚动祖先</td>
<td align="left">否（直到达到阈值）</td>
<td align="left">混合定位，达到阈值后固定</td>
<td align="left">粘性导航、表头固定</td>
</tr>
</tbody></table>
<h3 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h3><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：</p>
<p><img src="/../img/132257ri1tw184gtv3vu8t.png" alt="img"></p>
<p>对于上图，由上到下分别是：</p>
<p>（1）背景和边框：建立当前层叠上下文元素的背景和边框。</p>
<p>（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。</p>
<p>（3）块级盒：文档流内非行内级非定位后代元素。</p>
<p>（4）浮动盒：非定位浮动元素。</p>
<p>（5）行内盒：文档流内行内级非定位后代元素。</p>
<p>（6）z-index:0：层叠级数为0的定位元素。</p>
<p>（7）正z-index：z-index属性值为正的定位元素。</p>
<p>使用clear:both吧。</p>
<p>一般使用伪元素的方式清除浮动：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clear</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block; </span><br><span class="line">  <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p>
<h2 id="对BFC的理解，如何创建BFC"><a href="#对BFC的理解，如何创建BFC" class="headerlink" title="对BFC的理解，如何创建BFC"></a>对BFC的理解，如何创建BFC</h2><p>先来看两个相关的概念：</p>
<ul>
<li>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。 </li>
<li>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li>
</ul>
<p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>
<p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p>
<p><strong>创建BFC的条件：</strong></p>
<ul>
<li>根元素：body；</li>
<li>元素设置浮动：float 除 none 以外的值；</li>
<li>元素设置绝对定位：position (absolute、fixed)；</li>
<li>display 值为：inline-block、table-cell、table-caption、flex等；</li>
<li>overflow 值为：hidden、auto、scroll；</li>
</ul>
<p><strong>BFC的特点：</strong></p>
<ul>
<li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li>
<li>在BFC中上下相邻的两个容器的margin会重叠</li>
<li>计算BFC的高度时，需要计算浮动元素的高度</li>
<li>BFC区域不会与浮动的容器发生重叠</li>
<li>BFC是独立的容器，容器内部元素不会影响外部元素</li>
<li>每个元素的左margin值和容器的左border相接触</li>
</ul>
<p><strong>BFC的作用：</strong></p>
<ul>
<li><strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li>
<li><strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li>
<li><strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">     <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">     <span class="attribute">background</span>: red;</span><br><span class="line">     <span class="attribute">float</span>: left;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="selector-class">.right</span>&#123;</span><br><span class="line">     <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">     <span class="attribute">background</span>: blue;</span><br><span class="line">     <span class="attribute">overflow</span>: hidden;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">left</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;<span class="attribute">right</span>&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p>
<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><ol>
<li><strong>GPU 加速</strong>：<ul>
<li>Transform 操作由 GPU 处理，不占用主线程资源</li>
<li>特别适合动画和复杂视觉效果</li>
<li>使用 <code>translate3d()</code> 或 <code>will-change</code> 可以强制启用 GPU 加速</li>
</ul>
</li>
<li><strong>不触发重排（Reflow）</strong>：<ul>
<li>应用 transform 时，浏览器跳过布局（Layout）阶段</li>
<li>元素在文档流中的位置保持不变</li>
<li>只影响元素的视觉效果，不影响布局</li>
</ul>
</li>
<li><strong>高性能动画</strong>：<ul>
<li>与 CSS transitions&#x2F;animations 结合性能极佳</li>
<li>60fps 流畅动画的理想选择</li>
<li>特别适合移动端性能优化</li>
</ul>
</li>
</ol>
<h3 id="与其他位移属性的性能对比"><a href="#与其他位移属性的性能对比" class="headerlink" title="与其他位移属性的性能对比"></a>与其他位移属性的性能对比</h3><table>
<thead>
<tr>
<th align="left">属性类型</th>
<th align="left">触发重排</th>
<th align="left">触发重绘</th>
<th align="left">性能影响</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Transform</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">最小</td>
<td align="left">动画、交互效果、视觉变换</td>
</tr>
<tr>
<td align="left"><strong>Position</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">中等</td>
<td align="left">静态定位、布局元素</td>
</tr>
<tr>
<td align="left"><strong>Margin</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">最大</td>
<td align="left">元素间距调整</td>
</tr>
<tr>
<td align="left"><strong>Padding</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">大</td>
<td align="left">内容内边距</td>
</tr>
<tr>
<td align="left"><strong>Left&#x2F;Top</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">中等</td>
<td align="left">绝对定位元素移动</td>
</tr>
</tbody></table>
<h3 id="浏览器渲染流程与性能"><a href="#浏览器渲染流程与性能" class="headerlink" title="浏览器渲染流程与性能"></a>浏览器渲染流程与性能</h3><ol>
<li><strong>渲染流水线</strong>：<ul>
<li>JavaScript → 样式计算 → 布局 → 绘制 → 合成</li>
<li>Transform 操作只在合成阶段处理</li>
<li>其他位移属性会触发布局和绘制阶段</li>
</ul>
</li>
<li><strong>优化建议</strong>：<ul>
<li>使用 <code>transform</code> 和 <code>opacity</code> 制作动画</li>
<li>避免在循环中修改布局属性</li>
<li>使用 <code>will-change</code> 提示浏览器优化</li>
<li>优先使用 CSS 动画而非 JavaScript 动画</li>
</ul>
</li>
</ol>
<h3 id="实际性能差异"><a href="#实际性能差异" class="headerlink" title="实际性能差异"></a>实际性能差异</h3><p>在动画演示中，可以看到：</p>
<ul>
<li><strong>Transform</strong>：性能最优，CPU 使用率最低</li>
<li><strong>Position</strong>：性能中等，会触发重排</li>
<li><strong>Margin</strong>：性能最差，导致完整文档重排</li>
</ul>
<h2 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h2><p>Flex 布局（弹性盒子布局）是 CSS3 中一种强大的<strong>一维布局模型</strong>，专门设计用于在<strong>单行或单列</strong>中高效分配容器空间。它解决了传统布局（如浮动和定位）的诸多痛点，特别适合构建<strong>响应式界面</strong>和<strong>复杂组件</strong>。</p>
<ul>
<li><strong>Flex 容器</strong>：应用 <code>display: flex</code> 的元素</li>
<li><strong>Flex 项目</strong>：容器内的直接子元素</li>
<li><strong>主轴 (Main Axis)</strong>：项目排列的主要方向（由 <code>flex-direction</code> 定义）</li>
<li><strong>交叉轴 (Cross Axis)</strong>：与主轴垂直的方向</li>
</ul>
<p><strong>二、Flex 容器属性详解</strong></p>
<ol>
<li><code>display</code> - 定义容器类型</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex; <span class="comment">/* 块级 flex 容器 */</span></span><br><span class="line">  <span class="attribute">display</span>: inline-flex; <span class="comment">/* 行内 flex 容器 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>flex-direction</code> - 主轴方向</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row; <span class="comment">/* 默认值，水平从左到右 */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>: row-reverse; <span class="comment">/* 水平从右到左 */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>: column; <span class="comment">/* 垂直从上到下 */</span></span><br><span class="line">  <span class="attribute">flex-direction</span>: column-reverse; <span class="comment">/* 垂直从下到上 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>flex-wrap</code> - 换行控制</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  flex-wrap: nowrap; /* 默认不换行 */</span><br><span class="line">  flex-wrap: wrap; /* 正常换行 */</span><br><span class="line">  flex-wrap: wrap-reverse; /* 反向换行 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>flex-flow</code> - 方向与换行的简写</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap; <span class="comment">/* 方向 + 换行 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>justify-content</code> - 主轴对齐</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start; <span class="comment">/* 默认，起点对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: flex-end; <span class="comment">/* 终点对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 居中对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-between; <span class="comment">/* 两端对齐 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-around; <span class="comment">/* 均匀分布 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-evenly; <span class="comment">/* 完全均匀 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>align-items</code> - 交叉轴对齐（单行）</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: stretch; <span class="comment">/* 默认，拉伸填满 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: flex-start; <span class="comment">/* 起点对齐 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: flex-end; <span class="comment">/* 终点对齐 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/* 居中对齐 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: baseline; <span class="comment">/* 基线对齐 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><code>align-content</code> - 交叉轴对齐（多行）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  align-content: stretch; /* 默认，拉伸填满 */</span><br><span class="line">  align-content: flex-start; /* 起点对齐 */</span><br><span class="line">  align-content: flex-end; /* 终点对齐 */</span><br><span class="line">  align-content: center; /* 居中对齐 */</span><br><span class="line">  align-content: space-between; /* 两端对齐 */</span><br><span class="line">  align-content: space-around; /* 均匀分布 */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>三、Flex 项目属性详解</strong></p>
<ol>
<li><code>order</code> - 项目顺序</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: <span class="number">0</span>; <span class="comment">/* 默认值 */</span></span><br><span class="line">  <span class="attribute">order</span>: <span class="number">1</span>; <span class="comment">/* 值越大越靠后 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>flex-grow</code> - 扩展比例</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">0</span>; <span class="comment">/* 默认不扩展 */</span></span><br><span class="line">  <span class="attribute">flex-grow</span>: <span class="number">1</span>; <span class="comment">/* 按比例分配剩余空间 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>flex-shrink</code> - 收缩比例</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">1</span>; <span class="comment">/* 默认可收缩 */</span></span><br><span class="line">  <span class="attribute">flex-shrink</span>: <span class="number">0</span>; <span class="comment">/* 禁止收缩 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>flex-basis</code> - 初始尺寸</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: auto; <span class="comment">/* 默认，基于内容 */</span></span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">200px</span>; <span class="comment">/* 固定尺寸 */</span></span><br><span class="line">  <span class="attribute">flex-basis</span>: <span class="number">30%</span>; <span class="comment">/* 百分比尺寸 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>flex</code> - 复合属性</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none; <span class="comment">/* 0 0 auto */</span></span><br><span class="line">  <span class="attribute">flex</span>: auto; <span class="comment">/* 1 1 auto */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>; <span class="comment">/* 1 1 0% */</span></span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>; <span class="comment">/* 不扩展不收缩，固定200px */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><code>align-self</code> - 单独对齐</li>
</ol>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto; <span class="comment">/* 继承容器 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: stretch; <span class="comment">/* 拉伸填满 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: flex-start; <span class="comment">/* 顶部对齐 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: flex-end; <span class="comment">/* 底部对齐 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: center; <span class="comment">/* 垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="requestAnimationframe"><a href="#requestAnimationframe" class="headerlink" title="requestAnimationframe"></a>requestAnimationframe</h2><p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是<strong>请求动画帧</strong>。</p>
<p>MDN对该方法的描述：</p>
<p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p>
<p><strong>语法：</strong> <code>window.requestAnimationFrame(callback);</code>  其中，callback是<strong>下一次重绘之前更新动画帧所调用的函数</strong>(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于<strong>宏任务</strong>，所以会在执行完微任务之后再去执行。</p>
<p>**取消动画：**使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p>
<p><strong>优势：</strong></p>
<ul>
<li><strong>CPU节能</strong>：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li>
<li><strong>函数节流</strong>：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li>
<li><strong>减少DOM操作</strong>：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li>
</ul>
<p><strong>setTimeout执行动画的缺点</strong>：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p>
<ul>
<li>settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；</li>
<li>settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li>
</ul>
<h2 id="CSS图片格式对比，应用场景"><a href="#CSS图片格式对比，应用场景" class="headerlink" title="CSS图片格式对比，应用场景"></a>CSS图片格式对比，应用场景</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">JPEG&#x2F;JPG</th>
<th align="left">PNG</th>
<th align="left">GIF</th>
<th align="left">WebP</th>
<th align="left">SVG</th>
<th align="left">AVIF</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>压缩类型</strong></td>
<td align="left">有损</td>
<td align="left">无损</td>
<td align="left">无损</td>
<td align="left">有损&#x2F;无损</td>
<td align="left">无损</td>
<td align="left">有损&#x2F;无损</td>
</tr>
<tr>
<td align="left"><strong>透明度支持</strong></td>
<td align="left">❌</td>
<td align="left">✅ (8&#x2F;24位)</td>
<td align="left">✅ (1位)</td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">✅</td>
</tr>
<tr>
<td align="left"><strong>动画支持</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">✅ (SMIL)</td>
<td align="left">❌</td>
</tr>
<tr>
<td align="left"><strong>颜色深度</strong></td>
<td align="left">24位</td>
<td align="left">8&#x2F;24&#x2F;48位</td>
<td align="left">8位(256色)</td>
<td align="left">24&#x2F;32位</td>
<td align="left">无限</td>
<td align="left">10&#x2F;12位</td>
</tr>
<tr>
<td align="left"><strong>文件大小</strong></td>
<td align="left">小</td>
<td align="left">中-大</td>
<td align="left">小(简单)</td>
<td align="left">很小</td>
<td align="left">极小(简单)</td>
<td align="left">非常小</td>
</tr>
<tr>
<td align="left"><strong>浏览器兼容性</strong></td>
<td align="left">100%</td>
<td align="left">100%</td>
<td align="left">100%</td>
<td align="left">95%+</td>
<td align="left">100%</td>
<td align="left">75%+</td>
</tr>
<tr>
<td align="left"><strong>最佳适用场景</strong></td>
<td align="left">照片</td>
<td align="left">透明图像</td>
<td align="left">简单动画</td>
<td align="left">通用</td>
<td align="left">图标&#x2F;矢量</td>
<td align="left">高清照片</td>
</tr>
</tbody></table>
<p>图片有损压缩与无损压缩的区别详解</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">有损压缩</th>
<th align="left">无损压缩</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>原理</strong></td>
<td align="left">删除人眼不易察觉的冗余数据</td>
<td align="left">通过算法重组数据，不丢失信息</td>
</tr>
<tr>
<td align="left"><strong>图像质量</strong></td>
<td align="left">质量下降，产生压缩伪影</td>
<td align="left">保持原始质量</td>
</tr>
<tr>
<td align="left"><strong>文件大小</strong></td>
<td align="left">压缩率高(可达90%)</td>
<td align="left">压缩率低(通常20-50%)</td>
</tr>
<tr>
<td align="left"><strong>数据恢复</strong></td>
<td align="left">不可恢复原始数据</td>
<td align="left">可完全恢复原始数据</td>
</tr>
<tr>
<td align="left"><strong>常用格式</strong></td>
<td align="left">JPEG, WebP, HEIC</td>
<td align="left">PNG, GIF, BMP, TIFF</td>
</tr>
<tr>
<td align="left"><strong>典型应用</strong></td>
<td align="left">网页图片、社交媒体、数码照片</td>
<td align="left">专业摄影、医学影像、设计素材</td>
</tr>
</tbody></table>
<h2 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h2><h3 id="1-回流与重绘的概念及触发条件"><a href="#1-回流与重绘的概念及触发条件" class="headerlink" title="1. 回流与重绘的概念及触发条件"></a>1. 回流与重绘的概念及触发条件</h3><h4 id="（1）回流"><a href="#（1）回流" class="headerlink" title="（1）回流"></a>（1）回流</h4><p>当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为<strong>回流</strong>。</p>
<p>下面这些操作会导致回流：</p>
<ul>
<li>页面的首次渲染</li>
<li>浏览器的窗口大小发生变化</li>
<li>元素的内容发生变化</li>
<li>元素的尺寸或者位置发生变化</li>
<li>元素的字体大小发生变化</li>
<li>激活CSS伪类</li>
<li>查询某些属性或者调用某些方法</li>
<li>添加或者删除可见的DOM元素</li>
</ul>
<p>在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：</p>
<ul>
<li>全局范围：从根节点开始，对整个渲染树进行重新布局</li>
<li>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</li>
</ul>
<h4 id="（2）重绘"><a href="#（2）重绘" class="headerlink" title="（2）重绘"></a>（2）重绘</h4><p>当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是<strong>重绘</strong>。</p>
<p>下面这些操作会导致重绘：</p>
<ul>
<li>color、background 相关属性：background-color、background-image 等</li>
<li>outline 相关属性：outline-color、outline-width 、text-decoration</li>
<li>border-radius、visibility、box-shadow</li>
</ul>
<p>注意： <strong>当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。</strong></p>
<p>样式设置</p>
<p>1、避免使用层级较深的选择器，或其他一些复杂的选择器，以提高CSS渲染效率</p>
<p>2、避免使用CSS<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=%E8%A1%A8%E8%BE%BE%E5%BC%8F&zhida_source=entity">表达式</a>，CSS表达式是动态设置CSS属性的强大但危险方法，它的问题就在于计算频率很快。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次</p>
<p>3、元素适当地定义高度或最小高度，否则元素的动态内容载入时，会出现页面元素的晃动或位置，造成回流</p>
<p>4、给图片设置尺寸。如果图片不设置尺寸，首次载入时，占据空间会从0到完全出现，上下左右都可能位移，发生回流</p>
<p>5、不要使用table布局，因为一个小改动可能会造成整个table重新布局。而且table渲染通常要3倍于同等元素时间</p>
<p>6、能够使用CSS实现的效果，尽量使用CSS而不使用JS实现</p>
<p><a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=%E6%B8%B2%E6%9F%93%E5%B1%82&zhida_source=entity">渲染层</a></p>
<p>1、此外，将需要多次重绘的元素独立为render layer渲染层，如设置absolute，可以减少重绘范围</p>
<p>2、对于一些进行动画的元素，使用硬件渲染，从而避免重绘和回流</p>
<p>DOM优化</p>
<p>1、缓存DOM</p>
<p>const div &#x3D; document.getElementById(‘div’)</p>
<p>由于查询DOM比较耗时，在同一个节点无需多次查询的情况下，可以缓存DOM</p>
<p>2、减少DOM深度及DOM数量</p>
<p>HTML 中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持 DOM 元素简洁和层级较少。</p>
<p>3、批量操作DOM</p>
<p>　　由于DOM操作比较耗时，且可能会造成回流，因此要避免频繁操作DOM，可以批量操作DOM，先用字符串拼接完毕，再用innerHTML更新DOM</p>
<p>4、批量操作CSS样式</p>
<p>　　通过切换class或者使用元素的style.csstext属性去批量操作元素样式</p>
<p>5、在内存中操作DOM</p>
<p>　　使用DocumentFragment对象，让DOM操作发生在内存中，而不是页面上</p>
<p>6、<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=DOM%E5%85%83%E7%B4%A0&zhida_source=entity">DOM元素</a>离线更新</p>
<p>　　对DOM进行相关操作时，例、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作</p>
<p>7、DOM<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB&zhida_source=entity">读写分离</a></p>
<p>　　浏览器具有惰性渲染机制，连接多次修改DOM可能只触发浏览器的一次渲染。而如果修改DOM后，立即读取DOM。为了保证读取到正确的DOM值，会触发浏览器的一次渲染。因此，修改DOM的操作要与访问DOM分开进行</p>
<p>8、<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86&zhida_source=entity">事件代理</a></p>
<p>　　事件代理是指将事件监听器注册在父级元素上，由于子元素的事件会通过事件冒泡的方式向上传播到父节点，因此，可以由父节点的监听函数统一处理多个子元素的事件</p>
<p>　　利用事件代理，可以减少内存使用，提高性能及降低代码复杂度</p>
<p>9、防抖和节流</p>
<p>　　使用函数节流（throttle）或函数去抖（debounce），限制某一个方法的频繁触发</p>
<p>10、及时清理环境</p>
<p>　　及时消除<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8&zhida_source=entity">对象引用</a>，清除定时器，清除事件监听器，创建最小<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=185471240&content_type=Article&match_order=1&q=%E4%BD%9C%E7%94%A8%E5%9F%9F&zhida_source=entity">作用域</a>变量，可以及时回收内存</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>变量、函数、属性或函数参数的名称。标识符可以由一或多个下列字符组成： </p>
<ul>
<li>第一个字符必须是一个字母、下划线（_）或美元符号（$）； </li>
<li>剩下的其他字符可以是字母、下划线、美元符号或数字。</li>
</ul>
<h2 id="let、const、var的区别"><a href="#let、const、var的区别" class="headerlink" title="let、const、var的区别"></a>let、const、var的区别</h2><p>**（1）块级作用域:**块作用域由 <code>&#123; &#125;</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p>
<ul>
<li>内层变量可能覆盖外层变量</li>
<li>用来计数的循环变量泄露为全局变量</li>
</ul>
<p>**（2）变量提升：**var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p>
<p>**（3）给全局添加属性：**浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p>
<p>**（4）重复声明：**var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p>
<p><strong>（5）暂时性死区：<strong>在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为</strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。</p>
<p>**（6）初始值设置：**在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p>
<p>**（7）指针指向：**let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p>
<table>
<thead>
<tr>
<th><strong>区别</strong></th>
<th><strong>var</strong></th>
<th><strong>let</strong></th>
<th><strong>const</strong></th>
</tr>
</thead>
<tbody><tr>
<td>是否有块级作用域</td>
<td>×</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>是否存在变量提升</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>是否添加全局属性</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>能否重复声明变量</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>是否存在暂时性死区</td>
<td>×</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>是否必须设置初始值</td>
<td>×</td>
<td>×</td>
<td>✔️</td>
</tr>
<tr>
<td>能否改变指针指向</td>
<td>✔️</td>
<td>✔️</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="const对象的属性可以修改吗"><a href="#const对象的属性可以修改吗" class="headerlink" title="const对象的属性可以修改吗"></a>const对象的属性可以修改吗</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p>
<p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Undefined、Null、Boolean、Number、 String 、 Symbol</p>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><strong>typeof 工作机制</strong></p>
<p>JavaScript 使用<strong>类型标签</strong>机制在底层表示值类型：</p>
<ul>
<li><p>值在内存中被表示为 32 位单元</p>
</li>
<li><p>低 1-3 位存储类型标签：</p>
<ul>
<li><p><code>000</code>: 对象</p>
</li>
<li><p><code>001</code>: 整数</p>
</li>
<li><p><code>010</code>: 浮点数</p>
</li>
<li><p><code>100</code>: 字符串</p>
</li>
<li><p><code>110</code>: 布尔值</p>
</li>
<li><p><code>111</code>: 符号</p>
</li>
<li><p><code>-2^30</code>: 特殊值（undefined）、</p>
<p><code>null</code> 值被表示为机器码 <code>0x00000000</code>（全零）<br><code>typeof</code> 检查类型标签时看到 <code>000</code>，判定为对象</p>
</li>
</ul>
</li>
</ul>
<h3 id="typeof-返回值表"><a href="#typeof-返回值表" class="headerlink" title="typeof 返回值表"></a>typeof 返回值表</h3><table>
<thead>
<tr>
<th align="left">值类型</th>
<th align="left">typeof 返回值</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Undefined</td>
<td align="left">“undefined”</td>
<td align="left"><code>typeof undefined</code></td>
</tr>
<tr>
<td align="left">Null</td>
<td align="left">“object”</td>
<td align="left"><code>typeof null</code></td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">“boolean”</td>
<td align="left"><code>typeof true</code></td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">“number”</td>
<td align="left"><code>typeof 42</code></td>
</tr>
<tr>
<td align="left">BigInt</td>
<td align="left">“bigint”</td>
<td align="left"><code>typeof 10n</code></td>
</tr>
<tr>
<td align="left">String</td>
<td align="left">“string”</td>
<td align="left"><code>typeof &quot;hello&quot;</code></td>
</tr>
<tr>
<td align="left">Symbol</td>
<td align="left">“symbol”</td>
<td align="left"><code>typeof Symbol()</code></td>
</tr>
<tr>
<td align="left">Function</td>
<td align="left">“function”</td>
<td align="left"><code>typeof function()&#123;&#125;</code></td>
</tr>
<tr>
<td align="left">其他对象</td>
<td align="left">“object”</td>
<td align="left"><code>typeof &#123;&#125;</code></td>
</tr>
</tbody></table>
<h3 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h3><p>null &#x3D;&#x3D; undefined true</p>
<table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">null</th>
<th align="left">undefined</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>含义</strong></td>
<td align="left">表示<strong>空对象指针</strong></td>
<td align="left">表示<strong>未定义的值</strong></td>
</tr>
<tr>
<td align="left"><strong>类型</strong></td>
<td align="left"><code>object</code> (历史遗留问题)</td>
<td align="left"><code>undefined</code></td>
</tr>
<tr>
<td align="left"><strong>产生场景</strong></td>
<td align="left">开发者显式赋值</td>
<td align="left">JavaScript 引擎自动分配</td>
</tr>
<tr>
<td align="left"><strong>数值转换</strong></td>
<td align="left"><code>Number(null) = 0</code></td>
<td align="left"><code>Number(undefined) = NaN</code></td>
</tr>
<tr>
<td align="left"><strong>典型场景</strong></td>
<td align="left">对象初始化、清除对象引用</td>
<td align="left">变量未初始化、函数无返回值</td>
</tr>
</tbody></table>
<h3 id="转化规则"><a href="#转化规则" class="headerlink" title="转化规则"></a>转化规则</h3><h4 id="转换为-Boolean-类型规则"><a href="#转换为-Boolean-类型规则" class="headerlink" title="转换为 Boolean 类型规则"></a>转换为 Boolean 类型规则</h4><table>
<thead>
<tr>
<th align="left">值类型</th>
<th align="left">转换结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>undefined</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(undefined)</code></td>
</tr>
<tr>
<td align="left"><code>null</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(null)</code></td>
</tr>
<tr>
<td align="left"><code>false</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(false)</code></td>
</tr>
<tr>
<td align="left"><code>0</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(0)</code></td>
</tr>
<tr>
<td align="left"><code>NaN</code></td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(NaN)</code></td>
</tr>
<tr>
<td align="left"><code>&quot;&quot;</code> (空字符串)</td>
<td align="left"><code>false</code></td>
<td align="left"><code>Boolean(&quot;&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>其他所有值</strong></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean(1)</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean(&quot; &quot;)</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean([])</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean(&#123;&#125;)</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>true</code></td>
<td align="left"><code>Boolean(&quot;false&quot;)</code></td>
</tr>
</tbody></table>
<h4 id="转换为-Number-类型规则"><a href="#转换为-Number-类型规则" class="headerlink" title="转换为 Number 类型规则"></a>转换为 Number 类型规则</h4><table>
<thead>
<tr>
<th align="left">值类型</th>
<th align="left">转换结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>undefined</code></td>
<td align="left"><code>NaN</code></td>
<td align="left"><code>Number(undefined)</code></td>
</tr>
<tr>
<td align="left"><code>null</code></td>
<td align="left"><code>0</code></td>
<td align="left"><code>Number(null)</code></td>
</tr>
<tr>
<td align="left"><code>true</code></td>
<td align="left"><code>1</code></td>
<td align="left"><code>Number(true)</code></td>
</tr>
<tr>
<td align="left"><code>false</code></td>
<td align="left"><code>0</code></td>
<td align="left"><code>Number(false)</code></td>
</tr>
<tr>
<td align="left"><code>&quot;&quot;</code> (空字符串)</td>
<td align="left"><code>0</code></td>
<td align="left"><code>Number(&quot;&quot;)</code></td>
</tr>
<tr>
<td align="left"><code>&quot; &quot;</code> (空白字符串)</td>
<td align="left"><code>0</code></td>
<td align="left"><code>Number(&quot; &quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>数字字符串</strong></td>
<td align="left">对应数字</td>
<td align="left"><code>Number(&quot;123&quot;) → 123</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>Number(&quot;12.3&quot;) → 12.3</code></td>
</tr>
<tr>
<td align="left"><strong>非数字字符串</strong></td>
<td align="left"><code>NaN</code></td>
<td align="left"><code>Number(&quot;123abc&quot;)</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"><code>NaN</code></td>
<td align="left"><code>Number(&quot;abc&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>数组</strong></td>
<td align="left">特殊规则</td>
<td align="left"><code>Number([]) → 0</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>Number([1]) → 1</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>Number([1,2]) → NaN</code></td>
</tr>
<tr>
<td align="left"><strong>对象</strong></td>
<td align="left"><code>NaN</code></td>
<td align="left"><code>Number(&#123;&#125;)</code></td>
</tr>
</tbody></table>
<h4 id="转换为-String-类型规则"><a href="#转换为-String-类型规则" class="headerlink" title="转换为 String 类型规则"></a>转换为 String 类型规则</h4><table>
<thead>
<tr>
<th align="left">值类型</th>
<th align="left">转换结果</th>
<th align="left">示例</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>undefined</code></td>
<td align="left"><code>&quot;undefined&quot;</code></td>
<td align="left"><code>String(undefined)</code></td>
</tr>
<tr>
<td align="left"><code>null</code></td>
<td align="left"><code>&quot;null&quot;</code></td>
<td align="left"><code>String(null)</code></td>
</tr>
<tr>
<td align="left"><code>true</code></td>
<td align="left"><code>&quot;true&quot;</code></td>
<td align="left"><code>String(true)</code></td>
</tr>
<tr>
<td align="left"><code>false</code></td>
<td align="left"><code>&quot;false&quot;</code></td>
<td align="left"><code>String(false)</code></td>
</tr>
<tr>
<td align="left"><code>0</code></td>
<td align="left"><code>&quot;0&quot;</code></td>
<td align="left"><code>String(0)</code></td>
</tr>
<tr>
<td align="left"><code>NaN</code></td>
<td align="left"><code>&quot;NaN&quot;</code></td>
<td align="left"><code>String(NaN)</code></td>
</tr>
<tr>
<td align="left"><code>Infinity</code></td>
<td align="left"><code>&quot;Infinity&quot;</code></td>
<td align="left"><code>String(Infinity)</code></td>
</tr>
<tr>
<td align="left"><code>-0</code></td>
<td align="left"><code>&quot;0&quot;</code></td>
<td align="left"><code>String(-0)</code></td>
</tr>
<tr>
<td align="left"><strong>数字</strong></td>
<td align="left">数字字符串</td>
<td align="left"><code>String(123) → &quot;123&quot;</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>String(12.3) → &quot;12.3&quot;</code></td>
</tr>
<tr>
<td align="left"><strong>字符串</strong></td>
<td align="left">原字符串</td>
<td align="left"><code>String(&quot;hello&quot;)</code></td>
</tr>
<tr>
<td align="left"><strong>数组</strong></td>
<td align="left">元素拼接字符串</td>
<td align="left"><code>String([]) → &quot;&quot;</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>String([1]) → &quot;1&quot;</code></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><code>String([1,2]) → &quot;1,2&quot;</code></td>
</tr>
<tr>
<td align="left"><strong>对象</strong></td>
<td align="left"><code>&quot;[object Object]&quot;</code></td>
<td align="left"><code>String(&#123;&#125;)</code></td>
</tr>
</tbody></table>
<h4 id="特殊转换场景规则"><a href="#特殊转换场景规则" class="headerlink" title="特殊转换场景规则"></a>特殊转换场景规则</h4><p><strong>1. 加法运算 (+) 类型转换</strong></p>
<table>
<thead>
<tr>
<th align="left">操作数1类型</th>
<th align="left">操作数2类型</th>
<th align="left">转换规则</th>
<th align="left">示例</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">String</td>
<td align="left">任意类型</td>
<td align="left">都转字符串</td>
<td align="left"><code>&quot;1&quot; + 1</code></td>
<td align="left"><code>&quot;11&quot;</code></td>
</tr>
<tr>
<td align="left">任意类型</td>
<td align="left">String</td>
<td align="left">都转字符串</td>
<td align="left"><code>1 + &quot;1&quot;</code></td>
<td align="left"><code>&quot;11&quot;</code></td>
</tr>
<tr>
<td align="left">Number</td>
<td align="left">Number</td>
<td align="left">数值相加</td>
<td align="left"><code>1 + 1</code></td>
<td align="left"><code>2</code></td>
</tr>
<tr>
<td align="left">Boolean</td>
<td align="left">Number</td>
<td align="left">布尔转数字再相加</td>
<td align="left"><code>true + 1</code></td>
<td align="left"><code>2</code></td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">Number</td>
<td align="left">null转0再相加</td>
<td align="left"><code>null + 1</code></td>
<td align="left"><code>1</code></td>
</tr>
<tr>
<td align="left">undefined</td>
<td align="left">Number</td>
<td align="left">返回 NaN</td>
<td align="left"><code>undefined + 1</code></td>
<td align="left"><code>NaN</code></td>
</tr>
</tbody></table>
<p><strong>2. 相等比较 (&#x3D;&#x3D;) 类型转换</strong></p>
<table>
<thead>
<tr>
<th align="left">比较类型</th>
<th align="left">转换规则</th>
<th align="left">示例</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">null &#x3D;&#x3D; undefined</td>
<td align="left">总是相等</td>
<td align="left"><code>null == undefined</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">数字 &#x3D;&#x3D; 字符串</td>
<td align="left">字符串转数字</td>
<td align="left"><code>1 == &quot;1&quot;</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">布尔 &#x3D;&#x3D; 非布尔</td>
<td align="left">布尔转数字再比较</td>
<td align="left"><code>true == 1</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">对象 &#x3D;&#x3D; 原始值</td>
<td align="left">对象转原始值再比较</td>
<td align="left"><code>[1] == 1</code></td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left">相同类型</td>
<td align="left">直接比较</td>
<td align="left"><code>&quot;1&quot; == &quot;1&quot;</code></td>
<td align="left"><code>true</code></td>
</tr>
</tbody></table>
<h3 id="for…of-与-for…in-对比"><a href="#for…of-与-for…in-对比" class="headerlink" title="for…of 与 for…in 对比"></a>for…of 与 for…in 对比</h3><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">for…of</th>
<th align="left">for…in</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>迭代对象</strong></td>
<td align="left">可迭代对象的值</td>
<td align="left">对象的可枚举属性名</td>
</tr>
<tr>
<td align="left"><strong>返回值</strong></td>
<td align="left">元素值</td>
<td align="left">属性键名</td>
</tr>
<tr>
<td align="left"><strong>适用数据类型</strong></td>
<td align="left">Array, Map, Set, String, TypedArray, NodeList</td>
<td align="left">普通对象, 数组(不推荐)</td>
</tr>
<tr>
<td align="left"><strong>原型链属性</strong></td>
<td align="left">不遍历</td>
<td align="left">会遍历(除非使用 hasOwnProperty)</td>
</tr>
<tr>
<td align="left"><strong>迭代顺序</strong></td>
<td align="left">按元素插入顺序(有序集合)</td>
<td align="left">无保证顺序(依赖于JS引擎实现)</td>
</tr>
<tr>
<td align="left"><strong>Symbol属性</strong></td>
<td align="left">支持迭代 Symbol.iterator</td>
<td align="left">默认不迭代 Symbol 属性</td>
</tr>
<tr>
<td align="left"><strong>空元素处理</strong></td>
<td align="left">跳过数组空位(sparse arrays)</td>
<td align="left">会处理空位(返回 undefined)</td>
</tr>
<tr>
<td align="left"><strong>性能</strong></td>
<td align="left">较高</td>
<td align="left">较低</td>
</tr>
</tbody></table>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><h4 id="数组检测"><a href="#数组检测" class="headerlink" title="数组检测"></a>数组检测</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过Object.prototype.toString.call()做判断</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>,-<span class="number">1</span>) === <span class="string">&#x27;Array&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过原型链做判断</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过ES6的Array.isArray()做判断</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArrray</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过instanceof做判断</span></span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> <span class="title class_">Array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Array.prototype.isPrototypeOf</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(obj)</span><br></pre></td></tr></table></figure>



<h4 id="数组方法详解"><a href="#数组方法详解" class="headerlink" title="数组方法详解"></a>数组方法详解</h4><h5 id="数组方法分类概览"><a href="#数组方法分类概览" class="headerlink" title="数组方法分类概览"></a>数组方法分类概览</h5><table>
<thead>
<tr>
<th align="left"><strong>方法类型</strong></th>
<th align="left"><strong>特点</strong></th>
<th align="left"><strong>代表方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">改变原数组</td>
<td align="left">直接修改数组</td>
<td align="left">push, pop, splice, sort, reverse</td>
</tr>
<tr>
<td align="left">不改变原数组</td>
<td align="left">返回新数组或值</td>
<td align="left">map, filter, slice, concat, reduce</td>
</tr>
<tr>
<td align="left">可中断遍历</td>
<td align="left">可通过返回值提前结束遍历</td>
<td align="left">some, every, find, findIndex</td>
</tr>
<tr>
<td align="left">不可中断遍历</td>
<td align="left">必须完整遍历所有元素</td>
<td align="left">forEach, map, filter, reduce</td>
</tr>
</tbody></table>
<h5 id="原生数组方法详细解析"><a href="#原生数组方法详细解析" class="headerlink" title="原生数组方法详细解析"></a>原生数组方法详细解析</h5><p><strong>1. 改变原数组的方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">参数</th>
<th align="left">是否改变原数组</th>
<th align="left">遍历是否可暂停</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>push</strong></td>
<td align="left">(item1, item2, …, itemN)</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">新数组长度</td>
</tr>
<tr>
<td align="left"><strong>pop</strong></td>
<td align="left">()</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">移除的元素</td>
</tr>
<tr>
<td align="left"><strong>shift</strong></td>
<td align="left">()</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">移除的元素</td>
</tr>
<tr>
<td align="left"><strong>unshift</strong></td>
<td align="left">(item1, item2, …, itemN)</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">新数组长度</td>
</tr>
<tr>
<td align="left"><strong>splice</strong></td>
<td align="left">(start, deleteCount, item1, item2, …, itemN)</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">被删除元素组成的数组</td>
</tr>
<tr>
<td align="left"><strong>sort</strong></td>
<td align="left">[compareFunction(a, b)]</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">排序后的数组</td>
</tr>
<tr>
<td align="left"><strong>reverse</strong></td>
<td align="left">()</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">反转后的数组</td>
</tr>
<tr>
<td align="left"><strong>fill</strong></td>
<td align="left">(value, [start], [end])</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">修改后的数组</td>
</tr>
<tr>
<td align="left"><strong>copyWithin</strong></td>
<td align="left">(target, [start], [end])</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">修改后的数组</td>
</tr>
</tbody></table>
<p><strong>2. 不改变原数组的方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">参数</th>
<th align="left">是否改变原数组</th>
<th align="left">遍历是否可暂停</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>concat</strong></td>
<td align="left">(array1, array2, …, arrayN)</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">合并后的新数组</td>
</tr>
<tr>
<td align="left"><strong>slice</strong></td>
<td align="left">([start], [end])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">提取元素组成的新数组</td>
</tr>
<tr>
<td align="left"><strong>join</strong></td>
<td align="left">([separator])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">连接后的字符串</td>
</tr>
<tr>
<td align="left"><strong>toString</strong></td>
<td align="left">()</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">数组的字符串表示</td>
</tr>
<tr>
<td align="left"><strong>indexOf</strong></td>
<td align="left">(searchElement, [fromIndex])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">元素的索引或 -1</td>
</tr>
<tr>
<td align="left"><strong>lastIndexOf</strong></td>
<td align="left">(searchElement, [fromIndex])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">元素的索引或 -1</td>
</tr>
<tr>
<td align="left"><strong>includes</strong></td>
<td align="left">(searchElement, [fromIndex])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left"><strong>map</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">处理后的新数组</td>
</tr>
<tr>
<td align="left"><strong>filter</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">过滤后的新数组</td>
</tr>
<tr>
<td align="left"><strong>reduce</strong></td>
<td align="left">(callback(acc, current, index, array), [initialValue])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">累计结果值</td>
</tr>
<tr>
<td align="left"><strong>reduceRight</strong></td>
<td align="left">(callback(acc, current, index, array), [initialValue])</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">累计结果值</td>
</tr>
</tbody></table>
<p><strong>3. 可中断遍历的方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">参数</th>
<th align="left">是否改变原数组</th>
<th align="left">遍历是否可暂停</th>
<th align="left">暂停条件</th>
<th align="left">返回值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>some</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">callback 返回 true</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left"><strong>every</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">callback 返回 false</td>
<td align="left">布尔值</td>
</tr>
<tr>
<td align="left"><strong>find</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">callback 返回 true</td>
<td align="left">找到的元素或 undefined</td>
</tr>
<tr>
<td align="left"><strong>findIndex</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">✅</td>
<td align="left">callback 返回 true</td>
<td align="left">元素的索引或 -1</td>
</tr>
</tbody></table>
<p><strong>4. 不可中断遍历的方法</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">参数</th>
<th align="left">是否改变原数组</th>
<th align="left">遍历是否可暂停</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>forEach</strong></td>
<td align="left">(callback(current, index, array))</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">遍历所有元素</td>
</tr>
<tr>
<td align="left"><strong>entries</strong></td>
<td align="left">()</td>
<td align="left">❌</td>
<td align="left">⚠️*</td>
<td align="left">返回迭代器，可用 break</td>
</tr>
<tr>
<td align="left"><strong>keys</strong></td>
<td align="left">()</td>
<td align="left">❌</td>
<td align="left">⚠️*</td>
<td align="left">返回迭代器，可用 break</td>
</tr>
<tr>
<td align="left"><strong>values</strong></td>
<td align="left">()</td>
<td align="left">❌</td>
<td align="left">⚠️*</td>
<td align="left">返回迭代器，可用 break</td>
</tr>
</tbody></table>
<blockquote>
<p>*注：entries&#x2F;keys&#x2F;values 方法返回的是迭代器对象，本身不进行遍历，使用迭代器时可配合 <code>break</code> 暂停</p>
</blockquote>
<h2 id="JavaScript-集合类型对比与应用场景指南"><a href="#JavaScript-集合类型对比与应用场景指南" class="headerlink" title="JavaScript 集合类型对比与应用场景指南"></a>JavaScript 集合类型对比与应用场景指南</h2><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">Map</th>
<th align="left">Set</th>
<th align="left">WeakMap</th>
<th align="left">WeakSet</th>
<th align="left">Object</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>键类型</strong></td>
<td align="left">任意类型</td>
<td align="left">任意类型</td>
<td align="left">仅对象</td>
<td align="left">仅对象</td>
<td align="left">字符串&#x2F;Symbol</td>
</tr>
<tr>
<td align="left"><strong>值类型</strong></td>
<td align="left">任意类型</td>
<td align="left">无值(仅存储键)</td>
<td align="left">任意类型</td>
<td align="left">无值(仅存储键)</td>
<td align="left">任意类型</td>
</tr>
<tr>
<td align="left"><strong>可迭代性</strong></td>
<td align="left">✅</td>
<td align="left">✅</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅(需辅助方法)</td>
</tr>
<tr>
<td align="left"><strong>大小获取</strong></td>
<td align="left">直接(size属性)</td>
<td align="left">直接(size属性)</td>
<td align="left">不可获取</td>
<td align="left">不可获取</td>
<td align="left">需计算</td>
</tr>
<tr>
<td align="left"><strong>垃圾回收</strong></td>
<td align="left">强引用(阻止回收)</td>
<td align="left">强引用(阻止回收)</td>
<td align="left">弱引用(不阻止回收)</td>
<td align="left">弱引用(不阻止回收)</td>
<td align="left">强引用(阻止回收)</td>
</tr>
<tr>
<td align="left"><strong>顺序保证</strong></td>
<td align="left">插入顺序</td>
<td align="left">插入顺序</td>
<td align="left">无顺序</td>
<td align="left">无顺序</td>
<td align="left">无顺序(ES6后有序)</td>
</tr>
<tr>
<td align="left"><strong>键冲突处理</strong></td>
<td align="left">可覆盖</td>
<td align="left">自动去重</td>
<td align="left">可覆盖</td>
<td align="left">自动去重</td>
<td align="left">属性名覆盖</td>
</tr>
<tr>
<td align="left"><strong>序列化支持</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅</td>
</tr>
<tr>
<td align="left"><strong>原型链影响</strong></td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">❌</td>
<td align="left">✅</td>
</tr>
<tr>
<td align="left"><strong>性能(增删)</strong></td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">较低</td>
</tr>
</tbody></table>
<p><strong>应用场景详解</strong></p>
<ol>
<li>Map 最佳应用场景</li>
</ol>
<ul>
<li><strong>复杂键值存储</strong>：当需要使用非字符串键（如对象、函数）时</li>
<li><strong>DOM元素关联</strong>：将DOM元素与元数据关联，不污染DOM本身</li>
<li><strong>频率计数</strong>：高效统计元素出现频率</li>
<li><strong>有序键值对</strong>：需要保持键值对插入顺序的场景</li>
<li><strong>类私有属性</strong>：实现类实例的私有属性存储</li>
</ul>
<ol start="2">
<li>Set 最佳应用场景</li>
</ol>
<ul>
<li><strong>值唯一性保证</strong>：自动去除重复元素的场景</li>
<li><strong>集合运算</strong>：实现并集、交集、差集等数学集合操作</li>
<li><strong>存在性检查</strong>：快速检查元素是否存在的场景</li>
<li><strong>事件订阅管理</strong>：管理唯一的事件处理器集合</li>
<li><strong>数据过滤</strong>：从大型数据集中快速过滤唯一值</li>
</ul>
<ol start="3">
<li>WeakMap 最佳应用场景</li>
</ol>
<ul>
<li><strong>私有数据存储</strong>：关联对象与私有数据，不暴露给外部</li>
<li><strong>DOM元数据关联</strong>：当DOM元素被移除时自动清除关联数据</li>
<li><strong>缓存系统</strong>：对象缓存，当对象不再使用时自动清除缓存</li>
<li><strong>资源管理</strong>：对象与资源的关联，资源随对象自动释放</li>
<li><strong>避免内存泄漏</strong>：需要对象作为键且自动垃圾回收的场景</li>
</ul>
<ol start="4">
<li>WeakSet 最佳应用场景</li>
</ol>
<ul>
<li><strong>对象标记</strong>：标记对象状态（如”已处理”），不阻止垃圾回收</li>
<li><strong>循环引用检测</strong>：跟踪对象访问状态，防止无限递归</li>
<li><strong>临时对象集合</strong>：存储临时使用的对象集合，自动清理</li>
<li><strong>访问控制</strong>：检查对象是否具有特定权限，自动清理无效对象</li>
<li><strong>依赖管理</strong>：管理对象依赖关系，随主对象自动清除</li>
</ul>
<ol start="5">
<li>Object 最佳应用场景</li>
</ol>
<ul>
<li><strong>配置对象</strong>：结构化配置参数的存储</li>
<li><strong>JSON数据</strong>：需要序列化和反序列化的数据</li>
<li><strong>方法命名空间</strong>：组织相关函数和方法</li>
<li><strong>简单键值对</strong>：键为字符串&#x2F;Symbol的简单数据结构</li>
<li><strong>模块导出</strong>：作为模块的导出容器</li>
<li><strong>原型继承</strong>：需要利用原型链实现继承的场景</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>3种定义方式 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 全局提升</span></span><br><span class="line"><span class="keyword">const</span> fn =<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 函数表达式</span></span><br><span class="line">箭头表达式</span><br><span class="line"><span class="comment">// 0或多个参数，1个可以没有（）</span></span><br><span class="line"><span class="comment">// 1行语句可以没有&#123;&#125;</span></span><br><span class="line">()=&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JavaScript 引擎在任何代码执行之前，会<strong>先读取函数声明，并在执行上下文中生成函数定义</strong>。</p>
<p>而<strong>函数表达式必须等到代码执行到它那一行</strong>，才会在执行上下文中生成函数定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没问题  </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));  </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">	<span class="keyword">return</span> num1 + num2;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>只有var 修饰的变量，存在<strong>变量声明提升</strong>，且在赋值前允许访问,<strong>但不赋值</strong>，返回undefiend</p>
<p>let存在<strong>变量声明提升</strong>，但是<strong>在赋值前不允许访问</strong>,报错</p>
<p>以上代码可以正常运行，因为函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个 过程叫作<strong>函数声明提升</strong>（function declaration hoisting）</p>
<p>在<strong>执行代码时，JavaScript 引擎会先执行一遍扫描， 把发现的函数声明提升到源代码树的顶部</strong>。因此即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部<font color="red">为了性能</font></p>
<p>这两提升适用于函数作用域<br><img src="/../img/image-20240216221556720.png" alt="image-20240216221556720"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会出错 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>));  </span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">	<span class="keyword">return</span> num1 + num2;  </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>上面的代码之所以会出错，是因为这个函数定义包含在一个变量初始化语句中，而不是函数声明中。 这意味着代码如果没有执行到加粗的那一行，那么执行上下文中就没有函数的定义，所以上面的代码会 出错。</p>
<p><strong>函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量 functionName。这样创建的函数叫作匿名函数（anonymous funtion），因为 function 关键字后面没有 标识符。（匿名函数有也时候也被称为兰姆达函数）。未赋值给其他变量的匿名函数的 name 属性是空字符串</strong>。</p>
<p>箭头函数箭头后面一行代码想要返回一个对像{}是不行的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span>=(<span class="params"></span>)=&gt;&#123;<span class="attr">test</span>:<span class="string">&quot;name&quot;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> res=<span class="title function_">fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//&#123;&#123;&#125;&#125;也不行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//（&#123;&#125;）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span>=(<span class="params"></span>)=&gt;(&#123;<span class="attr">test</span>:<span class="string">&quot;name&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> res=<span class="title function_">fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);<span class="comment">//&#123;test:&quot;name&quot;&#125;</span></span><br></pre></td></tr></table></figure>



<p><strong>函数名</strong></p>
<p>函数名就是指向函数的指针，所以它们跟其他包含对象指针的变量具有相同的行为。这意味着 一个函数可以有多个名称，如下所示： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">	<span class="keyword">return</span> num1 + num2;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20  </span></span><br><span class="line"><span class="keyword">let</span> anotherSum = sum;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherSum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20  </span></span><br><span class="line">sum = <span class="literal">null</span>;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">anotherSum</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 20  </span></span><br></pre></td></tr></table></figure>

<p>以上代码定义了一个名为 sum()的函数，用于求两个数之和。然后又声明了一个变量 anotherSum， 并将它的值设置为等于 sum。</p>
<p><strong>注意，使用不带括号的函数名会访问函数指针，而不会执行函数。</strong></p>
<p>此时， anotherSum 和 sum 都指向同一个函数。调用 anotherSum()也可以返回结果。</p>
<p>把 sum 设置为 null 之后，就切断了它与函数之间的关联。而 anotherSum()还是可以照常调用，没有问题</p>
<p>ECMAScript 6 的所有函数对象都会暴露一个只读的 <strong>name 属性</strong>，其中包含关于函数的信息。多数情 况下，这个属性中保存的就是一个函数标识符，或者说是一个字符串化的变量名。即使函数没有名称， 也会如实显示成空字符串。<strong>如果它是使用 Function 构造函数创建的，则会标识成”anonymous”</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125; </span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;; </span><br><span class="line"><span class="keyword">let</span> <span class="title function_">baz</span> = (<span class="params"></span>) =&gt; &#123;&#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">name</span>); <span class="comment">// foo </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">name</span>); <span class="comment">// bar </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(baz.<span class="property">name</span>); <span class="comment">// baz </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="function">() =&gt;</span> &#123;&#125;).<span class="property">name</span>); <span class="comment">//（空字符串）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">new</span> <span class="title class_">Function</span>()).<span class="property">name</span>); <span class="comment">// anonymous </span></span><br></pre></td></tr></table></figure>

<p>如果函数是一个获取函数、设置函数，或者使用 bind()实例化，那么标识符前面会加上一个前缀：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;  <span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="title function_">bind</span>(<span class="literal">null</span>).<span class="property">name</span>); <span class="comment">// bound foo  </span></span><br><span class="line"><span class="keyword">let</span> dog = &#123;  </span><br><span class="line">    <span class="attr">years</span>: <span class="number">1</span>,  </span><br><span class="line">    <span class="keyword">get</span> <span class="title function_">age</span>() &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">years</span>;  </span><br><span class="line">    &#125;,  </span><br><span class="line">    <span class="keyword">set</span> <span class="title function_">age</span>(<span class="params">newAge</span>) &#123;  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">years</span> = newAge;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">let</span> propertyDescriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(dog, <span class="string">&#x27;age&#x27;</span>); <span class="variable language_">console</span>.<span class="title function_">log</span>(propertyDescriptor.<span class="property">get</span>.<span class="property">name</span>); <span class="comment">// get age  console.log(propertyDescriptor.set.name); // set age </span></span><br></pre></td></tr></table></figure>





<p><strong>函数参数</strong></p>
<p>定义形参就相当于<strong>在函数中声明了对应的变量，但是没有赋值</strong></p>
<p><img src="/../img/image-20240216221930349.png" alt="image-20240216221930349"></p>
<p><img src="/../img/image-20240216222103472.png" alt="image-20240216222103472"></p>
<p><img src="/../img/image-20240216222423936.png" alt="image-20240216222423936"></p>
<p><strong>ECMAScript 函数的参数在内部表现为一个数组</strong>。</p>
<p>函数被调用时总会接收一个数组，但函数并不关心这个数组中包含什么。</p>
<p>如果数组中什么也没有，那没问题；如果数组的元素超出了要求，那也没问题。</p>
<p>事实上，在使用 function 关键字定义（非箭头）函数时，<strong>可以在函数内部访问 arguments 对象</strong>，从中取得传进来的每个参数值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">howManyArgs</span>(<span class="params"></span>) &#123; </span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">howManyArgs</span>(<span class="string">&quot;string&quot;</span>, <span class="number">45</span>); <span class="comment">// 2 </span></span><br><span class="line"><span class="title function_">howManyArgs</span>(); <span class="comment">// 0 </span></span><br><span class="line"><span class="title function_">howManyArgs</span>(<span class="number">12</span>); <span class="comment">// 1 </span></span><br></pre></td></tr></table></figure>

<p><strong>arguments 对象</strong>可以跟命名参数一起使用，比如： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAdd</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;  </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(num1 + <span class="number">10</span>);  </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">2</span>) &#123;  </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在这个 doAdd()函数中，同时使用了两个命名参数和 arguments 对象。命名参数 num1 保存着与 arugments[0]一样的值，因此使用谁都无所谓。（同样，num2 也保存着跟 arguments[1]一样的值。）</p>
<p> arguments 对象的另一个有意思的地方就是，<strong>它的值始终会与对应的命名参数同步</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doAdd</span>(<span class="params">num1, num2</span>) &#123;  </span><br><span class="line">    <span class="variable language_">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>] + num2);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个 doAdd()函数把第二个参数的值重写为 10。因为 <strong>arguments 对象的值会自动同步到对应的命名参数</strong>，所以修改 arguments[1]也会修改 num2 的值，因此两者的值都是 10。但这并不意味着它们都访问同一个内存地址，<strong>它们在内存中还是分开的，只不过会保持同步而已</strong>。另外还要记住一点：如果只传了一个参数，然后把 arguments[1]设置为某个值，那么这个值并不会反映到第二个命名参数。这是 <strong>因为 arguments 对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的</strong></p>
<p>特例</p>
<p><strong>箭头函数中的参数</strong> </p>
<p>如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用 arguments 关键字访问，而只能通过定义的命名参数访问。</p>
<p>注意 <strong>ECMAScript 中的所有参数都按值传递的。不可能按引用传递参数。如果把对象作为参数传递，那么传递的值就是这个对象的引用。</strong></p>
<p>在JavaScript中，<strong>原始类型的内容是存储在栈中，而对象的内容是存储在堆中，指向堆的地址存储在栈中</strong>。</p>
<p>(Number、Stirng、Boolean、Null、Underfined这些基本数据类型，他们的值直接保存在栈中；<br>Object、Function、Array、Date、RegExp这些引用类型，他们的引用变量储存在栈中，通过指针指向储存在堆中的实际对象)</p>
<p>原始变量及他们的值储存在栈中，当把一个原始变量传递给另一个原始变量时，是把一个栈房间的东西复制到另一个栈房间，且这两个原始变量互不影响。</p>
<p>引用值是把引用变量的名称储存在栈中，但是其实际对象储存在堆中，且存在一个指针由变量名指向储存在堆中的实际对象，当把引用对象传递给另一个变量时，复制的其实是指向实际对象的指针，此时两者指向的是同一个数据，若通过方法改变其中一个变量的值，则访问另一个变量时，其值也会随之加以改变；但若通过重新赋值  ，此时相当于重新开了一个房间 ，该值的原指针改变，而另外一个值不会随它的改变而改变</p>
<p><strong>原始变量赋值给参数时，将栈中数据发给参数，两个数相互独立</strong></p>
<p><strong>引用变量给的是栈中的内存地址，所以，在函数内部发生属性值得改变，是对堆中对象的修改，所以另一个值得属性也发生，除非在函数中修改参数的内存的地址，也即参数重新赋值，才会再次相互独立</strong></p>
<p><strong>默认参数值</strong></p>
<p>1、使用默认参数时，arguments 对象的值不反映参数的默认值，只反映传给函数的参数</p>
<p>2、默认参数值并不限于原始值或对象类型，也可以使用调用函数返回的值：</p>
<p>3、函数的默认参数只有在函数被调用时才会求值，不会在函数定义时求值。而且，计算默认值的函数 只有在调用函数但未传相应参数时才会被调用。 箭头函数同样也可以这样使用默认参数，只不过在只有一个参数时，就必须使用括号而不能省略了</p>
<p>4、默认参数会按照定义它们的顺序依次被初始化，后定义默认值的参数可以引用先定义的参数</p>
<p>5、参数初始化顺序遵循“暂时性死区”规则，即前面定义的参数不能引用后面定义的</p>
<p>6、参数也存在于自己的作用域中，它们不能引用函数体的作用域</p>
<p><strong>扩展参数</strong></p>
<p>对可迭代对象适用 …,这也适用于argument数组，箭头函数中也能这么写</p>
<p><strong>函数作为传递值</strong></p>
<p>函数作为值 因为函数名在 ECMAScript 中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数。</p>
<h3 id="函数内部"><a href="#函数内部" class="headerlink" title="函数内部"></a>函数内部</h3><h3 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a><strong>arguments</strong></h3><p>一个类数组对象，包含调用函数时传入的所有参数。这 个对象只有以 function 关键字定义函数（相对于使用箭头语法创建函数）时才会有。虽然主要用于包 含函数参数，但 arguments 对象其实还有一个 callee 属性，是一个指向 arguments 对象所在函数的 指针。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a><strong>this</strong></h3><p>它在标准函数和箭头函数中有不同的行为。 在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为 this 值（在 网页的全局上下文中调用函数时，this 指向 windows）</p>
<p>在箭头函数中，this引用的是定义箭头函数的上下文。</p>
<h4 id="对this对象的理解"><a href="#对this对象的理解" class="headerlink" title="对this对象的理解"></a>对this对象的理解</h4><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p>
<ul>
<li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li>
<li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li>
<li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li>
<li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li>
</ul>
<p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p>
<h4 id="对this-的补充"><a href="#对this-的补充" class="headerlink" title="对this 的补充"></a>对this 的补充</h4><ol>
<li>函数默认执行 执行window.也就是什么都不做直接执行</li>
<li>对象调用函数,会隐式绑定把this指向对象</li>
<li>显示绑定,通过call , apply , bind,会指向输入的参数,如果不输入参数,则默认绑定为window</li>
<li>通过new操作符来绑定this.</li>
</ol>
<p>它们的优先级是:</p>
<p>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。</p>
<p>还有一个考察的知识点就是箭头函数.它的this由定义它的结构代码时父级执行上下文决定的</p>
<ul>
<li>如果是在全局环境,或者是在一个对象里,它的父级执行上下文就是全局环境,它的this就指向了window</li>
<li>如果它的<strong>外部是一个函数,那么它的this就指向了函数的执行上下文.而函数的执行上下文就是活的.取决于调用时的情况.也就上面列举的四种情况</strong>.</li>
</ul>
<p>根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。</p>
<p>要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined</p>
<h4 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h4><p>函数的 <code>this</code> 关键字在 <code>JavaScript</code> 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别</p>
<p>在绝大多数情况下，函数的调用方式决定了 <code>this</code> 的值（运行时绑定）</p>
<p><code>this</code> 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置是全局作用域</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;baz&quot;</span> );</span><br><span class="line">    <span class="title function_">bar</span>(); <span class="comment">// &lt;-- bar的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz --&gt; bar</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在baz中</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;bar&quot;</span> );</span><br><span class="line">    <span class="title function_">foo</span>(); <span class="comment">// &lt;-- foo的调用位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前调用栈是：baz --&gt; bar --&gt; foo</span></span><br><span class="line">    <span class="comment">// 因此，当前调用位置在bar中</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;foo&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">baz</span>(); <span class="comment">// &lt;-- baz的调用位置</span></span><br></pre></td></tr></table></figure>



<p>同时，<code>this</code>在函数执行过程中，<code>this</code>一旦被确定了，就不可以再更改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span> = obj; <span class="comment">// 修改this，运行后会报错</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>



<h4 id="二、绑定规则"><a href="#二、绑定规则" class="headerlink" title="二、绑定规则"></a>二、绑定规则</h4><p>根据不同的使用场合，<code>this</code>有不同的值，主要分为下面几种情况：</p>
<ul>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>new绑定</li>
<li>显示绑定</li>
</ul>
<h5 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h5><p>全局环境中定义<code>person</code>函数，内部使用<code>this</code>关键字</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;Jenny&#x27;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">person</span>());  <span class="comment">//Jenny</span></span><br></pre></td></tr></table></figure>



<p>上述代码输出<code>Jenny</code>，原因是调用函数的对象在游览器中位<code>window</code>，因此<code>this</code>指向<code>window</code>，所以输出<code>Jenny</code></p>
<p>注意：</p>
<p>严格模式下，不能将全局对象用于默认绑定，this会绑定到<code>undefined</code>，只有函数运行在非严格模式下，默认绑定才能绑定到全局对象</p>
<h5 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h5><p>函数还可以作为某个对象的方法调用，这时<code>this</code>就指这个上级对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">m</span> = test;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">m</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<p>这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，<code>this</code>指向的也只是它上一级的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>:&#123;</span><br><span class="line">        <span class="attr">fn</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">//undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.<span class="property">b</span>.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>



<p>上述代码中，<code>this</code>的上一级对象为<code>b</code>，<code>b</code>内部并没有<code>a</code>变量的定义，所以输出<code>undefined</code></p>
<p>这里再举一种特殊情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="number">10</span>,</span><br><span class="line">    <span class="attr">b</span>:&#123;</span><br><span class="line">        <span class="attr">a</span>:<span class="number">12</span>,</span><br><span class="line">        <span class="attr">fn</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>); <span class="comment">//undefined</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">//window</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = o.<span class="property">b</span>.<span class="property">fn</span>;</span><br><span class="line"><span class="title function_">j</span>();</span><br></pre></td></tr></table></figure>



<p>此时<code>this</code>指向的是<code>window</code>，这里的大家需要记住，<code>this</code>永远指向的是最后调用它的对象，虽然<code>fn</code>是对象<code>b</code>的方法，但是<code>fn</code>赋值给<code>j</code>时候并没有执行，所以最终指向<code>window</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure>

<h5 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h5><p>通过构建函数<code>new</code>关键字生成一个实例对象，此时<code>this</code>指向这个实例对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">　<span class="variable language_">this</span>.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title function_">test</span>();</span><br><span class="line">obj.<span class="property">x</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<p>上述代码之所以能过输出1，是因为<code>new</code>关键字改变了<code>this</code>的指向</p>
<p>这里再列举一些特殊情况：</p>
<p><code>new</code>过程遇到<code>return</code>一个对象，此时<code>this</code>指向为返回的对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="title function_">fn</span>();  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>



<p>如果返回一个简单类型的时候，则<code>this</code>指向实例对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//xxx</span></span><br></pre></td></tr></table></figure>



<p>注意的是<code>null</code>虽然也是对象，但是此时<code>new</code>仍然指向实例对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">user</span> = <span class="string">&#x27;xxx&#x27;</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">user</span>); <span class="comment">//xxx</span></span><br></pre></td></tr></table></figure>



<h5 id="显示修改"><a href="#显示修改" class="headerlink" title="显示修改"></a>显示修改</h5><p><code>apply()、call()、bind()</code>是函数的一个方法，作用是改变函数的调用对象。它的第一个参数就表示改变后的调用这个函数的对象。因此，这时<code>this</code>指的就是这第一个参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">　<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">x</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">x</span> = <span class="number">1</span>;</span><br><span class="line">obj.<span class="property">m</span> = test;</span><br><span class="line">obj.<span class="property">m</span>.<span class="title function_">apply</span>(obj) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>



<p>关于<code>apply、call、bind</code>三者的区别，我们后面再详细说</p>
<h4 id="三、箭头函数"><a href="#三、箭头函数" class="headerlink" title="三、箭头函数"></a>三、箭头函数</h4><p>在 ES6 的语法中还提供了箭头函语法，让我们在代码书写时就能确定 <code>this</code> 的指向（编译时绑定）</p>
<p>举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">sayThis</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">sayThis</span>(); <span class="comment">// window 因为 JavaScript 没有块作用域，所以在定义 sayThis 的时候，里面的 this 就绑到 window 上去了</span></span><br><span class="line"><span class="keyword">const</span> globalSay = obj.<span class="property">sayThis</span>;</span><br><span class="line"><span class="title function_">globalSay</span>(); <span class="comment">// window 浏览器中的 global 对象</span></span><br></pre></td></tr></table></figure>



<p>虽然箭头函数的<code>this</code>能够在编译的时候就确定了<code>this</code>的指向，但也需要注意一些潜在的坑</p>
<p>下面举个例子：</p>
<p>绑定事件监听</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;mngb&#x27;</span>);</span><br><span class="line">button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">// true</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;clicked button&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<p>上述可以看到，我们其实是想要<code>this</code>为点击的<code>button</code>，但此时<code>this</code>指向了<code>window</code></p>
<p>包括在原型上添加方法时候，此时<code>this</code>指向<code>window</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">//true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&#x27;mm&#x27;</span>);</span><br><span class="line">cat.<span class="title function_">sayName</span>()</span><br></pre></td></tr></table></figure>



<p>同样的，箭头函数不能作为构建函数</p>
<h4 id="四、优先级"><a href="#四、优先级" class="headerlink" title="四、优先级"></a>四、优先级</h4><h5 id="隐式绑定-VS-显式绑定"><a href="#隐式绑定-VS-显式绑定" class="headerlink" title="隐式绑定 VS 显式绑定"></a>隐式绑定 VS 显式绑定</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">a</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>(); <span class="comment">// 2</span></span><br><span class="line">obj2.<span class="title function_">foo</span>(); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>( obj2 ); <span class="comment">// 3</span></span><br><span class="line">obj2.<span class="property">foo</span>.<span class="title function_">call</span>( obj1 ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<p>显然，显示绑定的优先级更高</p>
<h5 id="new绑定-VS-隐式绑定"><a href="#new绑定-VS-隐式绑定" class="headerlink" title="new绑定 VS 隐式绑定"></a>new绑定 VS 隐式绑定</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>( <span class="number">2</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>( obj2, <span class="number">3</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj2.<span class="property">a</span> ); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> obj1.<span class="title function_">foo</span>( <span class="number">4</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( bar.<span class="property">a</span> ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>



<p>可以看到，new绑定的优先级<code>&gt;</code>隐式绑定</p>
<h5 id="new绑定-VS-显式绑定"><a href="#new绑定-VS-显式绑定" class="headerlink" title="new绑定 VS 显式绑定"></a><code>new</code>绑定 VS 显式绑定</h5><p>因为<code>new</code>和<code>apply、call</code>无法一起使用，但硬绑定也是显式绑定的一种，可以替换测试</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">something</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = something;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>( obj1 );</span><br><span class="line"><span class="title function_">bar</span>( <span class="number">2</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> baz = <span class="keyword">new</span> <span class="title function_">bar</span>( <span class="number">3</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj1.<span class="property">a</span> ); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( baz.<span class="property">a</span> ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar`被绑定到obj1上，但是`new bar(3)` 并没有像我们预计的那样把`obj1.a`修改为3。但是，`new`修改了绑定调用`bar()`中的`this</span><br></pre></td></tr></table></figure>

<p>我们可认为<code>new</code>绑定优先级<code>&gt;</code>显式绑定</p>
<p>综上，new绑定优先级 &gt; 显示绑定优先级 &gt; 隐式绑定优先级 &gt; 默认绑定优先级</p>
<p>**new.target **</p>
<p>ECMAScript 6 新增了检测函数是否使用 new 关键字调用的 new.target 属性。如果函数是正常调用的</p>
<p>则 new.target 的值是 undefined；如果是使用 new 关键字调用的，则 new.target 将引用被调用的 构造函数。</p>
<p><strong>函数的属性和方法</strong></p>
<p>length 属性保存函数定义的命名参数的个数</p>
<p>prototype 属性也许是 ECMAScript 核心中最有趣的部分。prototype 是保存引用类型所有实例 方法的地方，这意味着 toString()、valueOf()等方法实际上都保存在 prototype 上，进而由所有实 例共享</p>
<p>apply()和 call()。这两个方法都会以指定的 this 值来调用函数，即会设 置调用函数时函数体内 this 对象的值。</p>
<p>apply()方法接收两个参数：函数内 this 的值和一个参数数组。第二个参数可以是 Array 的实例，但也可以是 arguments 对象</p>
<p>call()方法与 apply()的作用一样，只是传参的形式不同。第一个参数跟 apply()一样，也是 this 值，而剩下的要传给被调用函数的参数则是逐个传递的。换句话说，通过 call()向函数传参时，必须 将参数一个一个地列出来</p>
<p><strong>严格模式下，调用函数时如果没有指定上下文对象，则 this 值不会指向 window。 除非使用 apply()或 call()把函数指定给一个对象，否则 this 的值会变成 undefined。</strong></p>
<p>bind() bind()方法会创建一个新的函数实例， 其 this 值会被绑定到传给 bind()的对象。</p>
<h3 id="三个函数方法的原理实现"><a href="#三个函数方法的原理实现" class="headerlink" title=" 三个函数方法的原理实现"></a><font color="red"> <strong>三个函数方法的原理实现</strong></font></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断调用对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">let</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">      result = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 判断 context 是否传入，如果未传入则设置为 window</span></span><br><span class="line">    context = context || <span class="variable language_">window</span>;</span><br><span class="line">    <span class="comment">// 将调用函数设为对象的方法</span></span><br><span class="line">    context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    result = context.<span class="title function_">fn</span>(...args);</span><br><span class="line">    <span class="comment">// 将属性删除</span></span><br><span class="line">    <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断 context 是否存在，如果未传入则为 window</span></span><br><span class="line">  context = context || <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 将函数设为对象的方法</span></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="comment">// 调用方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>(...<span class="variable language_">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.<span class="title function_">fn</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将属性删除</span></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">        fn = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">            <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context,</span><br><span class="line">            args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>尾调用优化的条件</strong> </p>
<p>代码在严格模式下执行； </p>
<p>外部函数的返回值是对尾调用函数的调用； </p>
<p>尾调用函数返回后不需要执行额外的逻辑； </p>
<p>尾调用函数不是引用外部函数作用域中自由变量的闭包</p>
<h3 id="函数垃圾回收"><a href="#函数垃圾回收" class="headerlink" title="函数垃圾回收"></a><strong>函数垃圾回收</strong></h3><p><strong>标记清理</strong></p>
<p> JavaScript 最常用的垃圾回收策略是标记清理（mark-and-sweep）。</p>
<p>当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永 远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时， 也会被加上离开上下文的标记。 </p>
<p>给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下 文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现 并不重要，关键是策略。 垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它 会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记 的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内 存清理，销毁带标记的所有值并收回它们的内存。</p>
<p><strong>引用计数</strong></p>
<p> 另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被 引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变 量，那么引用数加 1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1。当一 个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序 下次运行的时候就会释放引用数为 0 的值的内存。 引用计数最早由 Netscape Navigator 3.0 采用，但很快就遇到了严重的问题：<strong>循环引用</strong>。所谓循环引 用，就是对象 A 有一个指针指向对象 B，而对象 B 也引用了对象 A。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>执行上下文（以下简称“上下文”）的概念在 JavaScript 中是颇为重要的。变量或函数的上下文决定 了它们可以访问哪些数据，以及它们的行为。每个上下文都有一个关联的<strong>变量对象（variable object）</strong>， 而这个上下文中定义的所有变量和函数都存在于这个对象上。虽然无法通过代码访问变量对象，但后台处理数据会用到它</p>
<p><strong>全局上下文</strong></p>
<p>是最外层的上下文。根据 ECMAScript 实现的宿主环境，表示全局上下文的对象可能不一 样。在浏览器中，全局上下文就是我们常说的 window 对象，因此<strong>所有通过 var 定义的全局变量和函数都会成为 window 对象的属性和方法。</strong></p>
<p><strong>使用 let 和 const 的顶级声明不会定义在全局上下文中，但在作用域链解析上效果是一样的。上下文在其所有代码都执行完毕后会被销毁，包括定义 在它上面的所有变量和函数</strong>（全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器）。<br>每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。 在函数执行完之后，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。</p>
<p>ECMAScript 程序的执行流就是通过这个上下文栈进行控制的。 上下文中的代码在执行的时候，会创建变量对象的一个作用域链（scope chain）。这个作用域链决定 了各级上下文中的代码在访问变量和函数时的顺序。</p>
<p>代码正在执行的上下文的变量对象始终位于作用域链的最前端。如果上下文是函数，则其活动对象（activation object）用作变量对象。活动对象最初只有 一个定义变量：arguments。（全局上下文中没有这个变量）作用域链中的下一个变量对象来自包含上 下文，再下一个对象来自再下一个包含上下文。以此类推直至全局上下文；</p>
<p><strong>就近原则</strong></p>
<p>**全局上下文的变量对象始终是作用域链的最后一个变量对象。 **</p>
<p><strong>代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符</strong></p>
<p><strong>作用域链增强</strong> </p>
<p>虽然执行上下文主要有全局上下文和函数上下文两种（eval()调用内部存在第三种上下文），但有其他方式来增强作用域链。某些语句会导致在作用域链前端临时添加一个上下文，这个上下文在代码执行后会被删除。通常在两种情况下会出现这个现象，即代码执行到下面任意一种情况时： </p>
<p>try&#x2F;catch 语句的 catch 块 </p>
<p>with 语句 这两种情况下，都会在作用域链前端添加一个变量对象。</p>
<p><strong>对 with 语句来说，会向作用域链前端添 加指定的对象；</strong></p>
<p><strong>对 catch 语句而言，则会创建一个新的变量对象，这个变量对象会包含要抛出的错误对象的声明</strong></p>
<h3 id="作用域、作用域链的理解"><a href="#作用域、作用域链的理解" class="headerlink" title="作用域、作用域链的理解"></a>作用域、作用域链的理解</h3><h5 id="1）全局作用域和函数作用域"><a href="#1）全局作用域和函数作用域" class="headerlink" title="1）全局作用域和函数作用域"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p>
<ul>
<li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li>
<li>所有未定义直接赋值的变量自动声明为全局作用域</li>
<li>所有window对象的属性拥有全局作用域</li>
<li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li>
</ul>
<p>（2）函数作用域</p>
<ul>
<li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li>
<li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li>
</ul>
<h5 id="2）块级作用域"><a href="#2）块级作用域" class="headerlink" title="2）块级作用域"></a>2）块级作用域</h5><ul>
<li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li>
<li>let和const声明的变量不会有变量提升，也不可以重复声明</li>
<li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li>
</ul>
<p><strong>作用域链：</strong></p>
<p>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p>
<p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p>
<p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p>
<p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><font color="red">函数的作用域，<strong>在函数创建时就已经确定的</strong>(词法作用域)和调用的位置无关</font></p>
<font color="red">

<p>闭包的生命周期:1闭包在外部函数调用时产生，外部函数每次调用都会产生一个全新的闭包2在内部函数丢失时销毁(内部函数被垃圾回收了，闭包才会消失)</p>
</font>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> a=<span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    <span class="title function_">test</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//1</span></span><br></pre></td></tr></table></figure>



<p><img src="/../img/image-20240217084901274.png" alt="image-20240217084901274"></p>
<p>指的是那些引用了另一个函数作用域中变量的函数，通常是在嵌套函数中实现的。比如，下面是之前展示的 createComparisonFunction()函数，</p>
<p>注 意其中加粗的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createComparisonFunction</span>(<span class="params">propertyName</span>) &#123;  </span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">object1, object2</span>) &#123;  </span><br><span class="line">		    <span class="keyword">let</span> value1 = object1[propertyName];  </span><br><span class="line">		    <span class="keyword">let</span> value2 = object2[propertyName];  </span><br><span class="line">		    <span class="keyword">if</span> (value1 &lt; value2) &#123;  </span><br><span class="line">		    	<span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">		    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;  </span><br><span class="line">		    	<span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">		    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">		    	<span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">		    &#125;  </span><br><span class="line">	 &#125;;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>



<p><img src="/../img/image-20240217094012495.png" alt="image-20240217094012495"></p>
<h3 id="闭包的理解"><a href="#闭包的理解" class="headerlink" title="闭包的理解"></a>闭包的理解</h3><p>普通函数（外层函数）</p>
<p>函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义 compare()函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的[[Scope]]中。在 调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[Scope]]来创建其作用域链。接着会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。在这个例子中，这意味着 compare() 函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。</p>
<p><img src="/../img/image-20240217100208940.png" alt="image-20240217100208940"></p>
<p>函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。 在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。因此，在 createComparisonFunction()函数中，匿名函数的作用域链中实际上包含 createComparisonFunction()的活动对象。图 10-2 展示了以下代码执行后的结果</p>
<p><img src="/../img/image-20240217100229047.png" alt="image-20240217100229047"></p>
<p><font color="red">闭包在外部函数调用时且在外部函数作用域已被调用或者已被返回才会产生</font></p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>占用的内存没有及时释放</p>
<p>内存泄露积累多了就容易导致内存溢出</p>
<p>常见的内存泄露:<br>意外的全局变量</p>
<p>没有及时清理的计时器或回调函数</p>
<p>闭包</p>
<p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line"></span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。解决办法有三种：</p>
<p>●第一种是使用闭包的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  ;(<span class="keyword">function</span>(<span class="params">j</span>) &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">​      <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line"></span><br><span class="line">​    &#125;, j * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">  &#125;)(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。</p>
<p>●第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line"></span><br><span class="line">  setTimeout(</span><br><span class="line"></span><br><span class="line">​    function timer(j) &#123;</span><br><span class="line"></span><br><span class="line">​      console.log(j)</span><br><span class="line"></span><br><span class="line">​    &#125;,</span><br><span class="line"></span><br><span class="line">​    i * 1000,</span><br><span class="line"></span><br><span class="line">​    i</span><br><span class="line"></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>●第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line"></span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a><strong>立即调用的函数表达式</strong></h2><p>立即调用的函数表达式（IIFE，Immediately Invoked Function  Expression）。</p>
<p>它类似于函数声明，但<strong>由于被包含在括号中，所以会被解释为函数表达式</strong>。紧跟在第一组括号后面的第二组括号会立即调用前面的函数表达式。下面是一个简单的例子： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line"><span class="comment">// 块级作用域  </span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p> 使用 IIFE 可以<strong>模拟块级作用域</strong>，即在<strong>一个函数表达式内部声明变量，然后立即调用这个函数</strong>。这 样位于函数体作用域的变量就像是在块级作用域中一样。ECMAScript 5 尚未支持块级作用域，使用 IIFE 模拟块级作用域是相当普遍的。比如下面的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// IIFE  </span><br><span class="line">(function () &#123;  </span><br><span class="line">	for (var i = 0; i &lt; count; i++) &#123;  </span><br><span class="line">		console.log(i);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;)();  console.log(i); // 抛出错误 </span><br></pre></td></tr></table></figure>

<p>前面的代码在执行到 IIFE 外部的 console.log()时会出错，因为它访问的变量是在 IIFE 内部定义的，在外部访问不到。</p>
<p>在 ECMAScript 5.1 及以前，为了防止变量定义外泄，IIFE 是个非常有效的方式。 这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕， 其作用域链就可以被销毁。 在 </p>
<p>ECMAScript 6 以后，IIFE 就没有那么必要了，因为块级作用域中的变量无须 IIFE 就可以实现同 样的隔离。下面展示了两种不同的块级作用域形式： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内嵌块级作用域  </span></span><br><span class="line">&#123;  </span><br><span class="line">	<span class="keyword">let</span> i;  </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;  </span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">		&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误 </span></span><br><span class="line"><span class="comment">// 循环的块级作用域 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;  </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 抛出错误 </span></span><br></pre></td></tr></table></figure>

<p>说明 IIFE 用途的一个实际的例子，就是可以用它锁定参数值。比如： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);  <span class="comment">// 达不到目的！  </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;  </span><br><span class="line">	divs[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">	&#125;);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里使用 var 关键字声明了循环迭代变量 i，但这个变量并不会被限制在 for 循环的块级作用域内。 因此，渲染到页面上之后，点击每个都会弹出元素总数。这是因为在执行单击处理程序时，迭代变 量的值是循环结束时的最终值，即元素的个数。而且，这个变量 i 存在于循环体外部，随时可以访问。 以前，为了实现点击第几个</p>
<p>就显示相应的索引值，需要借助 IIFE 来执行一个函数表达式，传 入每次循环的当前索引，从而“锁定”点击时应该显示的索引值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>);  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;  </span><br><span class="line">	divs[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, (<span class="keyword">function</span>(<span class="params">frozenCounter</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;  </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(frozenCounter);  </span><br><span class="line">        &#125;;  </span><br><span class="line">        &#125;)(i));  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而使用 ECMAScript 块级作用域变量，就不用这么大动干戈了：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> divs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;div&#x27;</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; divs.<span class="property">length</span>; ++i) &#123;  </span><br><span class="line">	divs[i].<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(i);  </span><br><span class="line">	&#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/06/28/%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91/" data-id="cmcgaht3600004sur1w0e7uo4" data-title="基础开发" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html-css-javascript/" rel="tag">html css javascript</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html-css-javascript/" rel="tag">html css javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typescript/" rel="tag">typescript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E3%80%81%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/" rel="tag">前端工程、包管理器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E3%80%81%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E3%80%81/" rel="tag">前端页面、错误监控、</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8E%9F%E7%90%86/" rel="tag">原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/" rel="tag">场景设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/" rel="tag">大模型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" rel="tag">计算机网络，浏览器原理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/React/" style="font-size: 10px;">React</a> <a href="/tags/html-css-javascript/" style="font-size: 10px;">html css javascript</a> <a href="/tags/typescript/" style="font-size: 10px;">typescript</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E3%80%81%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/" style="font-size: 10px;">前端工程、包管理器</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E3%80%81%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E3%80%81/" style="font-size: 10px;">前端页面、错误监控、</a> <a href="/tags/%E5%8E%9F%E7%90%86/" style="font-size: 10px;">原理</a> <a href="/tags/%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">场景设计</a> <a href="/tags/%E5%A4%A7%E6%A8%A1%E5%9E%8B/" style="font-size: 10px;">大模型</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/" style="font-size: 10px;">计算机网络，浏览器原理</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/07/">July 2025</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">June 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/07/04/%E4%B8%9A%E5%8A%A1/">业务</a>
          </li>
        
          <li>
            <a href="/2025/07/03/Vue/">Vue</a>
          </li>
        
          <li>
            <a href="/2025/07/01/AI/">AI</a>
          </li>
        
          <li>
            <a href="/2025/07/01/React%E8%A1%A5%E5%85%85/">React补充</a>
          </li>
        
          <li>
            <a href="/2025/06/29/React/">React</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>